[".folder", "phosphorus", [[".folder", "packages", []], [".folder", "build", [[".osl", "script", "opal_imports = {}\ndef import(path) (\n  switch path (\n\ncase \"./src/devtools/menus/storage.osl\"\n  class __imports__968375a74382766e626cb371cd10b43a (\n    \n  )\n  return __imports__968375a74382766e626cb371cd10b43a\ncase \"./src/devtools/menus/network.osl\"\n  class __imports__b4ec205ca81f7630cd7f76511fd744fb (\n    \n  )\n  return __imports__b4ec205ca81f7630cd7f76511fd744fb\ncase \"./src/devtools/menus/console.osl\"\n  class __imports__ac7f1c744ff0d794c130cdf96196926d (\n    def getInst() (\n      return layouts.shared.state.currentDocument.rtrInst\n    )\n    \n    def topbar() (\n      local inst @= self.getInst()\n      \n      goto frame.left + 10 0\n      square 15 15 0 0 1\n      if inst != null (\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            inst.console @= []\n          )\n        )\n        c shared.theme.text\n      ) else (\n        if mouse_touching (\n          cursor \"not-allowed\"\n        )\n        c shared.theme.seco\n      )\n      icon \"w 2.5 cutcircle 0 0 10 0 180 line -6 -6 6 6\" .7\n    )\n    \n    def update() (\n      local inst @= self.getInst()\n      \n      local y = frame.top\n      local start = y\n      \n      for ii inst.console.len (\n        local item @= inst.console[ii]\n        local lines @= item[2].wrapText(frame.width - 10 / 10).split(\"\\n\")\n        local height = lines.len * 20\n        \n        local col = null\n        if item[1] == \"err\" (\n          col = #f00\n        )\n        \n        local ly = y\n        local sy = y\n        \n        y -= 5\n        y -= height\n        y -= 5\n        \n        if col != null (\n          frame frame.left y frame.right ly (\n            c col\n            pen \"opacity\" 20\n            pen \"size\" 10000\n            pen \"down\"\n            pen \"up\"\n          )\n        )\n        \n        for i lines.len (\n          ly -= 10\n          goto frame.left + 5 ly - 5\n          text lines[i] 10 : c#shared.theme.text\n          ly -= 10\n        )\n        \n        pen \"size\" 2 : c#shared.theme.prim\n        \n        goto 0 sy\n        line frame.left 0 frame.right 0\n        \n        goto 0 y\n        line frame.left 0 frame.right 0\n      )\n    )\n  )\n  return __imports__ac7f1c744ff0d794c130cdf96196926d\ncase \"./src/devtools/menus/elements.osl\"\n  class __imports__7de0f89117b2e081473955ae82bcf430 (\n    number indent = 20\n    \n    number x = 0\n    number y = 0\n    \n    number maxX = 0\n    \n    def drawElements(array elements) (\n      for i elements.len (\n        if elements[i] != null (\n          drawElement(elements[i])\n        )\n        if i < elements.len (\n          text \",\" 10\n        )\n      )\n    )\n    \n    def drawElement(object element) (\n      if element.children != null or element.kind == \"script\" (\n        self.y -= 15\n        goto 0 self.y\n        \n        element.dvt_open ??= false\n        \n        goto self.x self.y\n        square 20 20 0 0 1 : c#fff\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            element.dvt_open = !element.dvt_open\n          )\n        )\n        icon element.dvt_open ? \"down\" \"right\" .5 : c#shared.theme.text\n        \n        text element.blockName ?? element.name 10 : chx#15\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            element.dvt_open = !element.dvt_open\n          )\n        )\n        \n        self.y -= 15\n        \n        if element.dvt_open (\n          text \"{\" 10 : chx#10\n          self.maxX = max(self.maxX, x_position)\n          self.x += self.indent\n          \n          if element.kind == \"script\" (\n            local content = element.body\n            local lines @= content.split(\"\\n\")\n            local line_height = 25\n            local height = lines.len - 1 * line_height + 5\n            \n            local cy = self.y - 2.5\n            self.y -= height\n            \n            for i lines.len (\n              cy -= line_height / 2\n              \n              goto self.x cy\n              \n              self.maxX = max(self.maxX, x_position + (lines[i].len * 10))\n              text lines[i].trimText(frame.right - x_position - 17.5 / 8) 10 : c#shared.theme.text\n              \n              cy -= line_height / 2\n            )\n          ) else (\n            drawElements(element.children)\n          )\n          \n          self.x -= self.indent\n          \n          self.y -= 15\n          goto self.x - 5 self.y\n          text \"}\" 10\n          self.y -= 15\n        ) else (\n          if element.kind == \"script\" (\n            text \"{\" 10 : chx#10\n            drawTooLong() : chx#10\n            text \"}\" 10 : chx#10\n          ) else (\n            text \"{\" 10 : chx#10\n            drawMiniChildren(element.children) : chx#10\n            text \"}\" 10 : chx#10\n          )\n          self.maxX = max(self.maxX, x_position)\n        )\n      ) else (\n        self.y -= 15\n        goto self.x self.y\n        drawValue(element.value)\n        self.y -= 15\n      )\n    )\n    \n    def drawValue(object value) (\n      switch value.type (\n        case \"str\"\n          text value.value.JsonStringify() 10\n          break\n        case \"num\"\n          text value.value 10\n          break\n      )\n    )\n    \n    def drawMiniChildren(array children) (\n      if children.len == 0 (\n        change_x -20\n        return\n      )\n      \n      change_x 5\n      for i children.len (\n        drawMiniChild(children[i])\n        if i < children.len (\n          text \", \" 6\n        )\n      )\n      change_x 5\n      \n      change_x -20\n    )\n    \n    def drawMiniChild(object element) (\n      if element.children != null or element.kind == \"script\" (\n        text element.blockName ?? element.name 7\n        text \"{\" 7 : chx#10\n        drawTooLong()\n        text \"}\" 7 : chx#20\n      ) else (\n        text \"Element\" 7\n      )\n    )\n    \n    def drawTooLong() (\n      text \"...\" 8 : chx#5\n      change_x -15\n    )\n    \n    def update() (\n      local document @= layouts.shared.state.currentDocument\n      local elements @= document.rwlInst.elements\n      \n      local s = frame.scroll_h * -1\n      self.x = frame.left + s + 15\n      local startX = self.x - 20\n      self.y = frame.top + frame.scroll\n      local startY = self.y\n      \n      self.width = 0\n      self.maxX = 0\n      \n      if elements != null (\n        drawElements(elements)\n      )\n      \n      self.width = self.maxX - startX\n      self.height = startY - self.y + 5\n    )\n  )\n  return __imports__7de0f89117b2e081473955ae82bcf430\ncase \"./src/layouts/summit/topbar.osl\"\n  class __imports__6a477e7780a631dfc33d414269cd6008 (\n    def update(array area) (\n      goto rwl.area.centerX(area) rwl.area.centerY(area)\n      square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n      \n      local btns @= layouts.shared.topbar.defaultButtons\n      void layouts.shared.topbar.winButtons(btns, false)\n      \n      local titlebarX = max(area[1], window.left + 30)\n      goto titlebarX + 10 rwl.area.centerY(area)\n      if layouts.shared.state.currentDocument != null (\n        local icn = layouts.shared.state.currentDocument.getIcon()\n        if icn != null (\n          icon icn 1 : c#fff chx#7.5\n          change_x 17.5\n        )\n        text layouts.shared.state.currentDocument.getTitle() 10 : c#shared.theme.text\n      )\n      \n      frame area[1] area[4] titlebarX area[2] (\n        goto 0 0\n        square frame.width - 5 25 0 0 1\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            layouts.summit.sidebar.open = true\n          )\n        )\n        icon \"right\" .6 : c#shared.theme.text chx#5\n      )\n    )\n  )\n  return __imports__6a477e7780a631dfc33d414269cd6008\ncase \"./src/layouts/summit/sidebar.osl\"\n  class __imports__3dfd082eaa91cc9b8340f13c6baac410 (\n    open_width = 250\n    \n    width = 200\n    tar_width = open_width\n    open = true\n    \n    def update(array area) (\n      goto rwl.area.centerX(area) rwl.area.centerY(area)\n      square rwl.area.width(area) - 20 rwl.area.height(area) - 20 10 : c#shared.theme.back\n      \n      frame area[1] + 10 area[4] - 10 area[3] - 10 area[4] - 35 (\n        //square 1000 1000 1000 : c#fff\n        goto frame.right - 12.5 0\n        square 20 20 0 0 1 : c#fff\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            self.open = false\n          )\n        )\n        goto frame.right - 12.5 0\n        icon \"left\" .6 : c#shared.theme.text\n        \n        goto frame.left + 12.5 0\n        square 20 20 0 0 1 : c#fff\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            void layouts.shared.state.openEmptyTab()\n          )\n        )\n        icon \"add\" .6 : c#shared.theme.text\n      )\n      \n      void layouts.shared.urlbar.update([\n        area[1] + 10,\n        area[4] - 40 - 32.5,\n        area[3] - 10,\n        area[4] - 40 - 2.5\n      ])\n      \n      local height = 1000\n      c shared.theme.prim\n      frame area[1] + 5 area[4] - 40 - 35 area[3] - 5 area[2] + 5 height \"browser_sidebar\" (\n        local y = frame.top + frame.scroll\n        \n        for i layouts.shared.state.tabs.len (\n          local tab @= layouts.shared.state.tabs[i]\n          \n          local title = tab.document.getTitle()\n          local icon = tab.document.getIcon()\n          y -= 20\n          \n          local close_touching = false\n          \n          goto frame.right - 22.5 y\n          square 15 15 0 0 1\n          local close_touching = mouse_touching\n          \n          goto 0 y\n          c layouts.shared.state.currentTab == i ? shared.theme.seco shared.theme.prim\n          square frame.width - 25 20 15 : hover_c#shared.theme.tert\n          if mouse_touching and !close_touching (\n            cursor \"pointer\"\n            if onclick (\n              void layouts.shared.state.selectTab(i)\n            )\n          )\n          square frame.width - 25 20 10 : c#shared.theme.back\n          \n          goto frame.left + 15 y\n          if icon != null (\n            icon icon .9 : c#user.theme.text chx#7.5\n            change_x 15\n          )\n          text title.trimText(frame.right - x_position / 9 - 4) 9 : c#shared.theme.text tooltip#title\n          \n          goto frame.right - 22.5 y\n          square 15 15 0 0 1\n          if mouse_touching (\n            cursor \"pointer\"\n            if onclick (\n              void layouts.shared.state.closeTab(i)\n              i --\n            )\n          )\n          icon \"close\" .5\n          \n          y -= 20\n        )\n      )\n      \n      // clicking on the left side of the window opens the sidebar\n      if self.width < 25 (\n        goto window.left 0\n        square 20 window.height 0 0 1\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            self.open = true\n          )\n        )\n      )\n      \n      self.tar_width = self.open ? self.open_width 5\n      self.width += self.tar_width - self.width * min(delta_time, 0.02) * 10\n    )\n  )\n  return __imports__3dfd082eaa91cc9b8340f13c6baac410\ncase \"./src/layouts/summit/main.osl\"\n  class __imports__70bd3fa18cef0c20ca734751135b82d8 (\n    def init() (\n      void shared.document.init()\n      void layouts.shared.state.init()\n    )\n    \n    def update() (\n      void shared.theme.load()\n      \n      window.show()\n      window_colour = #000\n      \n      glass:frame window.left window.top window.right window.bottom; frame \"clear\"\n      \n      void layouts.shared.state.resetDragbox()\n      \n      layouts.shared.state.dragbox[1][3] = max(layouts.summit.sidebar.width, 30)\n      \n      void layouts.summit.sidebar.update([\n        window.left + layouts.summit.sidebar.width - layouts.summit.sidebar.open_width,\n        window.bottom,\n        window.left + layouts.summit.sidebar.width,\n        window.top\n      ])\n      \n      void layouts.summit.topbar.update([\n        window.left + layouts.summit.sidebar.width,\n        window.top - 37.5,\n        window.right - 5,\n        window.top - 5\n      ])\n      \n      void layouts.shared.view.render([\n        window.left + layouts.summit.sidebar.width,\n        window.bottom + 5,\n        window.right - 5,\n        window.top - 42.5\n      ])\n      \n      void layouts.shared.state.applyDragbox()\n    )\n  )\n  return __imports__70bd3fa18cef0c20ca734751135b82d8\ncase \"./src/layouts/chromeLike/topbar.osl\"\n  class __imports__0f6f8e5da8ad7dfb8f0386ba0c4b7fd4 (\n    def tabs() (\n      local space = window.width - 100 - 17.5 - 15\n      \n      local hovered = false\n      \n      local x = 0\n      local tabMax = space / layouts.shared.state.tabs.len - 5\n      for i layouts.shared.state.tabs.len (\n        local tab @= layouts.shared.state.tabs[i]\n        \n        local title = tab.document.getTitle()\n        local icon = tab.document.getIcon()\n        \n        local pad = 15 + 27.5\n        if icon != null (\n          pad += 20\n        )\n        //local width = title.len * 9 + pad\n        local width = 200\n        //width = max(width, 200)\n        width = min(width, tabMax)\n        \n        local lx = x\n        x += 2.5 + (width / 2)\n        \n        loc 2 2 x + (width / 2) - 17.5 -20\n        square 15 15 0 0 1\n        local close_touching = mouse_touching\n        \n        loc 2 2 x -20\n        \n        square width - 17.5 17.5 15 0 1\n        c mouse_touching ? shared.theme.seco shared.theme.prim\n        if layouts.shared.state.currentTab == i (\n          c shared.theme.tert\n        )\n        square width - 17.5 17.5 15\n        \n        if mouse_touching and !close_touching (\n          layouts.shared.state.dragbox @= [\n            [2, 2, lx, 0],\n            [2, 2, lx + width, -20]\n          ]\n          hovered = true\n          \n          cursor \"pointer\"\n          if onclick (\n            void layouts.shared.state.selectTab(i)\n          )\n        )\n        \n        square width - 17.5 17.5 10 : c#shared.theme.prim\n        \n        if icon != null (\n          lx += 20\n          loc 2 2 lx -20\n          icon icon .9 : c#user.theme.text\n          lx += 5\n        )\n        lx += 10\n        \n        loc 2 2 lx -20\n        text title.trimText(width - pad / 9) 9 : c#shared.theme.text tooltip#title\n        \n        lx += 5\n        loc 2 2 x + (width / 2) - 17.5 -20\n        square 15 15 0 0 1\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            void layouts.shared.state.closeTab(i)\n            i --\n          )\n        )\n        icon \"close\" .5\n        \n        x += 2.5 + (width / 2)\n      )\n      \n      x += 17.5\n      loc 2 2 x -20\n      square 17.5 17.5 15 : c#shared.theme.prim hover_c#shared.theme.seco\n      if mouse_touching (\n        cursor \"pointer\"\n        if onclick (\n          void layouts.shared.state.openEmptyTab()\n        )\n      )\n      icon \"add\" .6 : c#user.theme.text\n      x += 20\n      \n      loc -2 2 -90 -20\n      line 0 -20 0 20 : c#shared.theme.prim w#1\n      \n      if !hovered (\n        layouts.shared.state.dragbox[1][3] += x\n      )\n    )\n  )\n  return __imports__0f6f8e5da8ad7dfb8f0386ba0c4b7fd4\ncase \"./src/layouts/chromeLike/main.osl\"\n  class __imports__34355e72215dbff81e1963b1534949ee (\n    def init() (\n      void shared.document.init()\n      void layouts.shared.state.init()\n    )\n    \n    def update() (\n      void shared.theme.load()\n    \n      window.show()\n      window_colour = shared.theme.back\n      \n      void layouts.shared.state.resetDragbox()\n    \n      local btns @= layouts.shared.topbar.defaultButtons\n      void layouts.shared.topbar.winButtons(btns, false)\n      \n      void layouts.chromeLike.topbar.tabs()\n      \n      void layouts.shared.urlbar.update([\n        window.left,\n        window.top - 45 - 30,\n        window.right,\n        window.top - 44\n      ])\n      \n      void layouts.shared.view.render([\n        window.left,\n        window.bottom,\n        window.right,\n        window.top - 45 - 32.5\n      ])\n      \n      void layouts.shared.state.applyDragbox()\n    )\n  )\n  return __imports__34355e72215dbff81e1963b1534949ee\ncase \"./src/layouts/shared/view.osl\"\n  class __imports__5228a5cd2bf6a46e3a340119920c2e17 (\n    def render(array area) (\n      local devtoolsData @= devtools.main ?? { width: 0, anchor: \"l\" }\n      \n      local devtoolsArea @= rwl.area.copy(area)\n      local contentArea @= rwl.area.copy(area)\n      switch devtoolsData.anchor (\n        case \"l\"\n          contentArea[1] += devtoolsData.width\n          devtoolsArea[3] = contentArea[1]\n          break\n        case \"r\"\n          contentArea[3] -= devtoolsData.width\n          devtoolsArea[1] = contentArea[3]\n          break\n      )\n      \n      devtoolsArea[1] += 5\n      \n      if layouts.shared.state.currentDocument != null (\n        void layouts.shared.state.currentDocument.checkResp()\n        void layouts.shared.state.currentDocument.render(contentArea)\n      )\n      \n      if typeof(devtools) == \"object\" (\n        void devtools.main.update(devtoolsArea, area)\n      )\n    )\n  )\n  return __imports__5228a5cd2bf6a46e3a340119920c2e17\ncase \"./src/layouts/shared/urlbar.osl\"\n  class __imports__e1f3f683350eb46be2bb39ac4a8762b8 (\n    inputId = \"browser_url\"\n    \n    def update(array area) (\n      local defaultText = \"blehh\"\n      \n      goto rwl.area.centerX(area) rwl.area.centerY(area) + 2.5\n      \n      local w = rwl.area.width(area) - 15\n      local h = rwl.area.height(area) - 0\n      \n      square w - 5 h - 18 15 : c#shared.theme.prim\n      input w h - 5 self.inputId defaultText 0 shared.theme.text\n      \n      if inputs.selected.id == self.inputId (\n        if \"enter\".onKeyDown() (\n          void self.goto()\n        )\n      )\n      \n      //void shared.graphics.box(area, #f00)\n    )\n    \n    def goto() (\n      local url = inputs[self.inputId]\n      \n      url @= shared.url.Url(url)\n      \n      local tab @= layouts.shared.state.tabs[layouts.shared.state.currentTab]\n      void tab.redirect(url)\n    )\n  )\n  return __imports__e1f3f683350eb46be2bb39ac4a8762b8\ncase \"./src/layouts/shared/topbar.osl\"\n  class __imports__bce8e403422ca1f602a36f77e9c471c6 (\n    array defaultButtons = [\n      {\n        icon: \"close\",\n        click: window.close\n      },\n      {\n        icon: \"down\",\n        click: window.minimise\n      },\n      {\n        icon: \"maximise\",\n        click: window.fullscreen\n      }\n    ]\n    \n    def winButtons(array buttons, boolean background) (\n      if background (\n        local w = buttons.len * 25\n        \n        loc -2 2 w / -2 - 7.5 -20\n        square w - 5 18 10 : c#shared.theme.prim\n      )\n      \n      loc -2 2 -20 -20\n      change_x 25\n      for i buttons.len (\n        local button @= buttons[i]\n        \n        c shared.theme.text\n        icon button.icon 0.6 * (button.icon_size ?? 1) : hover_size#1.1 chx#-25\n        if mouse_touching (\n          cursor \"pointer\"\n          if onclick (\n            void button.click()\n          )\n        )\n      )\n    )\n  )\n  return __imports__bce8e403422ca1f602a36f77e9c471c6\ncase \"./src/layouts/shared/utils.osl\"\n  class __imports__bd7a86c2700e28469496d9f67248c0b2 (\n    def getContentArea() (\n      return [\n        window.left,\n        window.bottom,\n        window.right,\n        window.top - 50\n      ]\n    )\n  )\n  return __imports__bd7a86c2700e28469496d9f67248c0b2\ncase \"./src/layouts/shared/state.osl\"\n  class __imports__d1763f06b30a5d5d9c10608cf0f00c3e (\n    debug = false\n    \n    def init() (\n      void self.updateTab()\n      void self.selectTab(1)\n      \n      self.tabs @= []\n    )\n    \n    def resetDragbox() (\n      self.dragbox @= [[2,2,0,0],[-2,2,-90,-40]]\n    )\n    \n    def applyDragbox() (\n      window.setDragbox(self.dragbox[1], self.dragbox[2])\n      \n      if self.debug (\n        c #fff\n        loc self.dragbox[1][1] self.dragbox[1][2] self.dragbox[1][3] self.dragbox[1][4]\n        pen \"down\"\n        loc self.dragbox[2][1] self.dragbox[2][2] self.dragbox[2][3] self.dragbox[2][4]\n        pen \"up\"\n      )\n    )\n    \n    def openTabDocument(object document) (\n      local tab @= shared.tab.Tab(document)\n      void self.tabs.append(tab)\n      void self.selectTab(self.tabs.len)\n    )\n    \n    def openEmptyTab() (\n      void self.openTabDocument(shared.document.Document())\n    )\n    \n    def closeTab(number index) (\n      void self.tabs[index].document.close()\n      void self.tabs.delete(index)\n      \n      if index < self.currentTab (\n        self.currentTab --\n      )\n      \n      void self.selectTab(self.currentTab)\n    )\n    \n    def selectTab(number index) (\n      self.currentTab @= index\n      void self.updateTab()\n      inputs[layouts.shared.urlbar.inputId] = self.currentDocument.url.text\n    )\n    \n    def updateTab() (\n      self.currentDocument @= self.tabs[self.currentTab].document\n      //self.currentDocument ??= shared.document.Document()\n    )\n  )\n  return __imports__d1763f06b30a5d5d9c10608cf0f00c3e\ncase \"./src/devtools/topbar.osl\"\n  class __imports__3261b0e52c0051dec0dc6394c943d033 (\n    tabs_scroll = 0\n    tabs_width = 0\n    \n    def update() (\n      goto 0 -5\n      square frame.width - 10 frame.height 10 : c#shared.theme.prim\n      \n      square frame.width frame.height 0 0 1\n      if mouse_touching (\n        self.tabs_scroll += scroll.x.velocity + scroll.y.velocity * scroll.multiplier * 1.5\n      )\n      \n      self.tabs_scroll = min(self.tabs_scroll, self.tabs_width - frame.width)\n      self.tabs_scroll = max(self.tabs_scroll, 0)\n      \n      local x = frame.left - self.tabs_scroll\n      local start = x\n      local menus @= devtools.menus.getEntries()\n      for i menus.len (\n        local menu @= menus[i]\n        \n        local title = menu[1].toTitle()\n        local w = title.len * 8 + 10\n        \n        x += w / 2\n        \n        goto x 0\n        square w - 10 10 10 0 1\n        c devtools.main.menu == menu[1] ? shared.theme.seco shared.theme.prim\n        if mouse_touching (\n          c shared.theme.tert\n          cursor \"pointer\"\n          if onclick (\n            devtools.main.menu = menu[1]\n          )\n        )\n        pen \"size\" 2\n        line w / -2 -11 w / 2 -11\n        centext title 8 : c#shared.theme.text\n        \n        x += w / 2\n      )\n      self.tabs_width = x - start\n    )\n  )\n  return __imports__3261b0e52c0051dec0dc6394c943d033\ncase \"./src/devtools/main.osl\"\n  class __imports__87f5572a1b07abb6f61e525f0557da7a (\n    string anchor = \"r\"\n    number width = 350\n    number resizingEdge = 0\n    \n    menu = \"console\"\n    \n    def update(array area, array rawArea) (\n      goto rwl.area.centerX(area) rwl.area.centerY(area)\n      square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n      \n      local h = 25\n      frame area[1] area[4] area[3] area[4] - h (\n        void devtools.topbar.update()\n      )\n      \n      if mouse_y > area[2] and mouse_y < area[4] (\n        if anchor == \"r\" and abs(mouse_x - area[1]) < 5 (\n          cursor \"col-resize\"\n          goto mouse_x mouse_y\n          square 100 100 0 0 1\n          if onclick (\n            self.resizingEdge = 1\n          )\n        )\n        if anchor == \"l\" and abs(mouse_x - area[3]) < 5 (\n          cursor \"col-resize\"\n          goto mouse_x mouse_y\n          square 100 100 0 0 1\n          if onclick (\n            self.resizingEdge = 3\n          )\n        )\n      )\n      \n      if !mouse_down (\n        self.resizingEdge = 0\n      )\n      \n      if self.resizingEdge != 0 (\n        self.width = abs(mouse_x - area[4 - self.resizingEdge])\n      )\n      self.width = min(self.width, rwl.area.width(rawArea) - 200)\n      self.width = max(self.width, 200)\n      \n      local menu @= devtools.menus[self.menu]\n      \n      c shared.theme.prim\n      local topbarH = 0\n      if menu.topbar != null (\n        topbarH = 25\n        frame area[1] area[4] - h area[3] area[4] - h - topbarH (\n          void menu.topbar()\n        )\n        local w = rwl.area.width(area)\n        goto rwl.area.centerX(area) area[4] - h - topbarH\n        pen \"size\" 2\n        line w / -2 -1 w / 2 -1 : c#shared.theme.prim\n        topbarH += 1\n      )\n      \n      c shared.theme.prim\n      frame area[1] area[4] - h - topbarH area[3] area[2] [menu.width,menu.height] \"devtools_\" ++ self.menu (\n        if menu != null (\n          if menu.update != null (\n            void menu.update()\n          )\n        ) else (\n          goto 0 0\n          centext \"no open devtools menu\" 9 : c#shared.theme.prim\n        )\n      )\n    )\n  )\n  return __imports__87f5572a1b07abb6f61e525f0557da7a\ncase \"./src/net/response.osl\"\n  class __imports__f336b41d073413cbdabb122f71c530f0 (\n    class Response (\n      isValid = false\n      \n      def init(object url, string content) (\n        self.url @= url\n        self.content = content\n        \n        self.isFinished = true\n      )\n    )\n    \n    class NoResponse extends Response (\n      \n    )\n    \n    class ValidResponse extends Response (\n      isValid = true\n      \n      def init(object url) (\n        self.url @= url\n        \n        self.isFinished = false\n      )\n      \n      def update() (\n        void self.fetch()\n      )\n    )\n  )\n  return __imports__f336b41d073413cbdabb122f71c530f0\ncase \"./src/net/fetch.osl\"\n  class __imports__d974ce5692d372884f5c4f8f8bf1ab18 (\n    def url(object url) (\n      if url.scheme == \"local\" (\n        local f @= open(url.domain_name).toStr()\n        local r @= net.response.ValidResponse(url)\n        r.fetch @= def() -> (\n          self.content = self.f\n          self.isFinished = true\n        )\n        r.f @= f\n        return r\n      )\n    \n      local servers @= shared.config.net.servers\n      local server @= servers[url.scheme]\n      \n      if server == null (\n        local r @= net.response.NoResponse(url, \"scheme '\" ++ url.scheme ++ \"' not found\")\n        return r\n      )\n      \n      local resource = url.domain_top\n      resource ++= \"/\"\n      if url.domain_sub != null (\n        resource ++= url.domain_sub\n        resource ++= \".\"\n      )\n      resource ++= url.domain_name\n      if url.resource != null (\n        resource ++= \"/\"\n        resource ++= url.resource\n      )\n      \n      local tld = server.tlds[url.domain_top]\n      \n      if tld == null (\n        local r @= net.response.NoResponse(url, \"tld '\" ++ url.domain_top ++ \"' not found\")\n        return r\n      )\n      \n      local realUrl = tld ++ \"/\" ++ resource\n      \n      local r @= net.response.ValidResponse(url)\n      r.fetch @= def() -> (\n        local o = self.realUrl.getAsync()\n        if o != \"Loading\" and o != \"404: Not Found\" (\n          self.content = o\n          self.isFinished = true\n        )\n      )\n      r.realUrl = realUrl\n      \n      return r\n    )\n  )\n  return __imports__d974ce5692d372884f5c4f8f8bf1ab18\ncase \"./src/shared/tab_worker.osl\"\n  class __imports__ed11349f32bd7389fac05d89b56e016d (\n    def oncreate() (\n      \n    )\n    \n    def onframe() (\n      if self.parseText != null (\n        local parser @= rwl.ast.Parser(self.parseText)\n        if self != null (\n          //log self\n          void self.document.loadAst(parser.parse())\n          self.parseText = null\n        )\n      )\n    )\n  )\n  return __imports__ed11349f32bd7389fac05d89b56e016d\ncase \"./src/shared/config.osl\"\n  class __imports__9f198a2aa8925b082e5f887a2bba9b67 (\n    class net (\n      servers = {\n        //rtr: {\n        //  url: \"http://localhost:3000/\",\n        //  \n        //  // <server>/<command>\n        //  commands: {\n        //    tlds: \"tlds\"\n        //  }\n        //}\n      }\n      \n      def refresh() (\n        for i self.servers.len (\n          local s @= self.servers.getValues()[i]\n          s.tlds @= (s.url ++ s.commands.tlds).httpGet()\n        )\n      )\n    )\n    \n    net.refresh()\n    \n    class url (\n      class defaults (\n        scheme = \"rtr\"\n        name = \"unknown\"\n        top = \"web\"\n      )\n    )\n  )\n  return __imports__9f198a2aa8925b082e5f887a2bba9b67\ncase \"./src/shared/theme.osl\"\n  class __imports__5876b7f6fcd5ce7f0fafd1a44ec4bd74 (\n    def load() (\n      self.back = user.theme.background\n      self.prim = user.theme.primary\n      self.seco = user.theme.secondary\n      self.tert = user.theme.tertiary\n      self.text = user.theme.text\n    )\n    \n    load()\n  )\n  return __imports__5876b7f6fcd5ce7f0fafd1a44ec4bd74\ncase \"./src/shared/url.osl\"\n  class __imports__a1d00c2cd890aa6e92598446ff24f924 (\n    class Url (\n      def init(string text) (\n        void self.parse(text)\n      )\n      \n      def parse(string text) (\n        self.text = text\n        local s @= text.match(\"/^((\\\\w+):\\\\/\\\\/)/\")\n        local match @= text.match(\"/^((\\\\w+):\\\\/\\\\/)?(((\\\\w+)\\\\.)?(\\\\w+)(\\\\.(\\\\w+))?\\\\/?(([\\\\/w]+)?(\\\\/(\\\\w+\\\\.\\\\w+))?))\\\\/?/\")\n        \n        self.scheme = match[3] ?? s[3] ?? shared.config.url.defaults.scheme\n        \n        if self.scheme == \"local\" (\n          self.domain_name = text.trim(\"local://\".len + 1, -1)\n          local usrPath = \"origin/(c) users/\" ++ username\n          if self.domain_name.toLower().startsWith(usrPath.toLower()) (\n            self.domain_name = \"~\" ++ self.domain_name.trim(usrPath.len + 1, -1)\n          )\n          self.domain_top = null\n          self.domain_sub = null\n          self.path = null\n          self.params @= {}\n          self.resource = null\n          self.text = \"local://\" ++ self.domain_name\n          return\n        )\n        \n        if match[9] != null (\n          local domain_name = match[7]\n          local domain_top = match[9]\n          local domain_sub = match[6]\n        ) else (\n          if match[6] != null (\n            local domain_name = match[6]\n            local domain_top = match[7]\n            local domain_sub = null\n          ) else (\n            local domain_name = match[7]\n            local domain_top = null\n            local domain_sub = null\n          )\n        )\n        \n        self.domain_name = domain_name ?? shared.config.url.defaults.name\n        self.domain_top = domain_top ?? shared.config.url.defaults.top\n        self.domain_sub = domain_sub\n        self.path = match[13]\n        self.params @= {}\n        self.resource = match[10] ?? \"index.rwl\"\n      )\n      \n      def format() (\n        local sub = self.domain_sub != null ? self.domain_sub ++ \".\" \"\"\n        local top = self.domain_top != null ? \".\" ++ self.domain_top \"\"\n        local txt = self.scheme ++ \"://\" ++ sub ++ domain_name ++ top\n        if self.path != null (\n          txt ++= \"/\" ++ self.path\n        )\n        if self.file_name != \"index.osl\" (\n          txt ++= \"/\" ++ self.file_name\n        )\n        return txt\n      )\n      \n      def getTitle() (\n        if self.scheme == \"local\" (\n          return self.domain_name.split(\"/\")[-1].split(\".\")[1]\n        )\n        return self.domain_name\n      )\n    )\n  )\n  return __imports__a1d00c2cd890aa6e92598446ff24f924\ncase \"./src/shared/tab.osl\"\n  class __imports__0ffc38803b2c8e6e0623c0ea1ffbcc28 (\n    class Tab (\n      def init(object document) (\n        self.document @= document\n      )\n      \n      def redirect(object url) (\n        void self.document.loadUrl(url)\n      )\n    )\n  )\n  return __imports__0ffc38803b2c8e6e0623c0ea1ffbcc28\ncase \"./src/shared/document.osl\"\n  class __imports__af13446f70bd7836009892ffef4b5078 (\n    class Document (\n      def init() (\n        void self.createInsts()\n        \n        void self.createWorker()\n      )\n      \n      def close() (\n        void self.killWorker()\n      )\n      \n      def createWorker() (\n        //log \"create worker\"\n        void killWorker()\n        self.worker @= worker(shared.tab_worker)\n        self.worker.document @= self\n      )\n      \n      def killWorker() (\n        if self.worker != null (\n          //log \"kill worker\"\n          void self.worker.kill()\n          self.worker = null\n        )\n      )\n      \n      def createInsts() (\n        self.title = \"New Tab\"\n        if self.url != null (\n          self.title = self.url.getTitle()\n        )\n        self.icon = null\n        \n        self.rtrInst @= rtr.main.RTR()\n        self.rwlInst @= rwl.main.RWL(shared.document.empty, self.rtrInst)\n      )\n      \n      def updateInsts() (\n        // inject rwl apis\n        void rtr.rwl.addToInst(self, self.rtrInst)\n        \n        // start onloads\n        void self.rtrInst.startModules()\n      )\n      \n      def update(array area) (\n        void self.rwlInst.update(area)\n      )\n      \n      def render(array area) (\n        if self.worker != null (\n          self.worker.area @= area\n          if !self.worker.alive (\n            self.rwlInst.errored = true\n            self.rwlInst.errormsg = \"tab worker died, check code for syntax errors\\nyou can also check js console\"\n          )\n        )\n        \n        goto rwl.area.centerX(area) rwl.area.centerY(area)\n        square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n        \n        if self.loading (\n          goto rwl.area.centerX(area) rwl.area.centerY(area)\n          direction timer * 720\n          icon \"sync\" .75 : c#shared.theme.text\n          direction 90\n          return\n        )\n        \n        //log self.rwlInst\n        void self.rwlInst.render(area)\n      )\n      \n      def checkResp() (\n        if self.resp == null (\n          self.loading = false\n          return\n        )\n        \n        if self.resp.isFinished (\n          if self.resp.isValid (\n            self.loading = false\n            \n            void self.createInsts()\n            void self.loadText(self.resp.content)\n            \n            self.resp = null\n          )\n        ) else (\n          self.loading = true\n          void self.resp.update()\n        )\n      )\n      \n      def loadAst(object ast) (\n        void self.createInsts()\n        void self.rwlInst.loadFromAst(ast)\n        void self.updateInsts()\n      )\n      \n      def loadText(string text) (\n        void self.createWorker()\n        self.worker.parseText = text\n      )\n      \n      def loadUrl(object url) (\n        self.url @= url\n        void self.createInsts()\n        self.resp @= net.fetch.url(url)\n      )\n      \n      def getIcon() (\n        return self.icon\n      )\n      def getTitle() (\n        return self.title\n      )\n    )\n    \n    def init() (\n      local parser @= rwl.ast.Parser(import(\"./src/assets/empty.rwl\"))\n      self.empty @= parser.parse()\n    )\n  )\n  return __imports__af13446f70bd7836009892ffef4b5078\ncase \"./src/shared/utils.osl\"\n  class __imports__ace3e4fea1b83d3f4a6cf8da09fee544 (\n    def removeIndents(str) (\n      local lines @= str.split(\"\\n\")\n      local indent = null\n      for i lines.len (\n        local l2 = lines[i].match(\"/^( *)(.+)$/\")\n        if l2[2].len > 0 (\n          indent = min(indent ?? 9999, l2[2].len)\n        )\n      )\n      for i lines.len (\n        lines[i] = lines[i].trim(indent + 1, -1)\n      )\n      return lines.join(\"\\n\")\n    )\n    \n    def jsFunc(string js) (\n      local f @= js.eval()\n      local f2 @= () -> ()\n      f2.code @= f\n      return f2\n    )\n  )\n  return __imports__ace3e4fea1b83d3f4a6cf8da09fee544\ncase \"./src/shared/graphics.osl\"\n  class __imports__8840a5e065c53e817186a2216f863bca (\n    usesCanvas = false\n    \n    _canvasID = null\n    _canvas = null\n    \n    def init() (\n      if self.usesCanvas (\n        self._canvasID = OuidNew()\n        self._canvas @= shared.canvas.createCanvas(self._canvasID, window.width, window.height)\n        log self\n      )\n    )\n    \n    // cursor\n    cursor_x = 0\n    cursor_y = 0\n    def goto(number x, number y) (\n      self.cursor_x = x\n      self.cursor_y = y\n    )\n    \n    def change_x(number x) (\n      self.cursor_x += x\n    )\n    def change_y(number y) (\n      self.cursor_y += y\n    )\n    def change(number x, number y) (\n      self.cursor_x += x\n      self.cursor_y += y\n    )\n    \n    // utils\n    def getTextWidth(string text) (\n      return text.len\n    )\n    \n    // rendering\n    def box(array area, string color) (\n      c color\n      pen \"size\" 1\n      goto area[1] area[2]\n      pen \"down\"\n      goto area[3] area[2]\n      goto area[3] area[4]\n      goto area[1] area[4]\n      goto area[1] area[2]\n      pen \"up\"\n    )\n    \n    def filledBox(array area, rounding, string color) (\n      local x = rwl.area.centerX(area)\n      local y = rwl.area.centerY(area)\n      local w = rwl.area.width(area)\n      local h = rwl.area.height(area)\n      \n      c color\n      \n      if typeof(rounding) == \"number\" (\n        goto x y\n        square w - (rounding * 2) h - (rounding * 2) (rounding * 2)\n      ) else if typeof(rounding) == \"array\" (\n        // could rework this to have it be corner - rounding for pos\n        // so it would have higher parity with canvas?\n        goto x y\n        frame area[1] y x area[2] (\n          local r = min(rounding[1] * 2, min(w, h) / 2)\n          square w - r h - r r\n        )\n        frame x y area[3] area[2] (\n          local r = min(rounding[2] * 2, min(w, h) / 2)\n          square w - r h - r r\n        )\n        frame area[1] area[4] x y (\n          local r = min(rounding[3] * 2, min(w, h) / 2)\n          square w - r h - r r\n        )\n        frame x area[4] area[3] y (\n          local r = min(rounding[4] * 2, min(w, h) / 2)\n          square w - r h - r r\n        )\n      )\n    )\n    \n    def ctext(string text, number size, string color) (\n      void ptext(text, self.cursor_x, self.cursor_y, size, color)\n    )\n    def ptext(string text, number x, number y, number size, string color) (\n      goto x y\n      text text size : c#color\n    )\n  )\n  return __imports__8840a5e065c53e817186a2216f863bca\ncase \"./src/rtr/value.osl\"\n  class __imports__b2506e9c8a1f71d53780de64c11f25a1 (\n    class RTRValue (\n      boolean isReturnVal = false\n      def callFunc() (\n        throw \"cannot call\" + self.stringify(true) + \"as function\"\n      )\n    \n      def getRtrType() (\n        throw self.name + \"has not implemented getRtrType()\"\n        return rtr.value.RTRTypeValue({\n          name: \"?\"\n        })\n      )\n    \n      def stringify() (\n        return \"<\" ++ self.getRtrType().getName() ++ \">\"\n      )\n      def numbify() (\n        return NaN\n      )\n      def boolify() (\n        return true\n      )\n      def arrify() (\n        return []\n      )\n      def length() (\n        return 0\n      )\n      def getItem(key) (\n        return null\n      )\n      def setItem(key, value) (\n        throw \"cannot set items on\" + self.stringify(true)\n      )\n      def keys() (\n        return []\n      )\n      def values() (\n        return []\n      )\n      def has(key) (\n        return false\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType())\n      )\n    )\n    \n    class RTRTypeValue (\n      def init(object data) (\n        self.data @= data\n      )\n      \n      def stringify() (\n        return self.getName()\n      )\n      def getName() (\n        if self.data.name != null (\n          return self.data.name\n        )\n        return \"?\"\n      )\n      def isEqual(object other) (\n        return self.data.name == other.data.name\n      )\n    )\n    \n    class RTRLiteralValue extends RTRValue (\n      boolean isLiteral = true\n    )\n    \n    class RTRStrValue extends RTRLiteralValue (\n      def init(string value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"str\"\n        })\n      )\n      \n      def stringify(format) (\n        return format ? self.value.JsonStringify() self.value\n      )\n      def numbify() (\n        return self.value.toNum()\n      )\n      def boolify() (\n        return self.value.len > 0\n      )\n      def arrify() (\n        return self.value.split(\"\").map(e -> rtr.value.RTRStrValue(e))\n      )\n      def length() (\n        return self.value.len\n      )\n      def getItem(index) (\n        return rtr.value.RTRStrValue(self.value[index.numbify() + 1])\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRNumValue extends RTRLiteralValue (\n      def init(number value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"num\"\n        })\n      )\n      \n      def stringify() (\n        return self.value.toStr()\n      )\n      def numbify() (\n        return self.value\n      )\n      def boolify() (\n        return self.value > 0\n      )\n      def arrify() (\n        return self.value.toStr().split(\"\").map(e -> rtr.value.RTRStrValue(e))\n      )\n      def length() (\n        return self.value.toStr().length\n      )\n      def getItem(index) (\n        return self.value.toStr()[index.numbify() + 1]\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRBoolValue extends RTRLiteralValue (\n      def init(boolean value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"bool\"\n        })\n      )\n      \n      def stringify() (\n        return self.value.toStr()\n      )\n      def numbify() (\n        return self.value.toNum()\n      )\n      def boolify() (\n        return self.value\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRFuncValue extends RTRValue (\n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"func\"\n        })\n      )\n    )\n    \n    class RTROslFuncValue extends RTRFuncValue (\n      def init(func) (\n        self.func @= func\n      )\n      \n      def callFunc(object inst, array args) (\n        return self.func(args, inst) ?? rtr.value.RTRNullValue()\n      )\n    )\n    \n    class RTRAstFuncValue extends RTRFuncValue (\n      def init(array args, object body) (\n        self.args @= args\n        self.body @= body\n      )\n      \n      def callFunc(object inst, array args) (\n        local s @= {}\n        for i self.args.len (\n          local a @= self.args[i]\n          local v @= args[i] ?? rtr.value.RTRNullValue()\n          s[a.name] @= [v, {}]\n        )\n        \n        void inst.newScope(s)\n        void inst.declScopeVar(\"@return\", 0)\n        \n        local exprOut @= inst.runStatement(self.body)\n        \n        local ret @= inst.getScopeVar(\"@return\") ?? 0\n        if ret == 0 (\n          ret @= exprOut\n        )\n        \n        void inst.popScope()\n        \n        return ret\n      )\n    )\n    \n    class RTRNullValue extends RTRValue (\n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"null\"\n        })\n      )\n      \n      def boolify() (\n        return false\n      )\n      def isEqual(other) (\n        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n      )\n    )\n    \n    class RTRArrValue extends RTRValue (\n      def init(array elements) (\n        self.elements @= elements\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"arr\"\n        })\n      )\n      \n      def stringify() (\n        local el @= self.elements.map(e -> e.stringify(true))\n        return \"[\" ++ el.join(\", \") ++ \"]\"\n      )\n      def boolify() (\n        return self.elements.len > 0\n      )\n      def arrify() (\n        return self.elements\n      )\n      def length() (\n        return self.elements.len\n      )\n      def keys() (\n        local arr2 @= []\n        for i self.elements.len (\n          void arr2.append(i - 1)\n        )\n        return arr2\n      )\n      def values() (\n        return self.elements\n      )\n      def getItem(index) (\n        return self.elements[index.numbify() + 1]\n      )\n    )\n    \n    class RTRObjValue extends RTRValue (\n      def init(object value) (\n        self.value @= value\n      )\n      \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"obj\"\n        })\n      )\n      \n      def stringify() (\n        local el @= self.value.getEntries().map(e -> e[1] ++ \":\" + e[2].stringify(true))\n        return \"{\" ++ el.join(\", \") ++ \"}\"\n      )\n      def boolify() (\n        return self.value.getKeys().len > 0\n      )\n      def arrify() (\n        return self.value.getKeys().map(e -> rtr.value.RTRStrValue(e))\n      )\n      def length() (\n        return self.value.getKeys().len\n      )\n      def keys() (\n        return self.value.getKeys()\n      )\n      def values() (\n        return self.value.getValues()\n      )\n      def has(key) (\n        return self.value.getKeys().contains(key)\n      )\n      def getItem(key) (\n        return self.value[key.stringify()]\n      )\n      def setItem(key, value) (\n        self.value[key.stringify()] @= value\n      )\n    )\n  )\n  return __imports__b2506e9c8a1f71d53780de64c11f25a1\ncase \"./src/rtr/error.osl\"\n  class __imports__a51b04c580d521af176787ba84843c9a (\n    object Editors = {\n    \n    }\n    \n    class Error (\n      boolean isError = true\n      \n      def init(string type, object data) (\n        self.type = type\n        self.data @= data\n        \n        local err @= rwl.error.Errors[type]\n        if err == null (\n          self.txt = \"unknown error type\" + type\n          return\n        )\n        self.txt = err(data)\n      )\n      \n      def stringify() (\n        return \"Error<\" ++ self.type ++ \">:\\n\" ++ self.txt.split(\"\\n\").map(l -> \"    \" ++ l).join(\"\\n\")\n      )\n    )\n  )\n  return __imports__a51b04c580d521af176787ba84843c9a\ncase \"./src/rtr/ast.osl\"\n  class __imports__2691a00e099698fa56c4748f2551eb65 (\n    class Parser (\n      def init(string text) (\n        void self.tokenise(text)\n      )\n      \n      def parse() (\n        self.pointer = 1\n        \n        local out @= self.blockContent(true)\n        \n        if !self.atEnd() (\n          throw \"unexpected token\" + self.peek()\n        )\n        \n        return { elements: out }\n      )\n      \n      def peek(amount) (\n        amount ??= 1\n        return self.tokens[self.pointer + amount - 1]\n      )\n      def consume() (\n        local tkn = self.peek()\n        self.pointer ++\n        return tkn\n      )\n      def consumeWhitespace() (\n        while self.peek().match(\"/^\\\\s$/\") != null (\n          void self.consume()\n        )\n      )\n      def atEnd() (\n        return self.pointer >= self.tokens.len\n      )\n      def expect(string token) (\n        local tkn @= self.consume()\n        if tkn != token (\n          throw \"expected '\" ++ token ++ \"' got '\" ++ tkn ++ \"'\"\n        )\n        return tkn\n      )\n      def expects(array tokens) (\n        local tkn @= self.consume()\n        if !tokens.contains(tkn) (\n          throw \"expected '\" ++ tokens.join(\" or \") ++ \"' got '\" ++ tkn ++ \"'\"\n        )\n        return tkn\n      )\n      def expectText() (\n        local tkn @= self.consume()\n        if !tkn.match(\"/^[a-zA-Z_]+$/\") (\n          throw \"identifier must consist of letters or _\"\n        )\n        return tkn\n      )\n      def getPos() (\n        local ln = 1\n        local col = 0\n        local i = self.pointer\n        for t self.pointer (\n          col ++\n          if self.tokens[t] == \"\\n\" (\n            ln ++\n            col = 0\n          )\n        )\n        return { ln, col, i }\n      )\n      \n      def tokenise(string text) (\n        self.tokens @= []\n        local splitChars @= [\n          \"(\",\")\",\n          \"[\",\"]\",\n          \"{\",\"}\",\n          \",\",\";\",\":\",\"=\",\".\",\n          \"+\",\"-\",\"*\",\"/\",\"%\",\"^\",\n          \"\\\\\",\n          \"'\",\"\\\"\",\"`\",\n          \" \",\"\\n\",\n          \"!\",\"?\"\n        ]\n        local buf = \"\"\n        for i text.len (\n          if splitChars.contains(text[i]) (\n            if buf.len > 0 (\n              void self.tokens.append(buf)\n            )\n            void self.tokens.append(text[i])\n            buf = \"\"\n          ) else (\n            buf ++= text[i]\n          )\n        )\n        if buf.len > 0 (\n          self.tokens.append(buf)\n        )\n      )\n      \n      // statements\n      def blockContent(top) (\n        local statements @= []\n        local end = peek() == \"}\"\n        while !end (\n          local out @= top ? self.topLevelStatement() self.statement()\n          if out != null (\n            void statements.append(out)\n          )\n          void self.consumeWhitespace()\n          if self.peek() == \";\" (\n            void self.consume()\n          )\n          if self.peek() == \"}\" or self.atEnd() (\n            end = true\n          )\n        )\n        return statements\n      )\n      \n      def topLevelStatement() (\n        void self.consumeWhitespace()\n        \n        if self.peek() == \"event\" (\n          return self.event()\n        )\n        \n        throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n      )\n      \n      def event() (\n        local start @= self.getPos()\n        void self.expect(\"event\")\n        void self.consumeWhitespace()\n        void self.expect(\"(\")\n        void self.consumeWhitespace()\n        local name @= self.expectText()\n        void self.consumeWhitespace()\n        void self.expect(\")\")\n        void self.consumeWhitespace()\n        local body @= self.block()\n        \n        return {\n          kind: \"event\",\n          name,\n          body,\n          start, end: self.getPos()\n        }\n      )\n      \n      def statement(noSemicolon) (\n        void self.consumeWhitespace()\n        \n        // statements\n        if self.peek() == \"{\" (\n          local start @= self.getPos()\n          local body @= self.block()\n          return {\n            kind: \"block\",\n            body,\n            start, end: self.getPos()\n          }\n        )\n        \n        if self.peek() == \"if\" (\n          local start @= self.getPos()\n          void self.consume()\n          void self.consumeWhitespace()\n          void self.expect(\"(\")\n          local ifCond @= self.expression()\n          void self.expect(\")\")\n          void self.consumeWhitespace()\n          local ifBody @= self.statement()\n          \n          local elifs @= []\n          \n          void self.consumeWhitespace()\n          while self.peek() == \"elif\" (\n            void self.consume()\n            void self.consumeWhitespace()\n            void self.expect(\"(\")\n            local elifCond @= self.expression()\n            void self.expect(\")\")\n            void self.consumeWhitespace()\n            local elifBody @= self.statement()\n            \n            void elifs.append({\n              cond: elifCond,\n              body: elifBody\n            })\n            void self.consumeWhitespace()\n          )\n          \n          local elseBody = null\n          void self.consumeWhitespace()\n          if self.peek() == \"else\" (\n            void self.consume()\n            void self.consumeWhitespace()\n            local elseBody @= self.statement()\n          )\n          \n          return {\n            kind: \"branch\",\n            cond: ifCond,\n            body: ifBody,\n            elifs,\n            elseBody,\n            start, end: self.getPos()\n          }\n        )\n        \n        if [\"while\",\"until\"].contains(self.peek()) (\n          local start @= self.getPos()\n          local kind @= self.consume()\n          void self.consumeWhitespace()\n          void self.expect(\"(\")\n          local cond @= self.expression()\n          void self.expect(\")\")\n          void self.consumeWhitespace()\n          local body @= self.statement()\n          \n          return {\n            kind,\n            cond,\n            body,\n            start, end: self.getPos()\n          }\n        )\n        \n        if self.peek() == \"repeat\" (\n          local start @= self.getPos()\n          void self.consume()\n          void self.consumeWhitespace()\n          void self.expect(\"(\")\n          local amount @= self.expression()\n          void self.expect(\")\")\n          void self.consumeWhitespace()\n          local body @= self.statement()\n          \n          return {\n            kind: \"repeat\",\n            amount,\n            body,\n            start, end: self.getPos()\n          }\n        )\n        \n        if self.peek() == \"for\" (\n          local start @= self.getPos()\n          void self.consume()\n          void self.consumeWhitespace()\n          void self.expect(\"(\")\n          local var @= self.expectText()\n          void self.consumeWhitespace()\n          void self.expect(\",\")\n          void self.consumeWhitespace()\n          local arr @= self.expression()\n          void self.expect(\")\")\n          void self.consumeWhitespace()\n          local body @= self.statement()\n          return {\n            kind: \"for\",\n            var,\n            arr,\n            body,\n            start, end: self.getPos()\n          }\n        )\n        \n        local expr @= self.expression()\n        if expr != null (\n          void self.consumeWhitespace()\n          if !noSemicolon (\n            void self.expect(\";\")\n          )\n          \n          return {\n            kind: \"expression\",\n            expr\n          }\n        ) else (\n          throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n        )\n      )\n      \n      def block() (\n        local start @= self.getPos()\n        void self.expect(\"{\")\n        void self.consumeWhitespace()\n        local elements @= self.blockContent()\n        void self.consumeWhitespace()\n        void self.expect(\"}\")\n        return { elements, start, end: self.getPos() }\n      )\n      \n      // expressions\n      \n      def expression() (\n        return self.declare()\n      )\n      \n      def declare() (\n        if self.peek().match(\"/^[a-zA-Z_]\\\\w*$/\") != null (\n          local start @= self.getPos()\n          local ptr = self.pointer\n          local tar = self.consume()\n          void self.consumeWhitespace()\n          if self.peek() == \":\" and self.peek(2) == \"=\" (\n            void self.consume()\n            void self.consume()\n            void self.consumeWhitespace()\n            \n            local val @= self.expression()\n            \n            return {\n              kind: \"decl\",\n              tar,\n              val,\n              start, end: self.getPos()\n            }\n          )\n          self.pointer = ptr\n        )\n        \n        return self.assignment()\n      )\n      \n      def assignment() (\n        local start @= self.getPos()\n        local expr @= self.equality()\n        void self.consumeWhitespace()\n        \n        local op = null\n        \n        if self.peek() ++ self.peek(2) == \"??\" and self.peek(3) == \"=\" (\n          op = self.peek() ++ self.peek(2)\n        )\n        \n        if self.peek(2) == \"=\" and [\"+\",\"-\",\"*\",\"/\",\"%\",\"^\"].contains(self.peek()) (\n          op = self.peek()\n        )\n        \n        if op != null or self.peek() == \"=\" (\n          if op != null (\n            loop op.len (\n              void self.consume()\n            )\n          )\n          void self.consume()\n          void self.consumeWhitespace()\n          \n          local val @= self.expression()\n          \n          return {\n            kind: \"asi\",\n            op,\n            tar: expr,\n            val,\n            start, end: self.getPos()\n          }\n        )\n        \n        return expr\n      )\n      \n      def equality() (\n        local expr @= self.comparison()\n        void self.consumeWhitespace()\n        \n        while [\"==\",\"!=\"].contains(self.peek() ++ self.peek(2)) (\n          local op @= self.consume() ++ self.consume()\n          local right @= self.comparison()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n        )\n        \n        return expr\n      )\n      \n      def comparison() (\n        local expr @= self.term()\n        \n        local end = false\n        while !end (\n          void self.consumeWhitespace()\n          if [\">\",\"<\"].contains(self.peek()) (\n            local op @= self.consume()\n            local isEql = self.peek() == \"=\"\n            if isEql (\n              op ++= self.consume()\n            )\n            \n            local right @= self.factor()\n            \n            expr @= {\n              kind: \"binary\",\n              op,\n              left: expr,\n              right\n            }\n          ) else (\n            end = true\n          )\n        )\n        \n        return expr\n      )\n      \n      def term() (\n        local expr @= self.factor()\n        void self.consumeWhitespace()\n        \n        while [\"+\",\"-\"].contains(self.peek()) and self.peek(2) != \"=\" (\n          local op @= self.consume()\n          local right @= self.factor()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def factor() (\n        local expr @= self.otherBinary()\n        void self.consumeWhitespace()\n        \n        while [\"*\",\"/\"].contains(self.peek()) and self.peek(2) != \"=\" (\n          local op @= self.consume()\n          local right @= self.otherBinary()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def otherBinary() (\n        local expr @= self.coalescence()\n        void self.consumeWhitespace()\n        \n        while [\"%\",\"^\"].contains(self.peek()) and self.peek(2) != \"=\" (\n          local op @= self.consume()\n          local right @= self.coalescence()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def coalescence() (\n        local expr @= self.unary()\n        void self.consumeWhitespace()\n        \n        while self.peek() ++ self.peek(2) == \"??\" and self.peek(3) != \"=\" (\n          local op @= self.consume() ++ self.consume()\n          local right @= self.unary()\n          expr @= {\n            kind: \"binary\",\n            op,\n            left: expr,\n            right\n          }\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def unary() (\n        if self.peek(2) != \"=\" (\n          switch self.peek() (\n            case \"-\"; case \"+\"; case \"!\"; case \"?\"\n              return {\n                kind: \"unary\",\n                type: self.consume(),\n                expr: self.expression()\n              }\n          )\n        )\n        \n        return self.callExpr()\n      )\n      \n      def callExpr() (\n        local start @= self.getPos()\n        local expr @= self.func()\n        \n        if self.peek() == \"(\" (\n          self.consume()\n          \n          local args @= []\n          local end = self.peek() == \")\"\n          while !end (\n            local out @= self.expression()\n            if out != null (\n              void args.append(out)\n            )\n            void self.consumeWhitespace()\n            if self.peek() == \",\" (\n              void self.consume()\n            )\n            void self.consumeWhitespace()\n            if self.peek() == \")\" or self.atEnd() (\n              end = true\n            )\n          )\n          void self.expect(\")\")\n          \n          return {\n            kind: \"call\",\n            args,\n            func: expr,\n            start, end: self.getPos()\n          }\n        )\n        \n        return expr\n      )\n      \n      def func() (\n        local start @= self.getPos()\n        \n        local is = false\n        if self.peek() == \"(\" (\n          local end = false\n          local depth = 0\n          while !end (\n            local tkn @= self.consume()\n            if tkn == \"(\" (\n              depth ++\n            )\n            if tkn == \")\" (\n              depth --\n            )\n            \n            if tkn == \")\" and depth == 0 (\n              end = true\n              is = true\n            )\n            if self.atEnd() (\n              end = true\n            )\n          )\n        )\n        void self.consumeWhitespace()\n        if is and self.peek() == \"~\" (\n          self.pointer = start.i\n          \n          local args @= []\n          void self.consume()\n          void self.consumeWhitespace()\n          local end = self.peek() == \")\"\n          if self.peek() == \")\" (\n            void self.consume()\n          )\n          while !end (\n            local tkn @= self.expectText()\n            void args.append({\n              name: tkn\n            })\n            \n            void self.consumeWhitespace()\n            local ntkn = self.expects([\",\",\")\"])\n            void self.consumeWhitespace()\n            if ntkn == \")\" or self.atEnd() (\n              end = true\n            )\n          )\n          void self.consumeWhitespace()\n          void self.expect(\"~\")\n          void self.consumeWhitespace()\n          local body @= self.statement(true)\n          return {\n            kind: \"func\",\n            args,\n            body,\n            start, end: self.getPos()\n          }\n        )\n        self.pointer = start.i\n        \n        return self.objProperty()\n      )\n      \n      def objProperty() (\n        local expr @= self.primary()\n        void self.consumeWhitespace()\n        \n        while (self.peek() == \"[\" or self.peek() == \".\") and !self.atEnd() (\n          if self.peek() == \"[\" (\n            void self.consume()\n            local key @= self.expression()\n            void self.expect(\"]\")\n          ) else if self.peek() == \".\" (\n            void self.consume()\n            local key @= self.expectText()\n          ) else (\n            throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n          )\n          expr @= {\n            kind: \"prop\",\n            obj: expr,\n            key\n          }\n          void self.consumeWhitespace()\n        )\n        \n        return expr\n      )\n      \n      def primary() (\n        void self.consumeWhitespace()\n        \n        if self.peek() == \"(\" (\n          void self.consume()\n          local expr @= self.expression()\n          void self.expect(\")\")\n          return expr\n        )\n        \n        if self.peek() == \"[\" (\n          return self.arr()\n        )\n        \n        if self.peek() == \"{\" (\n          return self.obj()\n        )\n        \n        if [\"'\",\"\\\"\",\"`\"].contains(self.peek()) (\n          return self.str()\n        )\n        \n        if self.peek().match(\"/^[0-9]+$/\") != null (\n          return self.num()\n        )\n        \n        if self.peek().match(\"/^[a-zA-Z_]\\\\w*$/\") != null (\n          local start @= self.getPos()\n          return {\n            kind: \"var\",\n            name: self.consume(),\n            start, end: self.getPos()\n          }\n        )\n        \n        throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n      )\n      \n      def obj() (\n        void self.expect(\"{\")\n        void self.consumeWhitespace()\n        \n        local pairs @= []\n        \n        local end = self.peek() == \"}\"\n        while !end (\n          void self.consumeWhitespace()\n          local name @= self.expectText()\n          void self.consumeWhitespace()\n          void self.expect(\":\")\n          void self.consumeWhitespace()\n          local value @= self.expression()\n          \n          void pairs.append({ name, value })\n          \n          void self.consumeWhitespace()\n          if self.peek() == \"}\" (\n            end = true\n          ) else (\n            void self.expect(\",\")\n          )\n        )\n        void self.expect(\"}\")\n        \n        return {\n          kind: \"obj\",\n          pairs\n        }\n      )\n      \n      def arr() (\n        void self.expect(\"[\")\n        \n        local elems @= []\n        \n        local end = self.peek() == \"]\"\n        while !end (\n          local expr @= self.expression()\n          void elems.append(expr)\n          \n          void self.consumeWhitespace()\n          if self.peek() == \"]\" or self.atEnd() (\n            end = true\n          ) else (\n            void self.expect(\",\")\n          )\n          void self.consumeWhitespace()\n        )\n        \n        void self.expect(\"]\")\n        \n        return {\n          kind: \"arr\",\n          elems\n        }\n      )\n      \n      def str() (\n        local start @= self.getPos()\n        local q @= self.expects([\"'\",\"\\\"\",\"`\"])\n        local content = \"\"\n        local end = false\n        while (!end) (\n          local tkn @= self.peek()\n          if tkn == \"\\\\\" (\n            void self.consume()\n            local tkn = self.consume()\n            local char = tkn[1]\n            switch char (\n              case \"n\"\n                char = \"\\n\"\n                break\n            )\n            content ++= char ++ tkn.trim(2,-1)\n            continue\n          )\n          \n          if q == tkn (\n            end = true\n          ) else (\n            content ++= self.consume()\n          )\n          if self.atEnd() (\n            end = true\n          )\n        )\n        void self.expect(q)\n        return {\n          kind: \"str\",\n          val: content,\n          start, end: self.getPos()\n        }\n      )\n      \n      def num() (\n        if self.peek().match(\"/^[0-9]+$/\") == null (\n          throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n        )\n        \n        local start @= self.getPos()\n        local val @= self.consume()\n        \n        if self.peek() == \".\" (\n          val ++= self.consume()\n          if self.peek().match(\"/^[0-9]+$/\") == null (\n            throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n          )\n          val ++= self.consume()\n        )\n        \n        val @= val.toNum()\n        \n        return {\n          kind: \"num\",\n          val,\n          start, end: self.getPos()\n        }\n      )\n    )\n  )\n  return __imports__2691a00e099698fa56c4748f2551eb65\ncase \"./src/rtr/main.osl\"\n  class __imports__954b63a69b7120a02fa83923726ef587 (\n    class Module (\n      def init(object ast) (\n        void self.loadFromAst(ast)\n        void self.initScope()\n        void self.defScope()\n      )\n      def loadFromAst(object ast) (\n        self.ast @= ast\n        \n        self.events @= {}\n        self.eventList @= []\n        for i self.ast.elements.len (\n          local topLevel @= self.ast.elements[i]\n          if topLevel.kind == \"event\" (\n            if self.eventList.contains(topLevel.name) (\n              throw topLevel.name + \"event already exists on module\"\n            )\n            void self.eventList.append(topLevel.name)\n            self.events[topLevel.name] @= topLevel\n          )\n        )\n      )\n      \n      def initScope() (\n        self.scope @= []\n      )\n      def newScope(object vars) (\n        void self.scope.append(vars)\n      )\n      def popScope() (\n        return self.scope.pop()\n      )\n      def defScope() (\n        // helper funcs\n        local cFunc @= def(name, content) -> (\n          void self.setScopeVar(name, rtr.value.RTROslFuncValue(content))\n        )\n        \n        void self.newScope({})\n        \n        void self.setScopeVar(\"true\", rtr.value.RTRBoolValue(true))\n        void self.setScopeVar(\"false\", rtr.value.RTRBoolValue(false))\n        \n        cFunc(\"log\", def(args, inst) -> (\n          local txt = args.map(a -> a.stringify()).join(\" \")\n          log txt\n          void inst.inst.console.append([\"log\", txt])\n        ))\n        cFunc(\"error\", def(args, inst) -> (\n          local txt = args.map(a -> a.stringify()).join(\" \")\n          void inst.inst.console.append([\"err\", txt])\n          throw txt\n        ))\n        cFunc(\"return\", def(args, inst) -> (\n          local val @= args[1]\n          val ??= rtr.value.RTRNullValue()\n          void inst.setScopeVar(\"@return\", val)\n        ))\n        cFunc(\"typeof\", def(args) -> (\n          local val @= args[1] ?? rtr.value.RTRNullValue()\n          return val.getRtrType()\n        ))\n        cFunc(\"length\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].length())\n        ))\n        \n        // mathematical\n        cFunc(\"min\", def(args) -> (\n          local v = args[1].numbify()\n          for i args.len - 1 (\n            local a @= args[i + 1].numbify()\n            v = min(v, a)\n          )\n          return rtr.value.RTRNumValue(v)\n        ))\n        cFunc(\"max\", def(args) -> (\n          local v = args[1].numbify()\n          for i args.len - 1 (\n            local a @= args[i + 1].numbify()\n            v = max(v, a)\n          )\n          return rtr.value.RTRNumValue(v)\n        ))\n        \n        cFunc(\"abs\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().abs())\n        ))\n        cFunc(\"sqrt\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().sqrt())\n        ))\n        \n        cFunc(\"round\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().round())\n        ))\n        cFunc(\"floor\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().floor())\n        ))\n        cFunc(\"ceil\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].numbify().ceiling())\n        ))\n        \n        // string\n        cFunc(\"join\", def(args) -> (\n          local txt = \"\"\n          for i args.len (\n            txt ++= args[i].stringify()\n          )\n          return rtr.value.RTRStrValue(txt)\n        ))\n        cFunc(\"split\", def(args) -> (\n          return rtr.value.RTRArrValue(args[1]\n            .stringify()\n            .split(args[2].stringify())\n            .map(e -> rtr.value.RTRStrValue(e)))\n        ))\n        \n        cFunc(\"chr\", def(args) -> (\n          return rtr.value.RTRStrValue(args[1].numbify().chr())\n        ))\n        cFunc(\"ord\", def(args) -> (\n          return rtr.value.RTRNumValue(args[1].stringify().ord())\n        ))\n        \n        // array\n        cFunc(\"item\", def(args) -> (\n          return args[1].getItem(args[2])\n        ))\n        cFunc(\"range\", def(args) -> (\n          return rtr.value.RTRArrValue((args[1].numbify() to args[2].numbify()).map(e -> rtr.value.RTRNumValue(e)))\n        ))\n        \n        // object\n        cFunc(\"keys\", def(args) -> (\n          return rtr.value.RTRArrValue(args[1].keys().map(e -> rtr.value.RTRStrValue(e)))\n        ))\n        cFunc(\"values\", def(args) -> (\n          return rtr.value.RTRArrValue(args[1].values())\n        ))\n        cFunc(\"has\", def(args) -> (\n          return rtr.value.RTRBoolValue(args[1].has(args[2].stringify()))\n        ))\n        cFunc(\"obj\", def() -> (\n          return rtr.value.RTRObjValue({})\n        ))\n        \n        // logical\n        cFunc(\"all\", def(args) -> (\n          return rtr.value.RTRBoolValue(args.every(a -> a.boolify()))\n        ))\n        cFunc(\"any\", def(args) -> (\n          return rtr.value.RTRBoolValue(args.some(a -> a.boolify()))\n        ))\n        cFunc(\"not\", def(args) -> (\n          return rtr.value.RTRBoolValue(!args[1].boolify())\n        ))\n      )\n      def getScopeVarRaw(string key) (\n        for rawI self.scope.len (\n          local layer @= self.scope[self.scope.len - rawI + 1]\n          if layer[key] != null (\n            return layer[key]\n          )\n        )\n        return null\n      )\n      def getScopeVar(string key) (\n        return self.getScopeVarRaw(key)[1]\n      )\n      def getScopeVarMeta(string key) (\n        return self.getScopeVarRaw(key)[2]\n      )\n      def setScopeVar(string key, val, meta) (\n        meta ??= {}\n        for rawI self.scope.len (\n          local layer @= self.scope[self.scope.len - rawI + 1]\n          if layer[key] != null (\n            layer[key] @= [val, layer[key][2] ++ meta]\n            return\n          )\n        )\n        void self.declScopeVar(key, val, meta)\n      )\n      def declScopeVar(string key, val, meta) (\n        self.scope[self.scope.len][key] @= [val, meta]\n      )\n      \n      def runEvent(string name, object data) (\n        if !self.eventList.contains(name) (\n          return\n        )\n        \n        local ev @= self.events[name]\n        void self.runBlock(ev.body)\n      )\n      def runBlock(object block) (\n        local elements @= block.elements\n        local outVal @= rtr.value.RTRNullValue()\n        void self.newScope({})\n        for i elements.len (\n          local out @= self.runStatement(elements[i])\n          if self.getScopeVar(\"@return\") ?? 0 != 0 (\n            break\n          )\n        )\n        void self.popScope()\n        return outVal\n      )\n      def runStatement(object statement) (\n        switch statement.kind (\n          case \"expression\"\n            return self.runExpression(statement.expr)\n          case \"block\"\n            return self.runBlock(statement.body)\n          \n          case \"branch\"\n            if self.runExpression(statement.cond).boolify() (\n              return self.runStatement(statement.body)\n            )\n            for i statement.elifs.len (\n              local elif @= statement.elifs[i]\n              if self.runExpression(elif.cond).boolify() (\n                return self.runStatement(elif.body)\n              )\n            )\n            if statement.elseBody != null (\n              return self.runStatement(statement.elseBody)\n            )\n            return rtr.value.RTRNullValue()\n          \n          case \"while\"\n            local iters = 0\n            while self.runExpression(statement.cond).boolify() and self.getScopeVar(\"@return\") ?? 0 == 0 and iters < 999999 (\n              void self.runStatement(statement.body)\n              iters ++\n            )\n            return rtr.value.RTRNullValue()\n          case \"until\"\n            local iters = 0\n            while !self.runExpression(statement.cond).boolify() and self.getScopeVar(\"@return\") ?? 0 == 0 and iters < 999999 (\n              void self.runStatement(statement.body)\n              iters ++\n            )\n            return rtr.value.RTRNullValue()\n          case \"repeat\"\n            loop self.runExpression(statement.amount).numbify() (\n              void self.runStatement(statement.body)\n            )\n            return rtr.value.RTRNullValue()\n          case \"for\"\n            local arr @= self.runExpression(statement.arr).arrify()\n            for i arr.len (\n              void self.newScope({})\n              void self.declScopeVar(statement.var, arr[i])\n              void self.runStatement(statement.body)\n              void self.popScope()\n            )\n            return rtr.value.RTRNullValue()\n          \n          default\n            throw \"unknown statement type\" + statement.kind\n        )\n      )\n      def runExpression(object expression) (\n        switch expression.kind (\n          case \"call\"\n            local func @= self.runExpression(expression.func)\n            local args @= []\n            for i expression.args.len (\n              void args.append(self.runExpression(expression.args[i]))\n            )\n            return func.callFunc(self, args) ?? rtr.value.RTRNullValue()\n          case \"decl\"\n            local val @= self.runExpression(expression.val)\n            \n            void self.declScopeVar(expression.tar, val, {\n              type: val.getRtrType()\n            })\n            \n            return val\n          case \"asi\"\n            local val @= self.runExpression(expression.val)\n            \n            local existingMeta = null\n            local existing = null\n            switch expression.tar.kind (\n              case \"var\"\n                existingMeta @= self.getScopeVarMeta(expression.tar.name)\n                existing @= self.getScopeVar(expression.tar.name)\n                break\n              case \"prop\"\n                existing @= self.runExpression(expression.tar)\n                break\n            )\n            \n            if expression.op != null (\n              val @= self.runOperation(existing, expression.op, val)\n            )\n            \n            switch expression.tar.kind (\n              case \"var\"\n                if existingMeta != null (\n                  local curType @= val.getRtrType()\n                  if existingMeta.type != null (\n                    if !existingMeta.type.isEqual(curType) (\n                      throw \"cannot assign\" + curType.stringify() + \"to\" + existingMeta.type.stringify() + \"variable\" \n                    )\n                  )\n                )\n                void self.setScopeVar(expression.tar.name, val)\n                break\n              case \"prop\"\n                local obj @= self.runExpression(expression.tar.obj)\n                local key @= expression.tar.key\n                if typeof(key) == \"string\" (\n                  key @= rtr.value.RTRStrValue(key)\n                ) else (\n                  key @= self.runExpression(key)\n                )\n                obj.setItem(key, val)\n                break\n              default\n                throw \"cannot assign to\" + expression.tar.kind\n            )\n            \n            return val\n          case \"unary\"\n            local val @= self.runExpression(expression.expr)\n            switch expression.type (\n              case \"-\"\n                return rtr.value.RTRNumValue(-val.numbify())\n              case \"+\"\n                return rtr.value.RTRNumValue(val.numbify())\n              case \"!\"\n                return rtr.value.RTRBoolValue(!val.boolify())\n              case \"?\"\n                return rtr.value.RTRBoolValue(val.boolify())\n            )\n            return rtr.value.RTRNullValue()\n          case \"binary\"\n            local left @= self.runExpression(expression.left)\n            local right @= self.runExpression(expression.right)\n            return self.runOperation(left, expression.op, right)\n          case \"var\"\n            local val @= self.getScopeVar(expression.name)\n            return val ?? rtr.value.RTRNullValue()\n          case \"prop\"\n            local obj @= self.runExpression(expression.obj)\n            local key @= expression.key\n            if typeof(key) == \"string\" (\n              key @= rtr.value.RTRStrValue(key)\n            ) else (\n              key @= self.runExpression(key)\n            )\n            return obj.getItem(key) ?? rtr.value.RTRNullValue()\n          \n          case \"str\"\n            return rtr.value.RTRStrValue(expression.val)\n          case \"num\"\n            return rtr.value.RTRNumValue(expression.val)\n          case \"func\"\n            return rtr.value.RTRAstFuncValue(expression.args, expression.body)\n          case \"arr\"\n            return rtr.value.RTRArrValue(expression.elems.map(e -> self.runExpression(e)))\n          case \"obj\"\n            local val @= {}\n            for i expression.pairs.len (\n              local pair @= expression.pairs[i]\n              val[pair.name] @= self.runExpression(pair.value)\n            )\n            return rtr.value.RTRObjValue(val)\n          \n          default\n            throw \"unknown expression type\" + expression.kind\n        )\n      )\n      def runOperation(object left, op, object right) (\n        local numT @= rtr.value.RTRNumValue.getRtrType()\n        switch op (\n          case \"+\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() + right.numbify())\n            )\n            return rtr.value.RTRStrValue(left.stringify() ++ right.stringify())\n          case \"-\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() - right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          case \"*\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() * right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          case \"/\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() / right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          case \"%\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() % right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          case \"^\"\n            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n              return rtr.value.RTRNumValue(left.numbify() ^ right.numbify())\n            )\n            return rtr.value.RTRNumValue(NaN)\n          \n          case \"==\"\n            return rtr.value.RTRBoolValue(left.isEqual(right))\n          case \"!=\"\n            return rtr.value.RTRBoolValue(left.isEqual(right))\n          \n          case \">\"\n            return rtr.value.RTRBoolValue(left.numbify() > right.numbify())\n          case \"<\"\n            return rtr.value.RTRBoolValue(left.numbify() < right.numbify())\n          case \">=\"\n            return rtr.value.RTRBoolValue(left.numbify() >= right.numbify())\n          case \"<=\"\n            return rtr.value.RTRBoolValue(left.numbify() <= right.numbify())\n        \n          case \"??\"\n            return left.getRtrType().data.name == \"null\" ? right left\n        )\n        \n        return rtr.value.RTRNullValue()\n      )\n    )\n    \n    class RTR (\n      def init() (\n        self.modules @= {}\n        self.console @= []\n      )\n    \n      def addModule(object mod) (\n        local key @= OuidNew()\n        mod.inst @= self\n        self.modules[key] @= mod\n        return key\n      )\n      \n      def startModules() (\n        local mods @= self.modules.getValues()\n        for i mods.len (\n          void mods[i].runEvent(\"onload\", {})\n        )\n      )\n    )\n  )\n  return __imports__954b63a69b7120a02fa83923726ef587\ncase \"./src/rwl/ast.osl\"\n  class __imports__823191bbaeb9397e6eaf51c446a37c4c (\n    class Parser (\n      def init(string text) (\n        void self.tokenise(text)\n      )\n      \n      def parse() (\n        self.pointer = 1\n        \n        local out @= {\n          elements: self.blockContent()\n        }\n        \n        if !self.atEnd() (\n          throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n        )\n        \n        return out\n      )\n      \n      def peek() (\n        return self.tokens[self.pointer]\n      )\n      def consume() (\n        local tkn = self.peek()\n        self.pointer ++\n        return tkn\n      )\n      def consumeWhitespace() (\n        while self.peek().match(\"/^\\\\s$/\") != null (\n          void self.consume()\n        )\n      )\n      def consumeSpaces() (\n        local txt = \"\"\n        while self.peek() == \" \" (\n          txt ++= self.consume()\n        )\n        return txt\n      )\n      def atEnd() (\n        return self.pointer >= self.tokens.len\n      )\n      def expect(string token) (\n        local tkn @= self.consume()\n        if tkn != token (\n          throw \"expected '\" ++ token ++ \"' got '\" ++ tkn ++ \"'\"\n        )\n        return tkn\n      )\n      def expects(array tokens) (\n        local tkn @= self.consume()\n        if !tokens.contains(tkn) (\n          throw \"expected '\" ++ tokens.join(\" or \") ++ \"' got '\" ++ tkn ++ \"'\"\n        )\n        return tkn\n      )\n      \n      def tokenise(string text) (\n        self.tokens @= []\n        local splitChars @= [\n          // rwl\n          \"{\",\"}\",\n          \"[\",\"]\",\n          \",\",\n          \" \",\n          \"\\n\",\n          \"/\",\"\\\\\",\"*\",\n          \"'\",\"\\\"\",\"`\",\n          \":\",\"#\",\"%\",\"=\",\n          // rtr\n          \"(\",\")\",\n          \"[\",\"]\",\n          \"{\",\"}\",\n          \",\",\";\",\":\",\"=\",\".\",\n          \"+\",\"-\",\"*\",\"/\",\"%\",\"^\",\n          \"\\\\\",\n          \"'\",\"\\\"\",\"`\",\n          \" \",\"\\n\",\n          \"!\",\"?\"\n        ]\n        local buf = \"\"\n        for i text.len (\n          if splitChars.contains(text[i]) (\n            if buf.len > 0 (\n              void self.tokens.append(buf)\n            )\n            void self.tokens.append(text[i])\n            buf = \"\"\n          ) else (\n            buf ++= text[i]\n          )\n        )\n        if buf.len > 0 (\n          self.tokens.append(buf)\n        )\n      )\n      \n      // statements\n      def blockContent() (\n        local statements @= []\n        local end = false\n        while !end (\n          local out @= self.statement()\n          if out != null (\n            void statements.append(out)\n          )\n          void self.consumeWhitespace()\n          if self.peek() == \"}\" or self.atEnd() (\n            end = true\n          ) else (\n            void self.expect(\",\")\n          )\n        )\n        return statements\n      )\n      \n      def statement() (\n        void self.consumeWhitespace()\n        \n        local tkn @= self.peek()\n        \n        // block\n        if tkn.match(\"/^[a-zA-Z]+$/\") != null (\n          return self.blockStatement()\n        )\n        \n        // element\n        local value @= self.value()\n        if value != null (\n          void self.consumeWhitespace()\n          local header @= self.header()\n          \n          return {\n            data: {\n              value,\n              header\n            },\n            kind: \"element\"\n          }\n        )\n      )\n      \n      def blockStatement() (\n        local key @= self.consume()\n        \n        void self.consumeWhitespace()\n        \n        local header @= self.header()\n        header.key = key\n        \n        void self.consumeWhitespace()\n        \n        if key == \"script\" (\n          local content = \"\"\n          local spaceContent = \"\"\n          void self.expect(\"{\")\n          local end = false\n          local depth = 1\n          local stringType = null\n          while !end (\n            local tkn @= self.peek()\n            \n            if tkn == \"'\" (\n              if stringType == \"'\" (\n                stringType = null\n              ) else if stringType == null (\n                stringType = \"'\"\n              )\n            )\n            \n            if tkn == \"\\\"\" (\n              if stringType == \"\\\"\" (\n                stringType = null\n              ) else if stringType == null (\n                stringType = \"\\\"\"\n              )\n            )\n            \n            if tkn == \"`\" (\n              if stringType == \"`\" (\n                stringType = null\n              ) else if stringType == null (\n                stringType = \"`\"\n              )\n            )\n            \n            if stringType == null (\n              if tkn == \"{\" (\n                depth ++\n              )\n              if tkn == \"}\" (\n                depth --\n              )\n            )\n            \n            if self.atEnd() or (tkn == \"}\" and depth == 0 and stringType == null) (\n              end = true\n            ) else (\n              if tkn == \"\\n\" (\n                spaceContent = \"\"\n                void self.consume()\n                if content != \"\" (\n                  content ++= \"\\n\"\n                )\n              ) else if tkn == \" \" (\n                spaceContent ++= self.consume()\n              ) else (\n                content ++= spaceContent\n                content ++= self.consume()\n                spaceContent = \"\"\n              )\n            )\n          )\n          void self.expect(\"}\")\n        ) else (\n          local content @= self.block()\n        )\n        \n        return {\n          kind: \"block\",\n          data: {\n            header,\n            content\n          }\n        }\n      )\n      \n      def block() (\n        void self.expect(\"{\")\n        void self.consumeWhitespace()\n        local elements @= self.blockContent()\n        void self.consumeWhitespace()\n        void self.expect(\"}\")\n        return { elements }\n      )\n      \n      // header stuff\n      def header() (\n        local attributes @= []\n        if self.peek() == \"[\" (\n          void self.expect(\"[\")\n          local end = self.peek() == \"]\"\n          while !end (\n            local out @= self.headerItem()\n            if out != null (\n              void attributes.append(out)\n            )\n            void self.consumeWhitespace()\n            if self.peek() == \",\" (\n              void self.consume()\n            )\n            if self.peek() == \"]\" or self.atEnd() (\n              end = true\n            )\n          )\n          void self.expect(\"]\")\n        )\n        \n        return { attributes }\n      )\n      def headerItem() (\n        void self.consumeWhitespace()\n        local tkn @= self.consume()\n        void self.consumeWhitespace()\n        if self.peek() == \"=\" (\n          if tkn.match(\"/^[a-zA-Z_]+$/\") == null (\n            throw \"attribute key must consist of letters or _\"\n          )\n          void self.consume()\n          local value @= self.value()\n          return {\n            kind: \"key\",\n            key: tkn,\n            value\n          }\n        )\n        if tkn.match(\"/^[a-zA-Z_]+$/\") != null (\n          return {\n            kind: \"flag\",\n            data: tkn\n          }\n        )\n      )\n      \n      // values\n      def value() (\n        if [\"'\",\"\\\"\",\"`\"].contains(self.peek()) (\n          return self.str()\n        )\n        \n        if self.peek().match(\"/^[0-9]+$/\") != null (\n          return self.num()\n        )\n        \n        if self.peek() == \"#\" (\n          return self.color()\n        )\n        \n        if self.peek().match(\"/^\\\\w+$/\") != null (\n          return self.property()\n        )\n      )\n      \n      def str() (\n        local q @= self.expects([\"'\",\"\\\"\",\"`\"])\n        local content = \"\"\n        local end = false\n        while (!end) (\n          local tkn @= self.peek()\n          if tkn == \"\\\\\" (\n            void self.consume()\n            local tkn = self.consume()\n            local char = tkn[1]\n            switch char (\n              case \"n\"\n                char = \"\\n\"\n                break\n            )\n            content ++= char ++ tkn.trim(2,-1)\n            continue\n          )\n          \n          if q == tkn (\n            end = true\n          ) else (\n            content ++= self.consume()\n          )\n          if self.atEnd() (\n            end = true\n          )\n        )\n        void self.expect(q)\n        return {\n          type: \"str\",\n          value: content\n        }\n      )\n      \n      // and percentage\n      def num() (\n        if self.peek().match(\"/^[0-9]+$/\") == null (\n          throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n        )\n        \n        local value @= self.consume().toNum()\n        \n        local type = \"num\"\n        \n        if self.peek() == \"%\" (\n          void self.consume()\n          type = \"percentage\"\n        )\n        \n        return {\n          type,\n          value\n        }\n      )\n      \n      def color() (\n        void self.expect(\"#\")\n        local value = self.consume()\n        if ![3,6].contains(value.len) (\n          throw \"hex values can only be 3 or 6 characters long\"\n        )\n        return {\n          type: \"color\",\n          value: \"#\" ++ value\n        }\n      )\n      \n      def property() (\n        local source = self.consume()\n        if source.match(\"/^[a-zA-Z_]+$/\") == null (\n          throw \"source must consist of letters or _\"\n        )\n        \n        void self.consumeWhitespace()\n        void self.expect(\":\")\n        void self.consumeWhitespace()\n        \n        local name = self.consume()\n        if name.match(\"/^[a-zA-Z_]+$/\") == null (\n          throw \"name must consist of letters or _\"\n        )\n        \n        return {\n          type: \"property\",\n          source,\n          name\n        }\n      )\n    )\n  )\n  return __imports__823191bbaeb9397e6eaf51c446a37c4c\ncase \"./src/rwl/debug.osl\"\n  class __imports__a02a29842cf0d752bb9291888afe9568 (\n    def box(array area, color) (\n      if !rwl.main.debug (\n        return\n      )\n      void shared.graphics.box(area, color ?? #f00)\n    )\n  )\n  return __imports__a02a29842cf0d752bb9291888afe9568\ncase \"./src/rwl/value.osl\"\n  class __imports__b6b9b465fcf5c8c4f9d5fe786e8bce9c (\n    class RWLValue (\n      \n    )\n    \n    class RWLStrValue extends RWLValue (\n      type = \"str\"\n      def init(string value) (\n        self.value @= value\n      )\n    )\n    \n    class RWLNumValue extends RWLValue (\n      type = \"num\"\n      def init(number value) (\n        self.value @= value\n      )\n    )\n    \n    class RWLPercentageValue extends RWLValue (\n      type = \"percentage\"\n      def init(number value) (\n        self.value @= value\n      )\n    )\n    \n    class RWLColorValue extends RWLValue (\n      type = \"color\"\n      def init(string value) (\n        self.value @= value\n      )\n    )\n    \n    def AstToValue(ast) (\n      switch ast.type (\n        case \"str\"\n          return rwl.value.RWLStrValue(ast.value)\n        case \"num\"\n          return rwl.value.RWLNumValue(ast.value)\n        case \"percentage\"\n          return rwl.value.RWLPercentageValue(ast.value)\n        case \"color\"\n          return rwl.value.RWLColorValue(ast.value)\n        case \"property\"\n          switch ast.source (\n            case \"theme\"\n              local col = shared.theme[ast.name]\n              if typeof(col) == \"string\" (\n                return rwl.value.RWLColorValue(col)\n              )\n              break\n            default\n              return rwl.error.Error(\"UnknownPropertySource\", {\n                source: ast.source\n              })\n          )\n          return rwl.error.Error(\"UnknownProperty\", {\n            property: ast.name,\n            source: ast.source\n          })\n        default\n          return rwl.error.Error(\"UnknownValueType\", {\n            valueType: ast.type\n          })\n      )\n    )\n  )\n  return __imports__b6b9b465fcf5c8c4f9d5fe786e8bce9c\ncase \"./src/rwl/error.osl\"\n  class __imports__c17b91d805bd65a760423a0b948a2c09 (\n    object Errors = {\n      UnknownElementKind: def(data) -> (\n        return \"unknown element kind:\" + data.elementKind\n      ),\n      UnknownAttributeKind: def(data) -> (\n        return \"unknown attribute kind:\" + data.attributeKind\n      ),\n      \n      UnknownValueType: def(data) -> (\n        return \"unknown value type:\" + data.valueType\n      ),\n      UnknownBlockType: def(data) -> (\n        return \"unknown block type:\" + data.blockType\n      ),\n      \n      InvalidAnchorName: def(data) -> (\n        return \"unknown anchor name\" + data.name\n      ),\n      InvalidAlignmentName: def(data) -> (\n        return \"unknown anchor name\" + data.name\n      ),\n      \n      InvalidElemType: def(data) -> (\n        return \"cannot have\" + data.valueType + \"as element\"\n      ),\n      \n      ValueTypeMismatch: def(data) -> (\n        if typeof(data.wanted) == \"string\" (\n          data.wanted @= [data.wanted]\n        )\n        local forCtx = \"\"\n        if data.attr != null (\n          forCtx += \"for\" + data.attr\n        )\n        return \"wanted\" + data.wanted.join(\" or \") + \"got\" + data.got ++ forCtx\n      ),\n      \n      UnknownProperty: def(data) -> (\n        return \"unknown property\" + data.property + \"on\" + data.source\n      ),\n      UnknownPropertySource: def(data) -> (\n        return \"unknown source\" + data.source\n      ),\n      \n      ElemInFrame: def(data) -> (\n        return \"element in a frame, only sections are allowed directly in frames\"\n      ),\n      \n      NoScriptType: def(data) -> (\n        return \"no script type attribute\"\n      ),\n      InvalidScriptType: def(data) -> (\n        return \"unknown script type\" + data.type\n      ),\n      InvalidScriptAttrType: def(data) -> (\n        return \"unknown script type attribute type\" + data.type\n      )\n    }\n    \n    class Error (\n      boolean isError = true\n      \n      def init(string type, object data) (\n        self.type = type\n        self.data @= data\n        \n        local err @= rwl.error.Errors[type]\n        if err == null (\n          self.txt = \"unknown error type\" + type\n          return\n        )\n        self.txt = err(data)\n      )\n      \n      def stringify() (\n        return \"Error<\" ++ self.type ++ \">:\\n\" ++ self.txt.split(\"\\n\").map(l -> \"    \" ++ l).join(\"\\n\")\n      )\n    )\n  )\n  return __imports__c17b91d805bd65a760423a0b948a2c09\ncase \"./src/rwl/area.osl\"\n  class __imports__51b19cf190821eee598f3dc8fa9be944 (\n    def copy(area) (\n      return [area[1], area[2], area[3], area[4]]\n    )\n    \n    def centerX(area) (\n      return area[1] + area[3] / 2\n    )\n    \n    def centerY(area) (\n      return area[2] + area[4] / 2\n    )\n    \n    def width(area) (\n      return area[3] - area[1]\n    )\n    \n    def height(area) (\n      return area[4] - area[2]\n    )\n  )\n  return __imports__51b19cf190821eee598f3dc8fa9be944\ncase \"./src/rwl/config.osl\"\n  class __imports__997006161a7103fcb97a4e4d8f4a25b1 (\n    goob = \"hi\"\n  )\n  return __imports__997006161a7103fcb97a4e4d8f4a25b1\ncase \"./src/rwl/main.osl\"\n  class __imports__b471b13f60903428337025313115b852 (\n    debug = false\n    \n    class RWLNode (\n      def update() (\n        \n      )\n      \n      def render() (\n        \n      )\n      \n      def expectOnHeader(string key, string type) (\n        for attrI self.header.pairs.len (\n          local attr @= self.header.pairs[attrI]\n          if attr[2].isError (\n            return attr[2]\n          )\n          if attr[1] == key (\n            if attr[2].type != type (\n              return rwl.error.Error(\"ValueTypeMismatch\", {\n                wanted: type,\n                got: attr[2].type\n              })\n            ) else (\n              return attr[2]\n            )\n          )\n        )\n        return null\n      )\n    )\n    \n    class RWLContainer extends RWLNode (\n      kind = \"block\"\n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n      )\n      \n      def update(array area, object context) (\n        void self.updateBackground(area)\n        \n        local childArea @= rwl.area.copy(area)\n        \n        local childPaddingL = 0\n        local childPaddingR = 0\n        local childPaddingB = 0\n        local childPaddingT = 0\n        \n        for i self.header.pairs.len (\n          local pair @= self.header.pairs[i]\n          local value @= pair[2]\n          \n          switch pair[1] (\n            case \"padding\"\n              childPaddingL = value.value\n              childPaddingR = value.value\n              childPaddingB = value.value\n              childPaddingT = value.value\n              break\n            case \"padding_x\"\n              childPaddingL = value.value\n              childPaddingR = value.value\n              break\n            case \"padding_y\"\n              childPaddingB = value.value\n              childPaddingT = value.value\n              break\n            case \"padding_l\"\n              childPaddingL = value.value\n              break\n            case \"padding_r\"\n              childPaddingR = value.value\n              break\n            case \"padding_b\"\n              childPaddingB = value.value\n              break\n            case \"padding_t\"\n              childPaddingT = value.value\n              break\n          )\n        )\n        \n        childArea[1] += childPaddingL\n        childArea[2] += childPaddingB\n        childArea[3] -= childPaddingR\n        childArea[4] -= childPaddingT\n        \n        self.area @= area\n        self.childArea @= childArea\n        \n        return rwl.main.UpdateElements(self.children, childArea, {\n          x: rwl.area.centerX(childArea),\n          y: rwl.area.centerY(childArea),\n          anchorX: \"c\",\n          anchorY: \"c\",\n          color: \"#fff\",\n          inst: context.inst\n        })\n      )\n      \n      def updateBackground(area) (\n        self.area @= area\n        local color @= self.expectOnHeader(\"color\", \"color\")\n        \n        if color != null (\n          self.color @= color.value\n        )\n        \n        local allRounding @= self.expectOnHeader(\"rounding\", \"num\")\n        \n        local rounding @= allRounding.value ?? 0\n        \n        local corners @= [\"tl\",\"tr\",\"bl\",\"br\"]\n        for i corners.len (\n          local corner @= self.expectOnHeader(\"rounding_\" ++ corners[i], \"num\")\n          if corner != null (\n            if typeof(rounding) != \"array\" (\n              rounding @= []\n              loop i - 1 (\n                void rounding.append(allRounding.value ?? 0)\n              )\n            )\n            void rounding.append(corner.value ?? 0)\n          ) else (\n            void rounding.append(allRounding.value ?? 0)\n          )\n        )\n        self.rounding @= rounding\n      )\n      \n      def render() (\n        void self.renderBackground()\n        if rwl.main.debug (\n          void rwl.debug.box(self.area)\n          void rwl.debug.box(self.childArea, #0f0)\n        )\n        void rwl.main.RenderElements(self.children)\n      )\n      \n      def renderBackground() (\n        if self.color != null (\n          void shared.graphics.filledBox(self.area, self.rounding, self.color)\n        )\n      )\n    )\n    \n    class RWLRoot extends RWLContainer (\n      blockName = \"root\"\n      \n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n      )\n    )\n    \n    class RWLFrame extends RWLContainer (\n      blockName = \"frame\"\n      \n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n      )\n      \n      def update(array area, object context) (\n        void self.updateBackground()\n        local dir = \"x\"\n        local flipped = false\n        for flagI self.header.flags.len (\n          switch self.header.flags[flagI] (\n            case \"Horizontal\"\n              dir = \"x\"\n              break\n            case \"Vertical\"\n              dir = \"y\"\n              break\n            case \"Flipped\"\n              flipped = !flipped\n              break\n          )\n        )\n        \n        local amount = 0\n        if dir == \"x\" (\n          local total = rwl.area.width(area)\n        ) else if dir == \"y\" (\n          local total = rwl.area.height(area)\n        )\n        \n        local frameContext @= {\n          inst: context.inst\n        }\n        \n        for i self.children.len (\n          local child @= self.children[i]\n          if child.kind == \"block\" (\n            \n            local childMarginL = 0\n            local childMarginR = 0\n            local childMarginB = 0\n            local childMarginT = 0\n            \n            // defaults to remaining\n            local size = total - amount\n            local pairs @= child.header.pairs\n            for pairI pairs.len (\n              local pair @= pairs[pairI]\n              local value @= pair[2]\n              if pair[1] == \"size\" or (pair[1] == \"width\" and dir == \"x\") or (pair[1] == \"height\" and dir == \"y\") (\n                switch value.type (\n                  case \"num\"\n                    size = value.value\n                    break\n                  case \"percentage\"\n                    size = value.value / 100 * (total - amount)\n                    break\n                  default\n                    return rwl.error.Error(\"ValueTypeMismatch\", {\n                      wanted: [\"num\", \"percentage\"],\n                      got: value.type\n                    })\n                )\n                break\n              )\n              \n              switch pair[1] (\n                case \"margin\"\n                  childMarginL = value.value\n                  childMarginR = value.value\n                  childMarginB = value.value\n                  childMarginT = value.value\n                  break\n                case \"margin_x\"\n                  childMarginL = value.value\n                  childMarginR = value.value\n                  break\n                case \"margin_y\"\n                  childMarginB = value.value\n                  childMarginT = value.value\n                  break\n                case \"margin_l\"\n                  childMarginL = value.value\n                  break\n                case \"margin_r\"\n                  childMarginR = value.value\n                  break\n                case \"margin_b\"\n                  childMarginB = value.value\n                  break\n                case \"margin_t\"\n                  childMarginT = value.value\n                  break\n              )\n            )\n            \n            if dir == \"x\" (\n              local childArea @= [\n                (flipped ? (area[3] - amount - size) (area[1] + amount)) + childMarginL,\n                area[2] + childMarginB,\n                (flipped ? (area[3] - amount) (area[1] + amount + size)) - childMarginR,\n                area[4] - childMarginT\n              ]\n            ) else if dir == \"y\" (\n              local childArea @= [\n                area[1] + childMarginL,\n                (flipped ? (area[2] + amount) (area[4] - amount - size)) + childMarginB,\n                area[3] - childMarginR,\n                (flipped ? (area[2] + amount + size) (area[4] - amount)) - childMarginT\n              ]\n            )\n            \n            local out @= child.update(childArea, frameContext)\n            if out.isError (\n              return out\n            )\n            \n            amount += size\n          )\n        )\n      )\n      \n      def render() (\n        void self.renderBackground()\n        void rwl.main.RenderElements(self.children)\n      )\n    )\n    \n    class RWLSection extends RWLContainer (\n      blockName = \"section\"\n      \n      def init(array children, object header) (\n        self.children @= children\n        self.header @= header\n      )\n    )\n    \n    class RWLScript extends RWLNode (\n      blockName = \"script\"\n      kind = \"script\"\n      \n      def init(body, object header, object inst) (\n        self.body @= body\n        self.header @= header\n        \n        void self.parse()\n        void self.makeModule(inst)\n      )\n      \n      def parse() (\n        self.ast @= null\n        // TODO: try\n        local parser @= rtr.ast.Parser(body)\n        self.ast @= parser.parse()\n      )\n      \n      def makeModule(object inst) (\n        if self.ast != null (\n          self.mod @= rtr.main.Module(self.ast)\n          void inst.rtrInst.addModule(self.mod)\n        )\n      )\n      \n      def update(array area, object context) (\n        if self.mod != null (\n          void self.mod.runEvent(\"onupdate\", {})\n        )\n      )\n    )\n    \n    class RWLElement extends RWLNode (\n      kind = \"element\"\n      def init(object value, object header) (\n        self.value @= value\n        self.header @= header\n      )\n      \n      def update(array area, object context) (\n        local text = null\n        \n        switch self.value.type (\n          case \"str\"; case \"num\"\n            text = self.value.value.toStr()\n            break\n        )\n        \n        if text == null (\n          return rwl.error.Error(\"InvalidElemType\", {\n            valueType: self.value.type\n          })\n        )\n        \n        // font\n        //<font>\n        local size @= self.expectOnHeader(\"size\", \"num\")\n        if size.isError (\n          return size\n        )\n        size = size[\"value\"] ?? 10\n        \n        local spacing @= self.expectOnHeader(\"spacing\", \"num\")\n        if spacing.isError (\n          return spacing\n        )\n        spacing = spacing[\"value\"] ?? 1\n        \n        local line_height @= self.expectOnHeader(\"line_height\", \"num\")\n        if line_height.isError (\n          return line_height\n        )\n        line_height = spacing[\"line_height\"] ?? 1\n        \n        // positioning\n        local padding @= self.expectOnHeader(\"padding\", \"num\")\n        if padding.isError (\n          return padding\n        )\n        padding = padding[\"value\"] ?? 0\n        \n        local anchor @= self.expectOnHeader(\"anchor\", \"str\")\n        if anchor.isError (\n          return anchor\n        )\n        anchor = anchor[\"value\"]\n        \n        if anchor != null (\n          if [\"tl\",\"t\",\"tr\",\n              \"l\",\"c\",\"r\",\n              \"bl\",\"b\",\"br\",\n              \"top left\", \"top\", \"top right\",\n              \"left\", \"center\", \"right\",\n              \"bottom left\", \"bottom\", \"bottom right\"].contains(anchor).not() (\n            return rwl.error.Error(\"InvalidAnchorName\", {\n              name: anchor\n            })\n          )\n          \n          local anchorX = rwl.area.centerX(area)\n          local anchorY = rwl.area.centerY(area) + (line_height * 1 * size)\n          local anchorXType = \"c\"\n          local anchorYType = \"c\"\n          \n          if anchor.endsWith(\"l\") or anchor.endsWith(\"left\") (\n            anchorX = area[1] + padding\n            anchorXType = \"l\"\n          )\n          if anchor.endsWith(\"r\") or anchor.endsWith(\"right\") (\n            anchorX = area[3] - padding\n            anchorXType = \"r\"\n          )\n          \n          if anchor.startsWith(\"t\") or anchor.endsWith(\"top\") (\n            anchorY = area[4] - padding\n            anchorYType = \"t\"\n          )\n          if anchor.startsWith(\"b\") or anchor.endsWith(\"bottom\") (\n            anchorY = area[2] + padding\n            anchorYType = \"b\"\n          )\n          \n          context.x = anchorX\n          context.y = anchorY\n          context.anchorX = anchorXType\n          context.anchorY = anchorYType\n        )\n        \n        local boxAlignment = context.anchorX\n        \n        local alignment @= self.expectOnHeader(\"alignment\", \"str\")\n        if alignment.isError (\n          return alignment\n        )\n        alignment = alignment[\"value\"]\n        if alignment != null (\n          if [\"l\",\"c\",\"r\",\n              \"left\", \"center\", \"right\"].contains(alignment).not() (\n            return rwl.error.Error(\"InvalidAlignmentName\", {\n              name: anchor\n            })\n          )\n          \n          if alignment.endsWith(\"l\") or alignment.endsWith(\"left\") (\n            alignment = \"l\"\n          )\n          if alignment.endsWith(\"r\") or alignment.endsWith(\"right\") (\n            alignment = \"r\"\n          )\n        )\n        alignment ??= boxAlignment\n        \n        // appearance\n        //<link>\n        //<decoration>\n        local color @= self.expectOnHeader(\"color\", \"color\")\n        if color.isError (\n          return color\n        )\n        color = color[\"value\"]\n        if color != null (\n          context.color = color\n        )\n        color ??= context.color\n        \n        local lines @= text.split(\"\\n\")\n        local width = 0\n        for lineI lines.len (\n          width = max(width, lines[lineI].len * size * spacing)\n        )\n        local height = lines.len * line_height * 2 * size\n        \n        local x = context.x\n        if boxAlignment == \"l\" (\n          x += width / 2\n        )\n        if boxAlignment == \"r\" (\n          x += width / -2\n        )\n        \n        context.y -= height / (context.anchorY == \"b\" ? -2 2)\n        \n        self.lines @= []\n        local y = context.y + (height / 2)\n        for lineI lines.len (\n          y -= size * line_height\n          local lineW = shared.graphics.getTextWidth(lines[lineI]) * size\n          local lx = x\n          if alignment == \"l\" (\n            lx += width / -2\n          )\n          if alignment == \"r\" (\n            lx += width / 2 - lineW\n          )\n          if alignment == \"c\" (\n            // account for char spacing\n            lx += lineW * -.5\n          )\n          void self.lines.append([lines[lineI], lx, y, size, color])\n          y -= size * line_height\n        )\n        \n        self.debugArea @= [\n          x - (width / 2),\n          context.y - (height / 2),\n          x + (width / 2),\n          context.y + (height / 2)\n        ]\n        \n        context.y -= height / (context.anchorY == \"b\" ? -2 2)\n      )\n      \n      def render() (\n        for lineI self.lines.len (\n          local line @= self.lines[lineI]\n          void shared.graphics.ptext(line[1], line[2], line[3], line[4], line[5])\n        )\n        \n        void rwl.debug.box(self.debugArea ?? [])\n      )\n    )\n    \n    def UpdateElements(array elements, array area, object context) (\n      for i elements.len (\n        local out @= elements[i].update(area, context)\n        if out.isError (\n          return out\n        )\n      )\n    )\n    \n    def RenderElements(array elements) (\n      for i elements.len (\n        //void\n        void elements[i].render()\n        void\n      )\n    )\n    \n    def AstToElement(ast, object inst) (\n      def AstToHeader(header) (\n        local flags @= []\n        local pairs @= []\n        for attrI header.attributes.len (\n          local attr @= header.attributes[attrI]\n          switch attr.kind (\n            case \"flag\"\n              flags.append(attr.data)\n              break\n            case \"key\"\n              void pairs.append([attr.key, rwl.value.AstToValue(attr.value)])\n              break\n          )\n        )\n        return { flags, pairs }\n      )\n      //log \"a\" ast\n      local header @= AstToHeader(ast.data.header)\n      switch ast.kind (\n        case \"block\"\n          if ast.data.header.key != \"script\" (\n            local children @= AstsToElements(ast.data.content.elements, inst)\n          )\n          if typeof(children) != \"array\" and children[\"isError\"] (\n            return children\n          )\n          switch ast.data.header.key (\n            // top level\n            case \"root\"\n              return rwl.main.RWLRoot(children, header)\n            \n            // normal\n            case \"frame\"\n              return rwl.main.RWLFrame(children, header)\n            case \"section\"\n              return rwl.main.RWLSection(children, header)\n            \n            case \"script\"\n              return rwl.main.RWLScript(shared.utils.removeIndents(ast.data.content), header, inst)\n            \n            default\n              return rwl.error.Error(\"UnknownBlockType\", {\n                blockType: ast.data.header.key\n              })\n              break\n          )\n          break\n        case \"element\"\n          return rwl.main.RWLElement(rwl.value.AstToValue(ast.data.value), header)\n        default\n          return rwl.error.Error(\"UnknownElementKind\", {\n            elementKind: ast.kind\n          })\n          break\n      )\n    )\n    \n    def AstsToElements(elements, object inst) (\n      local elems @= []\n      for i elements.len (\n        local out @= AstToElement(elements[i], inst)\n        if out.isError (\n          return out\n        )\n        void elems.append(out)\n      )\n      return elems\n    )\n    \n    class RWL (\n      def init(object ast, object rtrInst) (\n        self.rtrInst @= rtrInst\n        self.errored = false\n        self.needsUpdate = true\n        \n        self._lastW = 0\n        self._lastH = 0\n        \n        void self.loadFromAst(ast)\n      )\n      \n      def loadFromAst(object ast) (\n        self.ast @= ast\n        self.elements @= rwl.main.AstsToElements(ast.elements, self)\n        \n        if typeof(self.elements) != \"array\" and self.elements.isError (\n          error self.elements.stringify()\n          self.errored = true\n          return\n        )\n      )\n      \n      def update(array area) (\n        local out @= rwl.main.UpdateElements(self.elements, area, {\n          inst: self,\n          root: true\n        })\n        if out.isError (\n          error out.stringify()\n          self.errored = true\n          self.errormsg = out.stringify()\n        )\n      )\n      \n      def checkUpdate(array area) (\n        local w = rwl.area.width(area)\n        local h = rwl.area.height(area)\n        \n        // if the width or height has changed, update\n        if w != self._lastW or h != self._lastH (\n          self.needsUpdate = true\n          \n          self._lastW = w\n          self._lastH = h\n        )\n        \n        if self.needsUpdate (\n          void self.update(area)\n          self.needsUpdate = false\n        )\n      )\n      \n      def render(array area) (\n        void self.checkUpdate(area)\n      \n        self.worker.area @= area\n        if self.errored (\n          goto rwl.area.centerX(area) rwl.area.centerY(area)\n          centext \"rwl errored :(\" 12 : c#shared.theme.seco\n          if self.errormsg != null (\n            centext self.errormsg 8 : c#shared.theme.prim chy#-20\n          )\n          return\n        )\n        \n        void rwl.main.RenderElements(self.elements)\n      )\n    )\n  )\n  return __imports__b471b13f60903428337025313115b852\ncase \"./src/rtr/rwl.osl\"\n  class __imports__9a058537c83ea298ad90e68798b3ddc4 (\n    class RTRDocument extends rtr.value.RTRValue (\n      def init(object doc) (\n        self.doc @= doc\n      )\n    \n      def getRtrType() (\n        return rtr.value.RTRTypeValue({\n          name: \"document\"\n        })\n      )\n      \n      def setItem(key, value) (\n        switch key.stringify() (\n          case \"title\"\n            self.doc.title = value.stringify()\n            break\n          case \"icon\"\n            self.doc.icon = value.stringify()\n            break\n          default\n            throw \"unknown property\" + key.stringify() + \"on document\"\n        )\n      )\n    )\n    \n    // applies all rwl related apis to rtr\n    def addToInst(object doc, object rtrInst) (\n      local mods @= rtrInst.modules.getValues()\n      for i mods.len (\n        addToMod(doc, mods[i])\n      )\n    )\n    \n    def addToMod(object doc, object mod) (\n      void mod.declScopeVar(\"document\", RTRDocument(doc))\n    )\n  )\n  return __imports__9a058537c83ea298ad90e68798b3ddc4\ncase \"./src/assets/empty.rwl\"\n  return \"  root {\\n    \\\"grahhh\\\"\\n  }\"\n\ncase \"./main.rwl\"\n  return \"  root [color=theme:prim] {\\n    frame [Horizontal] {\\n      section [size=100, rounding_tr=20, rounding_br=20] {\\n        \\\"fr\\\" [color=theme:seco],\\n        \\\"str\\\",\\n        15\\n      },\\n      section {\\n        frame [Vertical] {\\n          section [size=50] {\\n            \\\"maybe?\\\" [color=theme:text, anchor=\\\"l\\\", padding=10, size=15]\\n          },\\n          section [color=theme:back, rounding=20, margin_r=10, margin_b=10, padding=20] {\\n            \\\"blehhh\\\" [color=theme:text],\\n            \\\"fr\\\",\\n            \\\":P\\\" [anchor=\\\"bl\\\",size=5]\\n          }\\n        }\\n      }\\n    },\\n    script {\\n      event(onload) {\\n        for(i, range(1,10)) {\\n          log(i);\\n        }\\n        \\n        document.title = \\\"gay\\\";\\n        document.icon = \\\"flag-progress\\\";\\n      }\\n    }\\n  }\"\n)\n)\nimport as \"glass\" from \"packages\"\n\n// import overwrite\n\n\nobject rwl @= {\n  main: import(\"./src/rwl/main.osl\"),\n  config: import(\"./src/rwl/config.osl\"),\n  area: import(\"./src/rwl/area.osl\"),\n  error: import(\"./src/rwl/error.osl\"),\n  value: import(\"./src/rwl/value.osl\"),\n  debug: import(\"./src/rwl/debug.osl\"),\n  ast: import(\"./src/rwl/ast.osl\")\n}\n\nobject rtr @= {\n  main: import(\"./src/rtr/main.osl\"),\n  ast: import(\"./src/rtr/ast.osl\"),\n  error: import(\"./src/rtr/error.osl\"),\n  value: import(\"./src/rtr/value.osl\")\n}\n\nrtr.rwl @= import(\"./src/rtr/rwl.osl\")\n\nobject shared @= {\n  graphics: import(\"./src/shared/graphics.osl\"),\n  utils: import(\"./src/shared/utils.osl\"),\n  document: import(\"./src/shared/document.osl\"),\n  tab: import(\"./src/shared/tab.osl\"),\n  url: import(\"./src/shared/url.osl\"),\n  theme: import(\"./src/shared/theme.osl\"),\n  config: import(\"./src/shared/config.osl\"),\n  tab_worker: import(\"./src/shared/tab_worker.osl\")\n}\n\nobject layouts @= {\n  shared: {\n    state: import(\"./src/layouts/shared/state.osl\"),\n    utils: import(\"./src/layouts/shared/utils.osl\"),\n    topbar: import(\"./src/layouts/shared/topbar.osl\"),\n    urlbar: import(\"./src/layouts/shared/urlbar.osl\"),\n    view: import(\"./src/layouts/shared/view.osl\")\n  },\n  chromeLike: {\n    main: import(\"./src/layouts/chromeLike/main.osl\"),\n    topbar: import(\"./src/layouts/chromeLike/topbar.osl\")\n  },\n  summit: {\n    main: import(\"./src/layouts/summit/main.osl\"),\n    sidebar: import(\"./src/layouts/summit/sidebar.osl\"),\n    topbar: import(\"./src/layouts/summit/topbar.osl\")\n  }\n}\n\nobject net @= {\n  fetch: import(\"./src/net/fetch.osl\"),\n  response: import(\"./src/net/response.osl\")\n}\n\nobject devtools @= {\n  main: import(\"./src/devtools/main.osl\"),\n  topbar: import(\"./src/devtools/topbar.osl\"),\n  \n  menus: {\n    elements: import(\"./src/devtools/menus/elements.osl\"),\n    console: import(\"./src/devtools/menus/console.osl\"),\n    network: import(\"./src/devtools/menus/network.osl\"),\n    storage: import(\"./src/devtools/menus/storage.osl\")\n  }\n}\n\nvoid layouts.chromeLike.main.init()\n\nlocal document2 @= shared.document.Document()\nlocal document @= shared.document.Document()\nvoid document.loadUrl(shared.url.Url(\"local://~/projects/phosphorus/main.rwl\"))\nvoid layouts.shared.state.openTabDocument(document)\nvoid layouts.shared.state.openTabDocument(document2)\n\nvoid layouts.shared.state.selectTab(1)\n\nvoid window.resize(900,500)\n\nmainloop:\n  //void layouts.chromeLike.main.update()\n  void layouts.summit.main.update()\n  \n  // file dropping\n  if file_dropped != 0 (\n    local data @= open(file_dropped,[3,2,1])\n    local path = data[1] ++ \"/\" ++ data[2] ++ data[3]\n    local document @= shared.document.Document()\n    void document.loadUrl(shared.url.Url(\"local://\" ++ path))\n    void layouts.shared.state.openTabDocument(document)\n    file_dropped = 0\n  )"]]], [".folder", "src", [[".folder", "rwl", [[".osl", "config", "\ngoob = \"hi\"\n"], [".osl", "area", "\ndef copy(area) (\n  return [area[1], area[2], area[3], area[4]]\n)\n\ndef centerX(area) (\n  return area[1] + area[3] / 2\n)\n\ndef centerY(area) (\n  return area[2] + area[4] / 2\n)\n\ndef width(area) (\n  return area[3] - area[1]\n)\n\ndef height(area) (\n  return area[4] - area[2]\n)\n"], [".osl", "error", "\nobject Errors = {\n  UnknownElementKind: def(data) -> (\n    return \"unknown element kind:\" + data.elementKind\n  ),\n  UnknownAttributeKind: def(data) -> (\n    return \"unknown attribute kind:\" + data.attributeKind\n  ),\n  \n  UnknownValueType: def(data) -> (\n    return \"unknown value type:\" + data.valueType\n  ),\n  UnknownBlockType: def(data) -> (\n    return \"unknown block type:\" + data.blockType\n  ),\n  \n  InvalidAnchorName: def(data) -> (\n    return \"unknown anchor name\" + data.name\n  ),\n  InvalidAlignmentName: def(data) -> (\n    return \"unknown anchor name\" + data.name\n  ),\n  \n  InvalidElemType: def(data) -> (\n    return \"cannot have\" + data.valueType + \"as element\"\n  ),\n  \n  ValueTypeMismatch: def(data) -> (\n    if typeof(data.wanted) == \"string\" (\n      data.wanted @= [data.wanted]\n    )\n    local forCtx = \"\"\n    if data.attr != null (\n      forCtx += \"for\" + data.attr\n    )\n    return \"wanted\" + data.wanted.join(\" or \") + \"got\" + data.got ++ forCtx\n  ),\n  \n  UnknownProperty: def(data) -> (\n    return \"unknown property\" + data.property + \"on\" + data.source\n  ),\n  UnknownPropertySource: def(data) -> (\n    return \"unknown source\" + data.source\n  ),\n  \n  ElemInFrame: def(data) -> (\n    return \"element in a frame, only sections are allowed directly in frames\"\n  ),\n  \n  NoScriptType: def(data) -> (\n    return \"no script type attribute\"\n  ),\n  InvalidScriptType: def(data) -> (\n    return \"unknown script type\" + data.type\n  ),\n  InvalidScriptAttrType: def(data) -> (\n    return \"unknown script type attribute type\" + data.type\n  )\n}\n\nclass Error (\n  boolean isError = true\n  \n  def init(string type, object data) (\n    self.type = type\n    self.data @= data\n    \n    local err @= rwl.error.Errors[type]\n    if err == null (\n      self.txt = \"unknown error type\" + type\n      return\n    )\n    self.txt = err(data)\n  )\n  \n  def stringify() (\n    return \"Error<\" ++ self.type ++ \">:\\n\" ++ self.txt.split(\"\\n\").map(l -> \"    \" ++ l).join(\"\\n\")\n  )\n)\n"], [".osl", "value", "\nclass RWLValue (\n  \n)\n\nclass RWLStrValue extends RWLValue (\n  type = \"str\"\n  def init(string value) (\n    self.value @= value\n  )\n)\n\nclass RWLNumValue extends RWLValue (\n  type = \"num\"\n  def init(number value) (\n    self.value @= value\n  )\n)\n\nclass RWLPercentageValue extends RWLValue (\n  type = \"percentage\"\n  def init(number value) (\n    self.value @= value\n  )\n)\n\nclass RWLColorValue extends RWLValue (\n  type = \"color\"\n  def init(string value) (\n    self.value @= value\n  )\n)\n\ndef AstToValue(ast) (\n  switch ast.type (\n    case \"str\"\n      return rwl.value.RWLStrValue(ast.value)\n    case \"num\"\n      return rwl.value.RWLNumValue(ast.value)\n    case \"percentage\"\n      return rwl.value.RWLPercentageValue(ast.value)\n    case \"color\"\n      return rwl.value.RWLColorValue(ast.value)\n    case \"property\"\n      switch ast.source (\n        case \"theme\"\n          local col = shared.theme[ast.name]\n          if typeof(col) == \"string\" (\n            return rwl.value.RWLColorValue(col)\n          )\n          break\n        default\n          return rwl.error.Error(\"UnknownPropertySource\", {\n            source: ast.source\n          })\n      )\n      return rwl.error.Error(\"UnknownProperty\", {\n        property: ast.name,\n        source: ast.source\n      })\n    default\n      return rwl.error.Error(\"UnknownValueType\", {\n        valueType: ast.type\n      })\n  )\n)\n"], [".osl", "main", "\ndebug = false\n\nclass RWLNode (\n  def update() (\n    \n  )\n  \n  def render() (\n    \n  )\n  \n  def expectOnHeader(string key, string type) (\n    for attrI self.header.pairs.len (\n      local attr @= self.header.pairs[attrI]\n      if attr[2].isError (\n        return attr[2]\n      )\n      if attr[1] == key (\n        if attr[2].type != type (\n          return rwl.error.Error(\"ValueTypeMismatch\", {\n            wanted: type,\n            got: attr[2].type\n          })\n        ) else (\n          return attr[2]\n        )\n      )\n    )\n    return null\n  )\n)\n\nclass RWLContainer extends RWLNode (\n  kind = \"block\"\n  def init(array children, object header) (\n    self.children @= children\n    self.header @= header\n  )\n  \n  def update(array area, object context) (\n    void self.updateBackground(area)\n    \n    local childArea @= rwl.area.copy(area)\n    \n    local childPaddingL = 0\n    local childPaddingR = 0\n    local childPaddingB = 0\n    local childPaddingT = 0\n    \n    for i self.header.pairs.len (\n      local pair @= self.header.pairs[i]\n      local value @= pair[2]\n      \n      switch pair[1] (\n        case \"padding\"\n          childPaddingL = value.value\n          childPaddingR = value.value\n          childPaddingB = value.value\n          childPaddingT = value.value\n          break\n        case \"padding_x\"\n          childPaddingL = value.value\n          childPaddingR = value.value\n          break\n        case \"padding_y\"\n          childPaddingB = value.value\n          childPaddingT = value.value\n          break\n        case \"padding_l\"\n          childPaddingL = value.value\n          break\n        case \"padding_r\"\n          childPaddingR = value.value\n          break\n        case \"padding_b\"\n          childPaddingB = value.value\n          break\n        case \"padding_t\"\n          childPaddingT = value.value\n          break\n      )\n    )\n    \n    childArea[1] += childPaddingL\n    childArea[2] += childPaddingB\n    childArea[3] -= childPaddingR\n    childArea[4] -= childPaddingT\n    \n    self.area @= area\n    self.childArea @= childArea\n    \n    return rwl.main.UpdateElements(self.children, childArea, {\n      x: rwl.area.centerX(childArea),\n      y: rwl.area.centerY(childArea),\n      anchorX: \"c\",\n      anchorY: \"c\",\n      color: \"#fff\",\n      inst: context.inst\n    })\n  )\n  \n  def updateBackground(area) (\n    self.area @= area\n    local color @= self.expectOnHeader(\"color\", \"color\")\n    \n    if color != null (\n      self.color @= color.value\n    )\n    \n    local allRounding @= self.expectOnHeader(\"rounding\", \"num\")\n    \n    local rounding @= allRounding.value ?? 0\n    \n    local corners @= [\"tl\",\"tr\",\"bl\",\"br\"]\n    for i corners.len (\n      local corner @= self.expectOnHeader(\"rounding_\" ++ corners[i], \"num\")\n      if corner != null (\n        if typeof(rounding) != \"array\" (\n          rounding @= []\n          loop i - 1 (\n            void rounding.append(allRounding.value ?? 0)\n          )\n        )\n        void rounding.append(corner.value ?? 0)\n      ) else (\n        void rounding.append(allRounding.value ?? 0)\n      )\n    )\n    self.rounding @= rounding\n  )\n  \n  def render() (\n    void self.renderBackground()\n    if rwl.main.debug (\n      void rwl.debug.box(self.area)\n      void rwl.debug.box(self.childArea, #0f0)\n    )\n    void rwl.main.RenderElements(self.children)\n  )\n  \n  def renderBackground() (\n    if self.color != null (\n      void shared.graphics.filledBox(self.area, self.rounding, self.color)\n    )\n  )\n)\n\nclass RWLRoot extends RWLContainer (\n  blockName = \"root\"\n  \n  def init(array children, object header) (\n    self.children @= children\n    self.header @= header\n  )\n)\n\nclass RWLFrame extends RWLContainer (\n  blockName = \"frame\"\n  \n  def init(array children, object header) (\n    self.children @= children\n    self.header @= header\n  )\n  \n  def update(array area, object context) (\n    void self.updateBackground()\n    local dir = \"x\"\n    local flipped = false\n    for flagI self.header.flags.len (\n      switch self.header.flags[flagI] (\n        case \"Horizontal\"\n          dir = \"x\"\n          break\n        case \"Vertical\"\n          dir = \"y\"\n          break\n        case \"Flipped\"\n          flipped = !flipped\n          break\n      )\n    )\n    \n    local amount = 0\n    if dir == \"x\" (\n      local total = rwl.area.width(area)\n    ) else if dir == \"y\" (\n      local total = rwl.area.height(area)\n    )\n    \n    local frameContext @= {\n      inst: context.inst\n    }\n    \n    for i self.children.len (\n      local child @= self.children[i]\n      if child.kind == \"block\" (\n        \n        local childMarginL = 0\n        local childMarginR = 0\n        local childMarginB = 0\n        local childMarginT = 0\n        \n        // defaults to remaining\n        local size = total - amount\n        local pairs @= child.header.pairs\n        for pairI pairs.len (\n          local pair @= pairs[pairI]\n          local value @= pair[2]\n          if pair[1] == \"size\" or (pair[1] == \"width\" and dir == \"x\") or (pair[1] == \"height\" and dir == \"y\") (\n            switch value.type (\n              case \"num\"\n                size = value.value\n                break\n              case \"percentage\"\n                size = value.value / 100 * (total - amount)\n                break\n              default\n                return rwl.error.Error(\"ValueTypeMismatch\", {\n                  wanted: [\"num\", \"percentage\"],\n                  got: value.type\n                })\n            )\n            break\n          )\n          \n          switch pair[1] (\n            case \"margin\"\n              childMarginL = value.value\n              childMarginR = value.value\n              childMarginB = value.value\n              childMarginT = value.value\n              break\n            case \"margin_x\"\n              childMarginL = value.value\n              childMarginR = value.value\n              break\n            case \"margin_y\"\n              childMarginB = value.value\n              childMarginT = value.value\n              break\n            case \"margin_l\"\n              childMarginL = value.value\n              break\n            case \"margin_r\"\n              childMarginR = value.value\n              break\n            case \"margin_b\"\n              childMarginB = value.value\n              break\n            case \"margin_t\"\n              childMarginT = value.value\n              break\n          )\n        )\n        \n        if dir == \"x\" (\n          local childArea @= [\n            (flipped ? (area[3] - amount - size) (area[1] + amount)) + childMarginL,\n            area[2] + childMarginB,\n            (flipped ? (area[3] - amount) (area[1] + amount + size)) - childMarginR,\n            area[4] - childMarginT\n          ]\n        ) else if dir == \"y\" (\n          local childArea @= [\n            area[1] + childMarginL,\n            (flipped ? (area[2] + amount) (area[4] - amount - size)) + childMarginB,\n            area[3] - childMarginR,\n            (flipped ? (area[2] + amount + size) (area[4] - amount)) - childMarginT\n          ]\n        )\n        \n        local out @= child.update(childArea, frameContext)\n        if out.isError (\n          return out\n        )\n        \n        amount += size\n      )\n    )\n  )\n  \n  def render() (\n    void self.renderBackground()\n    void rwl.main.RenderElements(self.children)\n  )\n)\n\nclass RWLSection extends RWLContainer (\n  blockName = \"section\"\n  \n  def init(array children, object header) (\n    self.children @= children\n    self.header @= header\n  )\n)\n\nclass RWLScript extends RWLNode (\n  blockName = \"script\"\n  kind = \"script\"\n  \n  def init(body, object header, object inst) (\n    self.body @= body\n    self.header @= header\n    \n    void self.parse()\n    void self.makeModule(inst)\n  )\n  \n  def parse() (\n    self.ast @= null\n    // TODO: try\n    local parser @= rtr.ast.Parser(body)\n    self.ast @= parser.parse()\n  )\n  \n  def makeModule(object inst) (\n    if self.ast != null (\n      self.mod @= rtr.main.Module(self.ast)\n      void inst.rtrInst.addModule(self.mod)\n    )\n  )\n  \n  def update(array area, object context) (\n    if self.mod != null (\n      void self.mod.runEvent(\"onupdate\", {})\n    )\n  )\n)\n\nclass RWLElement extends RWLNode (\n  kind = \"element\"\n  def init(object value, object header) (\n    self.value @= value\n    self.header @= header\n  )\n  \n  def update(array area, object context) (\n    local text = null\n    \n    switch self.value.type (\n      case \"str\"; case \"num\"\n        text = self.value.value.toStr()\n        break\n    )\n    \n    if text == null (\n      return rwl.error.Error(\"InvalidElemType\", {\n        valueType: self.value.type\n      })\n    )\n    \n    // font\n    //<font>\n    local size @= self.expectOnHeader(\"size\", \"num\")\n    if size.isError (\n      return size\n    )\n    size = size[\"value\"] ?? 10\n    \n    local spacing @= self.expectOnHeader(\"spacing\", \"num\")\n    if spacing.isError (\n      return spacing\n    )\n    spacing = spacing[\"value\"] ?? 1\n    \n    local line_height @= self.expectOnHeader(\"line_height\", \"num\")\n    if line_height.isError (\n      return line_height\n    )\n    line_height = spacing[\"line_height\"] ?? 1\n    \n    // positioning\n    local padding @= self.expectOnHeader(\"padding\", \"num\")\n    if padding.isError (\n      return padding\n    )\n    padding = padding[\"value\"] ?? 0\n    \n    local anchor @= self.expectOnHeader(\"anchor\", \"str\")\n    if anchor.isError (\n      return anchor\n    )\n    anchor = anchor[\"value\"]\n    \n    if anchor != null (\n      if [\"tl\",\"t\",\"tr\",\n          \"l\",\"c\",\"r\",\n          \"bl\",\"b\",\"br\",\n          \"top left\", \"top\", \"top right\",\n          \"left\", \"center\", \"right\",\n          \"bottom left\", \"bottom\", \"bottom right\"].contains(anchor).not() (\n        return rwl.error.Error(\"InvalidAnchorName\", {\n          name: anchor\n        })\n      )\n      \n      local anchorX = rwl.area.centerX(area)\n      local anchorY = rwl.area.centerY(area) + (line_height * 1 * size)\n      local anchorXType = \"c\"\n      local anchorYType = \"c\"\n      \n      if anchor.endsWith(\"l\") or anchor.endsWith(\"left\") (\n        anchorX = area[1] + padding\n        anchorXType = \"l\"\n      )\n      if anchor.endsWith(\"r\") or anchor.endsWith(\"right\") (\n        anchorX = area[3] - padding\n        anchorXType = \"r\"\n      )\n      \n      if anchor.startsWith(\"t\") or anchor.endsWith(\"top\") (\n        anchorY = area[4] - padding\n        anchorYType = \"t\"\n      )\n      if anchor.startsWith(\"b\") or anchor.endsWith(\"bottom\") (\n        anchorY = area[2] + padding\n        anchorYType = \"b\"\n      )\n      \n      context.x = anchorX\n      context.y = anchorY\n      context.anchorX = anchorXType\n      context.anchorY = anchorYType\n    )\n    \n    local boxAlignment = context.anchorX\n    \n    local alignment @= self.expectOnHeader(\"alignment\", \"str\")\n    if alignment.isError (\n      return alignment\n    )\n    alignment = alignment[\"value\"]\n    if alignment != null (\n      if [\"l\",\"c\",\"r\",\n          \"left\", \"center\", \"right\"].contains(alignment).not() (\n        return rwl.error.Error(\"InvalidAlignmentName\", {\n          name: anchor\n        })\n      )\n      \n      if alignment.endsWith(\"l\") or alignment.endsWith(\"left\") (\n        alignment = \"l\"\n      )\n      if alignment.endsWith(\"r\") or alignment.endsWith(\"right\") (\n        alignment = \"r\"\n      )\n    )\n    alignment ??= boxAlignment\n    \n    // appearance\n    //<link>\n    //<decoration>\n    local color @= self.expectOnHeader(\"color\", \"color\")\n    if color.isError (\n      return color\n    )\n    color = color[\"value\"]\n    if color != null (\n      context.color = color\n    )\n    color ??= context.color\n    \n    local lines @= text.split(\"\\n\")\n    local width = 0\n    for lineI lines.len (\n      width = max(width, lines[lineI].len * size * spacing)\n    )\n    local height = lines.len * line_height * 2 * size\n    \n    local x = context.x\n    if boxAlignment == \"l\" (\n      x += width / 2\n    )\n    if boxAlignment == \"r\" (\n      x += width / -2\n    )\n    \n    context.y -= height / (context.anchorY == \"b\" ? -2 2)\n    \n    self.lines @= []\n    local y = context.y + (height / 2)\n    for lineI lines.len (\n      y -= size * line_height\n      local lineW = shared.graphics.getTextWidth(lines[lineI]) * size\n      local lx = x\n      if alignment == \"l\" (\n        lx += width / -2\n      )\n      if alignment == \"r\" (\n        lx += width / 2 - lineW\n      )\n      if alignment == \"c\" (\n        // account for char spacing\n        lx += lineW * -.5\n      )\n      void self.lines.append([lines[lineI], lx, y, size, color])\n      y -= size * line_height\n    )\n    \n    self.debugArea @= [\n      x - (width / 2),\n      context.y - (height / 2),\n      x + (width / 2),\n      context.y + (height / 2)\n    ]\n    \n    context.y -= height / (context.anchorY == \"b\" ? -2 2)\n  )\n  \n  def render() (\n    for lineI self.lines.len (\n      local line @= self.lines[lineI]\n      void shared.graphics.ptext(line[1], line[2], line[3], line[4], line[5])\n    )\n    \n    void rwl.debug.box(self.debugArea ?? [])\n  )\n)\n\ndef UpdateElements(array elements, array area, object context) (\n  for i elements.len (\n    local out @= elements[i].update(area, context)\n    if out.isError (\n      return out\n    )\n  )\n)\n\ndef RenderElements(array elements) (\n  for i elements.len (\n    //void\n    void elements[i].render()\n    void\n  )\n)\n\ndef AstToElement(ast, object inst) (\n  def AstToHeader(header) (\n    local flags @= []\n    local pairs @= []\n    for attrI header.attributes.len (\n      local attr @= header.attributes[attrI]\n      switch attr.kind (\n        case \"flag\"\n          flags.append(attr.data)\n          break\n        case \"key\"\n          void pairs.append([attr.key, rwl.value.AstToValue(attr.value)])\n          break\n      )\n    )\n    return { flags, pairs }\n  )\n  //log \"a\" ast\n  local header @= AstToHeader(ast.data.header)\n  switch ast.kind (\n    case \"block\"\n      if ast.data.header.key != \"script\" (\n        local children @= AstsToElements(ast.data.content.elements, inst)\n      )\n      if typeof(children) != \"array\" and children[\"isError\"] (\n        return children\n      )\n      switch ast.data.header.key (\n        // top level\n        case \"root\"\n          return rwl.main.RWLRoot(children, header)\n        \n        // normal\n        case \"frame\"\n          return rwl.main.RWLFrame(children, header)\n        case \"section\"\n          return rwl.main.RWLSection(children, header)\n        \n        case \"script\"\n          return rwl.main.RWLScript(shared.utils.removeIndents(ast.data.content), header, inst)\n        \n        default\n          return rwl.error.Error(\"UnknownBlockType\", {\n            blockType: ast.data.header.key\n          })\n          break\n      )\n      break\n    case \"element\"\n      return rwl.main.RWLElement(rwl.value.AstToValue(ast.data.value), header)\n    default\n      return rwl.error.Error(\"UnknownElementKind\", {\n        elementKind: ast.kind\n      })\n      break\n  )\n)\n\ndef AstsToElements(elements, object inst) (\n  local elems @= []\n  for i elements.len (\n    local out @= AstToElement(elements[i], inst)\n    if out.isError (\n      return out\n    )\n    void elems.append(out)\n  )\n  return elems\n)\n\nclass RWL (\n  def init(object ast, object rtrInst) (\n    self.rtrInst @= rtrInst\n    self.errored = false\n    self.needsUpdate = true\n    \n    self._lastW = 0\n    self._lastH = 0\n    \n    void self.loadFromAst(ast)\n  )\n  \n  def loadFromAst(object ast) (\n    self.ast @= ast\n    self.elements @= rwl.main.AstsToElements(ast.elements, self)\n    \n    if typeof(self.elements) != \"array\" and self.elements.isError (\n      error self.elements.stringify()\n      self.errored = true\n      return\n    )\n  )\n  \n  def update(array area) (\n    local out @= rwl.main.UpdateElements(self.elements, area, {\n      inst: self,\n      root: true\n    })\n    if out.isError (\n      error out.stringify()\n      self.errored = true\n      self.errormsg = out.stringify()\n    )\n  )\n  \n  def checkUpdate(array area) (\n    local w = rwl.area.width(area)\n    local h = rwl.area.height(area)\n    \n    // if the width or height has changed, update\n    if w != self._lastW or h != self._lastH (\n      self.needsUpdate = true\n      \n      self._lastW = w\n      self._lastH = h\n    )\n    \n    if self.needsUpdate (\n      void self.update(area)\n      self.needsUpdate = false\n    )\n  )\n  \n  def render(array area) (\n    void self.checkUpdate(area)\n  \n    self.worker.area @= area\n    if self.errored (\n      goto rwl.area.centerX(area) rwl.area.centerY(area)\n      centext \"rwl errored :(\" 12 : c#shared.theme.seco\n      if self.errormsg != null (\n        centext self.errormsg 8 : c#shared.theme.prim chy#-20\n      )\n      return\n    )\n    \n    void rwl.main.RenderElements(self.elements)\n  )\n)\n"], [".osl", "debug", "def box(array area, color) (\n  if !rwl.main.debug (\n    return\n  )\n  void shared.graphics.box(area, color ?? #f00)\n)"], [".osl", "ast", "\nclass Parser (\n  def init(string text) (\n    void self.tokenise(text)\n  )\n  \n  def parse() (\n    self.pointer = 1\n    \n    local out @= {\n      elements: self.blockContent()\n    }\n    \n    if !self.atEnd() (\n      throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n    )\n    \n    return out\n  )\n  \n  def peek() (\n    return self.tokens[self.pointer]\n  )\n  def consume() (\n    local tkn = self.peek()\n    self.pointer ++\n    return tkn\n  )\n  def consumeWhitespace() (\n    while self.peek().match(\"/^\\\\s$/\") != null (\n      void self.consume()\n    )\n  )\n  def consumeSpaces() (\n    local txt = \"\"\n    while self.peek() == \" \" (\n      txt ++= self.consume()\n    )\n    return txt\n  )\n  def atEnd() (\n    return self.pointer >= self.tokens.len\n  )\n  def expect(string token) (\n    local tkn @= self.consume()\n    if tkn != token (\n      throw \"expected '\" ++ token ++ \"' got '\" ++ tkn ++ \"'\"\n    )\n    return tkn\n  )\n  def expects(array tokens) (\n    local tkn @= self.consume()\n    if !tokens.contains(tkn) (\n      throw \"expected '\" ++ tokens.join(\" or \") ++ \"' got '\" ++ tkn ++ \"'\"\n    )\n    return tkn\n  )\n  \n  def tokenise(string text) (\n    self.tokens @= []\n    local splitChars @= [\n      // rwl\n      \"{\",\"}\",\n      \"[\",\"]\",\n      \",\",\n      \" \",\n      \"\\n\",\n      \"/\",\"\\\\\",\"*\",\n      \"'\",\"\\\"\",\"`\",\n      \":\",\"#\",\"%\",\"=\",\n      // rtr\n      \"(\",\")\",\n      \"[\",\"]\",\n      \"{\",\"}\",\n      \",\",\";\",\":\",\"=\",\".\",\n      \"+\",\"-\",\"*\",\"/\",\"%\",\"^\",\n      \"\\\\\",\n      \"'\",\"\\\"\",\"`\",\n      \" \",\"\\n\",\n      \"!\",\"?\"\n    ]\n    local buf = \"\"\n    for i text.len (\n      if splitChars.contains(text[i]) (\n        if buf.len > 0 (\n          void self.tokens.append(buf)\n        )\n        void self.tokens.append(text[i])\n        buf = \"\"\n      ) else (\n        buf ++= text[i]\n      )\n    )\n    if buf.len > 0 (\n      self.tokens.append(buf)\n    )\n  )\n  \n  // statements\n  def blockContent() (\n    local statements @= []\n    local end = false\n    while !end (\n      local out @= self.statement()\n      if out != null (\n        void statements.append(out)\n      )\n      void self.consumeWhitespace()\n      if self.peek() == \"}\" or self.atEnd() (\n        end = true\n      ) else (\n        void self.expect(\",\")\n      )\n    )\n    return statements\n  )\n  \n  def statement() (\n    void self.consumeWhitespace()\n    \n    local tkn @= self.peek()\n    \n    // block\n    if tkn.match(\"/^[a-zA-Z]+$/\") != null (\n      return self.blockStatement()\n    )\n    \n    // element\n    local value @= self.value()\n    if value != null (\n      void self.consumeWhitespace()\n      local header @= self.header()\n      \n      return {\n        data: {\n          value,\n          header\n        },\n        kind: \"element\"\n      }\n    )\n  )\n  \n  def blockStatement() (\n    local key @= self.consume()\n    \n    void self.consumeWhitespace()\n    \n    local header @= self.header()\n    header.key = key\n    \n    void self.consumeWhitespace()\n    \n    if key == \"script\" (\n      local content = \"\"\n      local spaceContent = \"\"\n      void self.expect(\"{\")\n      local end = false\n      local depth = 1\n      local stringType = null\n      while !end (\n        local tkn @= self.peek()\n        \n        if tkn == \"'\" (\n          if stringType == \"'\" (\n            stringType = null\n          ) else if stringType == null (\n            stringType = \"'\"\n          )\n        )\n        \n        if tkn == \"\\\"\" (\n          if stringType == \"\\\"\" (\n            stringType = null\n          ) else if stringType == null (\n            stringType = \"\\\"\"\n          )\n        )\n        \n        if tkn == \"`\" (\n          if stringType == \"`\" (\n            stringType = null\n          ) else if stringType == null (\n            stringType = \"`\"\n          )\n        )\n        \n        if stringType == null (\n          if tkn == \"{\" (\n            depth ++\n          )\n          if tkn == \"}\" (\n            depth --\n          )\n        )\n        \n        if self.atEnd() or (tkn == \"}\" and depth == 0 and stringType == null) (\n          end = true\n        ) else (\n          if tkn == \"\\n\" (\n            spaceContent = \"\"\n            void self.consume()\n            if content != \"\" (\n              content ++= \"\\n\"\n            )\n          ) else if tkn == \" \" (\n            spaceContent ++= self.consume()\n          ) else (\n            content ++= spaceContent\n            content ++= self.consume()\n            spaceContent = \"\"\n          )\n        )\n      )\n      void self.expect(\"}\")\n    ) else (\n      local content @= self.block()\n    )\n    \n    return {\n      kind: \"block\",\n      data: {\n        header,\n        content\n      }\n    }\n  )\n  \n  def block() (\n    void self.expect(\"{\")\n    void self.consumeWhitespace()\n    local elements @= self.blockContent()\n    void self.consumeWhitespace()\n    void self.expect(\"}\")\n    return { elements }\n  )\n  \n  // header stuff\n  def header() (\n    local attributes @= []\n    if self.peek() == \"[\" (\n      void self.expect(\"[\")\n      local end = self.peek() == \"]\"\n      while !end (\n        local out @= self.headerItem()\n        if out != null (\n          void attributes.append(out)\n        )\n        void self.consumeWhitespace()\n        if self.peek() == \",\" (\n          void self.consume()\n        )\n        if self.peek() == \"]\" or self.atEnd() (\n          end = true\n        )\n      )\n      void self.expect(\"]\")\n    )\n    \n    return { attributes }\n  )\n  def headerItem() (\n    void self.consumeWhitespace()\n    local tkn @= self.consume()\n    void self.consumeWhitespace()\n    if self.peek() == \"=\" (\n      if tkn.match(\"/^[a-zA-Z_]+$/\") == null (\n        throw \"attribute key must consist of letters or _\"\n      )\n      void self.consume()\n      local value @= self.value()\n      return {\n        kind: \"key\",\n        key: tkn,\n        value\n      }\n    )\n    if tkn.match(\"/^[a-zA-Z_]+$/\") != null (\n      return {\n        kind: \"flag\",\n        data: tkn\n      }\n    )\n  )\n  \n  // values\n  def value() (\n    if [\"'\",\"\\\"\",\"`\"].contains(self.peek()) (\n      return self.str()\n    )\n    \n    if self.peek().match(\"/^[0-9]+$/\") != null (\n      return self.num()\n    )\n    \n    if self.peek() == \"#\" (\n      return self.color()\n    )\n    \n    if self.peek().match(\"/^\\\\w+$/\") != null (\n      return self.property()\n    )\n  )\n  \n  def str() (\n    local q @= self.expects([\"'\",\"\\\"\",\"`\"])\n    local content = \"\"\n    local end = false\n    while (!end) (\n      local tkn @= self.peek()\n      if tkn == \"\\\\\" (\n        void self.consume()\n        local tkn = self.consume()\n        local char = tkn[1]\n        switch char (\n          case \"n\"\n            char = \"\\n\"\n            break\n        )\n        content ++= char ++ tkn.trim(2,-1)\n        continue\n      )\n      \n      if q == tkn (\n        end = true\n      ) else (\n        content ++= self.consume()\n      )\n      if self.atEnd() (\n        end = true\n      )\n    )\n    void self.expect(q)\n    return {\n      type: \"str\",\n      value: content\n    }\n  )\n  \n  // and percentage\n  def num() (\n    if self.peek().match(\"/^[0-9]+$/\") == null (\n      throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n    )\n    \n    local value @= self.consume().toNum()\n    \n    local type = \"num\"\n    \n    if self.peek() == \"%\" (\n      void self.consume()\n      type = \"percentage\"\n    )\n    \n    return {\n      type,\n      value\n    }\n  )\n  \n  def color() (\n    void self.expect(\"#\")\n    local value = self.consume()\n    if ![3,6].contains(value.len) (\n      throw \"hex values can only be 3 or 6 characters long\"\n    )\n    return {\n      type: \"color\",\n      value: \"#\" ++ value\n    }\n  )\n  \n  def property() (\n    local source = self.consume()\n    if source.match(\"/^[a-zA-Z_]+$/\") == null (\n      throw \"source must consist of letters or _\"\n    )\n    \n    void self.consumeWhitespace()\n    void self.expect(\":\")\n    void self.consumeWhitespace()\n    \n    local name = self.consume()\n    if name.match(\"/^[a-zA-Z_]+$/\") == null (\n      throw \"name must consist of letters or _\"\n    )\n    \n    return {\n      type: \"property\",\n      source,\n      name\n    }\n  )\n)\n"]]], [".folder", "rtr", [[".osl", "main", "\nclass Module (\n  def init(object ast) (\n    void self.loadFromAst(ast)\n    void self.initScope()\n    void self.defScope()\n  )\n  def loadFromAst(object ast) (\n    self.ast @= ast\n    \n    self.events @= {}\n    self.eventList @= []\n    for i self.ast.elements.len (\n      local topLevel @= self.ast.elements[i]\n      if topLevel.kind == \"event\" (\n        if self.eventList.contains(topLevel.name) (\n          throw topLevel.name + \"event already exists on module\"\n        )\n        void self.eventList.append(topLevel.name)\n        self.events[topLevel.name] @= topLevel\n      )\n    )\n  )\n  \n  def initScope() (\n    self.scope @= []\n  )\n  def newScope(object vars) (\n    void self.scope.append(vars)\n  )\n  def popScope() (\n    return self.scope.pop()\n  )\n  def defScope() (\n    // helper funcs\n    local cFunc @= def(name, content) -> (\n      void self.setScopeVar(name, rtr.value.RTROslFuncValue(content))\n    )\n    \n    void self.newScope({})\n    \n    void self.setScopeVar(\"true\", rtr.value.RTRBoolValue(true))\n    void self.setScopeVar(\"false\", rtr.value.RTRBoolValue(false))\n    \n    cFunc(\"log\", def(args, inst) -> (\n      local txt = args.map(a -> a.stringify()).join(\" \")\n      log txt\n      void inst.inst.console.append([\"log\", txt])\n    ))\n    cFunc(\"error\", def(args, inst) -> (\n      local txt = args.map(a -> a.stringify()).join(\" \")\n      void inst.inst.console.append([\"err\", txt])\n      throw txt\n    ))\n    cFunc(\"return\", def(args, inst) -> (\n      local val @= args[1]\n      val ??= rtr.value.RTRNullValue()\n      void inst.setScopeVar(\"@return\", val)\n    ))\n    cFunc(\"typeof\", def(args) -> (\n      local val @= args[1] ?? rtr.value.RTRNullValue()\n      return val.getRtrType()\n    ))\n    cFunc(\"length\", def(args) -> (\n      return rtr.value.RTRNumValue(args[1].length())\n    ))\n    \n    // mathematical\n    cFunc(\"min\", def(args) -> (\n      local v = args[1].numbify()\n      for i args.len - 1 (\n        local a @= args[i + 1].numbify()\n        v = min(v, a)\n      )\n      return rtr.value.RTRNumValue(v)\n    ))\n    cFunc(\"max\", def(args) -> (\n      local v = args[1].numbify()\n      for i args.len - 1 (\n        local a @= args[i + 1].numbify()\n        v = max(v, a)\n      )\n      return rtr.value.RTRNumValue(v)\n    ))\n    \n    cFunc(\"abs\", def(args) -> (\n      return rtr.value.RTRNumValue(args[1].numbify().abs())\n    ))\n    cFunc(\"sqrt\", def(args) -> (\n      return rtr.value.RTRNumValue(args[1].numbify().sqrt())\n    ))\n    \n    cFunc(\"round\", def(args) -> (\n      return rtr.value.RTRNumValue(args[1].numbify().round())\n    ))\n    cFunc(\"floor\", def(args) -> (\n      return rtr.value.RTRNumValue(args[1].numbify().floor())\n    ))\n    cFunc(\"ceil\", def(args) -> (\n      return rtr.value.RTRNumValue(args[1].numbify().ceiling())\n    ))\n    \n    // string\n    cFunc(\"join\", def(args) -> (\n      local txt = \"\"\n      for i args.len (\n        txt ++= args[i].stringify()\n      )\n      return rtr.value.RTRStrValue(txt)\n    ))\n    cFunc(\"split\", def(args) -> (\n      return rtr.value.RTRArrValue(args[1]\n        .stringify()\n        .split(args[2].stringify())\n        .map(e -> rtr.value.RTRStrValue(e)))\n    ))\n    \n    cFunc(\"chr\", def(args) -> (\n      return rtr.value.RTRStrValue(args[1].numbify().chr())\n    ))\n    cFunc(\"ord\", def(args) -> (\n      return rtr.value.RTRNumValue(args[1].stringify().ord())\n    ))\n    \n    // array\n    cFunc(\"item\", def(args) -> (\n      return args[1].getItem(args[2])\n    ))\n    cFunc(\"range\", def(args) -> (\n      return rtr.value.RTRArrValue((args[1].numbify() to args[2].numbify()).map(e -> rtr.value.RTRNumValue(e)))\n    ))\n    \n    // object\n    cFunc(\"keys\", def(args) -> (\n      return rtr.value.RTRArrValue(args[1].keys().map(e -> rtr.value.RTRStrValue(e)))\n    ))\n    cFunc(\"values\", def(args) -> (\n      return rtr.value.RTRArrValue(args[1].values())\n    ))\n    cFunc(\"has\", def(args) -> (\n      return rtr.value.RTRBoolValue(args[1].has(args[2].stringify()))\n    ))\n    cFunc(\"obj\", def() -> (\n      return rtr.value.RTRObjValue({})\n    ))\n    \n    // logical\n    cFunc(\"all\", def(args) -> (\n      return rtr.value.RTRBoolValue(args.every(a -> a.boolify()))\n    ))\n    cFunc(\"any\", def(args) -> (\n      return rtr.value.RTRBoolValue(args.some(a -> a.boolify()))\n    ))\n    cFunc(\"not\", def(args) -> (\n      return rtr.value.RTRBoolValue(!args[1].boolify())\n    ))\n  )\n  def getScopeVarRaw(string key) (\n    for rawI self.scope.len (\n      local layer @= self.scope[self.scope.len - rawI + 1]\n      if layer[key] != null (\n        return layer[key]\n      )\n    )\n    return null\n  )\n  def getScopeVar(string key) (\n    return self.getScopeVarRaw(key)[1]\n  )\n  def getScopeVarMeta(string key) (\n    return self.getScopeVarRaw(key)[2]\n  )\n  def setScopeVar(string key, val, meta) (\n    meta ??= {}\n    for rawI self.scope.len (\n      local layer @= self.scope[self.scope.len - rawI + 1]\n      if layer[key] != null (\n        layer[key] @= [val, layer[key][2] ++ meta]\n        return\n      )\n    )\n    void self.declScopeVar(key, val, meta)\n  )\n  def declScopeVar(string key, val, meta) (\n    self.scope[self.scope.len][key] @= [val, meta]\n  )\n  \n  def runEvent(string name, object data) (\n    if !self.eventList.contains(name) (\n      return\n    )\n    \n    local ev @= self.events[name]\n    void self.runBlock(ev.body)\n  )\n  def runBlock(object block) (\n    local elements @= block.elements\n    local outVal @= rtr.value.RTRNullValue()\n    void self.newScope({})\n    for i elements.len (\n      local out @= self.runStatement(elements[i])\n      if self.getScopeVar(\"@return\") ?? 0 != 0 (\n        break\n      )\n    )\n    void self.popScope()\n    return outVal\n  )\n  def runStatement(object statement) (\n    switch statement.kind (\n      case \"expression\"\n        return self.runExpression(statement.expr)\n      case \"block\"\n        return self.runBlock(statement.body)\n      \n      case \"branch\"\n        if self.runExpression(statement.cond).boolify() (\n          return self.runStatement(statement.body)\n        )\n        for i statement.elifs.len (\n          local elif @= statement.elifs[i]\n          if self.runExpression(elif.cond).boolify() (\n            return self.runStatement(elif.body)\n          )\n        )\n        if statement.elseBody != null (\n          return self.runStatement(statement.elseBody)\n        )\n        return rtr.value.RTRNullValue()\n      \n      case \"while\"\n        local iters = 0\n        while self.runExpression(statement.cond).boolify() and self.getScopeVar(\"@return\") ?? 0 == 0 and iters < 999999 (\n          void self.runStatement(statement.body)\n          iters ++\n        )\n        return rtr.value.RTRNullValue()\n      case \"until\"\n        local iters = 0\n        while !self.runExpression(statement.cond).boolify() and self.getScopeVar(\"@return\") ?? 0 == 0 and iters < 999999 (\n          void self.runStatement(statement.body)\n          iters ++\n        )\n        return rtr.value.RTRNullValue()\n      case \"repeat\"\n        loop self.runExpression(statement.amount).numbify() (\n          void self.runStatement(statement.body)\n        )\n        return rtr.value.RTRNullValue()\n      case \"for\"\n        local arr @= self.runExpression(statement.arr).arrify()\n        for i arr.len (\n          void self.newScope({})\n          void self.declScopeVar(statement.var, arr[i])\n          void self.runStatement(statement.body)\n          void self.popScope()\n        )\n        return rtr.value.RTRNullValue()\n      \n      default\n        throw \"unknown statement type\" + statement.kind\n    )\n  )\n  def runExpression(object expression) (\n    switch expression.kind (\n      case \"call\"\n        local func @= self.runExpression(expression.func)\n        local args @= []\n        for i expression.args.len (\n          void args.append(self.runExpression(expression.args[i]))\n        )\n        return func.callFunc(self, args) ?? rtr.value.RTRNullValue()\n      case \"decl\"\n        local val @= self.runExpression(expression.val)\n        \n        void self.declScopeVar(expression.tar, val, {\n          type: val.getRtrType()\n        })\n        \n        return val\n      case \"asi\"\n        local val @= self.runExpression(expression.val)\n        \n        local existingMeta = null\n        local existing = null\n        switch expression.tar.kind (\n          case \"var\"\n            existingMeta @= self.getScopeVarMeta(expression.tar.name)\n            existing @= self.getScopeVar(expression.tar.name)\n            break\n          case \"prop\"\n            existing @= self.runExpression(expression.tar)\n            break\n        )\n        \n        if expression.op != null (\n          val @= self.runOperation(existing, expression.op, val)\n        )\n        \n        switch expression.tar.kind (\n          case \"var\"\n            if existingMeta != null (\n              local curType @= val.getRtrType()\n              if existingMeta.type != null (\n                if !existingMeta.type.isEqual(curType) (\n                  throw \"cannot assign\" + curType.stringify() + \"to\" + existingMeta.type.stringify() + \"variable\" \n                )\n              )\n            )\n            void self.setScopeVar(expression.tar.name, val)\n            break\n          case \"prop\"\n            local obj @= self.runExpression(expression.tar.obj)\n            local key @= expression.tar.key\n            if typeof(key) == \"string\" (\n              key @= rtr.value.RTRStrValue(key)\n            ) else (\n              key @= self.runExpression(key)\n            )\n            obj.setItem(key, val)\n            break\n          default\n            throw \"cannot assign to\" + expression.tar.kind\n        )\n        \n        return val\n      case \"unary\"\n        local val @= self.runExpression(expression.expr)\n        switch expression.type (\n          case \"-\"\n            return rtr.value.RTRNumValue(-val.numbify())\n          case \"+\"\n            return rtr.value.RTRNumValue(val.numbify())\n          case \"!\"\n            return rtr.value.RTRBoolValue(!val.boolify())\n          case \"?\"\n            return rtr.value.RTRBoolValue(val.boolify())\n        )\n        return rtr.value.RTRNullValue()\n      case \"binary\"\n        local left @= self.runExpression(expression.left)\n        local right @= self.runExpression(expression.right)\n        return self.runOperation(left, expression.op, right)\n      case \"var\"\n        local val @= self.getScopeVar(expression.name)\n        return val ?? rtr.value.RTRNullValue()\n      case \"prop\"\n        local obj @= self.runExpression(expression.obj)\n        local key @= expression.key\n        if typeof(key) == \"string\" (\n          key @= rtr.value.RTRStrValue(key)\n        ) else (\n          key @= self.runExpression(key)\n        )\n        return obj.getItem(key) ?? rtr.value.RTRNullValue()\n      \n      case \"str\"\n        return rtr.value.RTRStrValue(expression.val)\n      case \"num\"\n        return rtr.value.RTRNumValue(expression.val)\n      case \"func\"\n        return rtr.value.RTRAstFuncValue(expression.args, expression.body)\n      case \"arr\"\n        return rtr.value.RTRArrValue(expression.elems.map(e -> self.runExpression(e)))\n      case \"obj\"\n        local val @= {}\n        for i expression.pairs.len (\n          local pair @= expression.pairs[i]\n          val[pair.name] @= self.runExpression(pair.value)\n        )\n        return rtr.value.RTRObjValue(val)\n      \n      default\n        throw \"unknown expression type\" + expression.kind\n    )\n  )\n  def runOperation(object left, op, object right) (\n    local numT @= rtr.value.RTRNumValue.getRtrType()\n    switch op (\n      case \"+\"\n        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n          return rtr.value.RTRNumValue(left.numbify() + right.numbify())\n        )\n        return rtr.value.RTRStrValue(left.stringify() ++ right.stringify())\n      case \"-\"\n        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n          return rtr.value.RTRNumValue(left.numbify() - right.numbify())\n        )\n        return rtr.value.RTRNumValue(NaN)\n      case \"*\"\n        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n          return rtr.value.RTRNumValue(left.numbify() * right.numbify())\n        )\n        return rtr.value.RTRNumValue(NaN)\n      case \"/\"\n        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n          return rtr.value.RTRNumValue(left.numbify() / right.numbify())\n        )\n        return rtr.value.RTRNumValue(NaN)\n      case \"%\"\n        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n          return rtr.value.RTRNumValue(left.numbify() % right.numbify())\n        )\n        return rtr.value.RTRNumValue(NaN)\n      case \"^\"\n        if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (\n          return rtr.value.RTRNumValue(left.numbify() ^ right.numbify())\n        )\n        return rtr.value.RTRNumValue(NaN)\n      \n      case \"==\"\n        return rtr.value.RTRBoolValue(left.isEqual(right))\n      case \"!=\"\n        return rtr.value.RTRBoolValue(left.isEqual(right))\n      \n      case \">\"\n        return rtr.value.RTRBoolValue(left.numbify() > right.numbify())\n      case \"<\"\n        return rtr.value.RTRBoolValue(left.numbify() < right.numbify())\n      case \">=\"\n        return rtr.value.RTRBoolValue(left.numbify() >= right.numbify())\n      case \"<=\"\n        return rtr.value.RTRBoolValue(left.numbify() <= right.numbify())\n    \n      case \"??\"\n        return left.getRtrType().data.name == \"null\" ? right left\n    )\n    \n    return rtr.value.RTRNullValue()\n  )\n)\n\nclass RTR (\n  def init() (\n    self.modules @= {}\n    self.console @= []\n  )\n\n  def addModule(object mod) (\n    local key @= OuidNew()\n    mod.inst @= self\n    self.modules[key] @= mod\n    return key\n  )\n  \n  def startModules() (\n    local mods @= self.modules.getValues()\n    for i mods.len (\n      void mods[i].runEvent(\"onload\", {})\n    )\n  )\n)\n"], [".osl", "ast", "\nclass Parser (\n  def init(string text) (\n    void self.tokenise(text)\n  )\n  \n  def parse() (\n    self.pointer = 1\n    \n    local out @= self.blockContent(true)\n    \n    if !self.atEnd() (\n      throw \"unexpected token\" + self.peek()\n    )\n    \n    return { elements: out }\n  )\n  \n  def peek(amount) (\n    amount ??= 1\n    return self.tokens[self.pointer + amount - 1]\n  )\n  def consume() (\n    local tkn = self.peek()\n    self.pointer ++\n    return tkn\n  )\n  def consumeWhitespace() (\n    while self.peek().match(\"/^\\\\s$/\") != null (\n      void self.consume()\n    )\n  )\n  def atEnd() (\n    return self.pointer >= self.tokens.len\n  )\n  def expect(string token) (\n    local tkn @= self.consume()\n    if tkn != token (\n      throw \"expected '\" ++ token ++ \"' got '\" ++ tkn ++ \"'\"\n    )\n    return tkn\n  )\n  def expects(array tokens) (\n    local tkn @= self.consume()\n    if !tokens.contains(tkn) (\n      throw \"expected '\" ++ tokens.join(\" or \") ++ \"' got '\" ++ tkn ++ \"'\"\n    )\n    return tkn\n  )\n  def expectText() (\n    local tkn @= self.consume()\n    if !tkn.match(\"/^[a-zA-Z_]+$/\") (\n      throw \"identifier must consist of letters or _\"\n    )\n    return tkn\n  )\n  def getPos() (\n    local ln = 1\n    local col = 0\n    local i = self.pointer\n    for t self.pointer (\n      col ++\n      if self.tokens[t] == \"\\n\" (\n        ln ++\n        col = 0\n      )\n    )\n    return { ln, col, i }\n  )\n  \n  def tokenise(string text) (\n    self.tokens @= []\n    local splitChars @= [\n      \"(\",\")\",\n      \"[\",\"]\",\n      \"{\",\"}\",\n      \",\",\";\",\":\",\"=\",\".\",\n      \"+\",\"-\",\"*\",\"/\",\"%\",\"^\",\n      \"\\\\\",\n      \"'\",\"\\\"\",\"`\",\n      \" \",\"\\n\",\n      \"!\",\"?\"\n    ]\n    local buf = \"\"\n    for i text.len (\n      if splitChars.contains(text[i]) (\n        if buf.len > 0 (\n          void self.tokens.append(buf)\n        )\n        void self.tokens.append(text[i])\n        buf = \"\"\n      ) else (\n        buf ++= text[i]\n      )\n    )\n    if buf.len > 0 (\n      self.tokens.append(buf)\n    )\n  )\n  \n  // statements\n  def blockContent(top) (\n    local statements @= []\n    local end = peek() == \"}\"\n    while !end (\n      local out @= top ? self.topLevelStatement() self.statement()\n      if out != null (\n        void statements.append(out)\n      )\n      void self.consumeWhitespace()\n      if self.peek() == \";\" (\n        void self.consume()\n      )\n      if self.peek() == \"}\" or self.atEnd() (\n        end = true\n      )\n    )\n    return statements\n  )\n  \n  def topLevelStatement() (\n    void self.consumeWhitespace()\n    \n    if self.peek() == \"event\" (\n      return self.event()\n    )\n    \n    throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n  )\n  \n  def event() (\n    local start @= self.getPos()\n    void self.expect(\"event\")\n    void self.consumeWhitespace()\n    void self.expect(\"(\")\n    void self.consumeWhitespace()\n    local name @= self.expectText()\n    void self.consumeWhitespace()\n    void self.expect(\")\")\n    void self.consumeWhitespace()\n    local body @= self.block()\n    \n    return {\n      kind: \"event\",\n      name,\n      body,\n      start, end: self.getPos()\n    }\n  )\n  \n  def statement(noSemicolon) (\n    void self.consumeWhitespace()\n    \n    // statements\n    if self.peek() == \"{\" (\n      local start @= self.getPos()\n      local body @= self.block()\n      return {\n        kind: \"block\",\n        body,\n        start, end: self.getPos()\n      }\n    )\n    \n    if self.peek() == \"if\" (\n      local start @= self.getPos()\n      void self.consume()\n      void self.consumeWhitespace()\n      void self.expect(\"(\")\n      local ifCond @= self.expression()\n      void self.expect(\")\")\n      void self.consumeWhitespace()\n      local ifBody @= self.statement()\n      \n      local elifs @= []\n      \n      void self.consumeWhitespace()\n      while self.peek() == \"elif\" (\n        void self.consume()\n        void self.consumeWhitespace()\n        void self.expect(\"(\")\n        local elifCond @= self.expression()\n        void self.expect(\")\")\n        void self.consumeWhitespace()\n        local elifBody @= self.statement()\n        \n        void elifs.append({\n          cond: elifCond,\n          body: elifBody\n        })\n        void self.consumeWhitespace()\n      )\n      \n      local elseBody = null\n      void self.consumeWhitespace()\n      if self.peek() == \"else\" (\n        void self.consume()\n        void self.consumeWhitespace()\n        local elseBody @= self.statement()\n      )\n      \n      return {\n        kind: \"branch\",\n        cond: ifCond,\n        body: ifBody,\n        elifs,\n        elseBody,\n        start, end: self.getPos()\n      }\n    )\n    \n    if [\"while\",\"until\"].contains(self.peek()) (\n      local start @= self.getPos()\n      local kind @= self.consume()\n      void self.consumeWhitespace()\n      void self.expect(\"(\")\n      local cond @= self.expression()\n      void self.expect(\")\")\n      void self.consumeWhitespace()\n      local body @= self.statement()\n      \n      return {\n        kind,\n        cond,\n        body,\n        start, end: self.getPos()\n      }\n    )\n    \n    if self.peek() == \"repeat\" (\n      local start @= self.getPos()\n      void self.consume()\n      void self.consumeWhitespace()\n      void self.expect(\"(\")\n      local amount @= self.expression()\n      void self.expect(\")\")\n      void self.consumeWhitespace()\n      local body @= self.statement()\n      \n      return {\n        kind: \"repeat\",\n        amount,\n        body,\n        start, end: self.getPos()\n      }\n    )\n    \n    if self.peek() == \"for\" (\n      local start @= self.getPos()\n      void self.consume()\n      void self.consumeWhitespace()\n      void self.expect(\"(\")\n      local var @= self.expectText()\n      void self.consumeWhitespace()\n      void self.expect(\",\")\n      void self.consumeWhitespace()\n      local arr @= self.expression()\n      void self.expect(\")\")\n      void self.consumeWhitespace()\n      local body @= self.statement()\n      return {\n        kind: \"for\",\n        var,\n        arr,\n        body,\n        start, end: self.getPos()\n      }\n    )\n    \n    local expr @= self.expression()\n    if expr != null (\n      void self.consumeWhitespace()\n      if !noSemicolon (\n        void self.expect(\";\")\n      )\n      \n      return {\n        kind: \"expression\",\n        expr\n      }\n    ) else (\n      throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n    )\n  )\n  \n  def block() (\n    local start @= self.getPos()\n    void self.expect(\"{\")\n    void self.consumeWhitespace()\n    local elements @= self.blockContent()\n    void self.consumeWhitespace()\n    void self.expect(\"}\")\n    return { elements, start, end: self.getPos() }\n  )\n  \n  // expressions\n  \n  def expression() (\n    return self.declare()\n  )\n  \n  def declare() (\n    if self.peek().match(\"/^[a-zA-Z_]\\\\w*$/\") != null (\n      local start @= self.getPos()\n      local ptr = self.pointer\n      local tar = self.consume()\n      void self.consumeWhitespace()\n      if self.peek() == \":\" and self.peek(2) == \"=\" (\n        void self.consume()\n        void self.consume()\n        void self.consumeWhitespace()\n        \n        local val @= self.expression()\n        \n        return {\n          kind: \"decl\",\n          tar,\n          val,\n          start, end: self.getPos()\n        }\n      )\n      self.pointer = ptr\n    )\n    \n    return self.assignment()\n  )\n  \n  def assignment() (\n    local start @= self.getPos()\n    local expr @= self.equality()\n    void self.consumeWhitespace()\n    \n    local op = null\n    \n    if self.peek() ++ self.peek(2) == \"??\" and self.peek(3) == \"=\" (\n      op = self.peek() ++ self.peek(2)\n    )\n    \n    if self.peek(2) == \"=\" and [\"+\",\"-\",\"*\",\"/\",\"%\",\"^\"].contains(self.peek()) (\n      op = self.peek()\n    )\n    \n    if op != null or self.peek() == \"=\" (\n      if op != null (\n        loop op.len (\n          void self.consume()\n        )\n      )\n      void self.consume()\n      void self.consumeWhitespace()\n      \n      local val @= self.expression()\n      \n      return {\n        kind: \"asi\",\n        op,\n        tar: expr,\n        val,\n        start, end: self.getPos()\n      }\n    )\n    \n    return expr\n  )\n  \n  def equality() (\n    local expr @= self.comparison()\n    void self.consumeWhitespace()\n    \n    while [\"==\",\"!=\"].contains(self.peek() ++ self.peek(2)) (\n      local op @= self.consume() ++ self.consume()\n      local right @= self.comparison()\n      expr @= {\n        kind: \"binary\",\n        op,\n        left: expr,\n        right\n      }\n    )\n    \n    return expr\n  )\n  \n  def comparison() (\n    local expr @= self.term()\n    \n    local end = false\n    while !end (\n      void self.consumeWhitespace()\n      if [\">\",\"<\"].contains(self.peek()) (\n        local op @= self.consume()\n        local isEql = self.peek() == \"=\"\n        if isEql (\n          op ++= self.consume()\n        )\n        \n        local right @= self.factor()\n        \n        expr @= {\n          kind: \"binary\",\n          op,\n          left: expr,\n          right\n        }\n      ) else (\n        end = true\n      )\n    )\n    \n    return expr\n  )\n  \n  def term() (\n    local expr @= self.factor()\n    void self.consumeWhitespace()\n    \n    while [\"+\",\"-\"].contains(self.peek()) and self.peek(2) != \"=\" (\n      local op @= self.consume()\n      local right @= self.factor()\n      expr @= {\n        kind: \"binary\",\n        op,\n        left: expr,\n        right\n      }\n      void self.consumeWhitespace()\n    )\n    \n    return expr\n  )\n  \n  def factor() (\n    local expr @= self.otherBinary()\n    void self.consumeWhitespace()\n    \n    while [\"*\",\"/\"].contains(self.peek()) and self.peek(2) != \"=\" (\n      local op @= self.consume()\n      local right @= self.otherBinary()\n      expr @= {\n        kind: \"binary\",\n        op,\n        left: expr,\n        right\n      }\n      void self.consumeWhitespace()\n    )\n    \n    return expr\n  )\n  \n  def otherBinary() (\n    local expr @= self.coalescence()\n    void self.consumeWhitespace()\n    \n    while [\"%\",\"^\"].contains(self.peek()) and self.peek(2) != \"=\" (\n      local op @= self.consume()\n      local right @= self.coalescence()\n      expr @= {\n        kind: \"binary\",\n        op,\n        left: expr,\n        right\n      }\n      void self.consumeWhitespace()\n    )\n    \n    return expr\n  )\n  \n  def coalescence() (\n    local expr @= self.unary()\n    void self.consumeWhitespace()\n    \n    while self.peek() ++ self.peek(2) == \"??\" and self.peek(3) != \"=\" (\n      local op @= self.consume() ++ self.consume()\n      local right @= self.unary()\n      expr @= {\n        kind: \"binary\",\n        op,\n        left: expr,\n        right\n      }\n      void self.consumeWhitespace()\n    )\n    \n    return expr\n  )\n  \n  def unary() (\n    if self.peek(2) != \"=\" (\n      switch self.peek() (\n        case \"-\"; case \"+\"; case \"!\"; case \"?\"\n          return {\n            kind: \"unary\",\n            type: self.consume(),\n            expr: self.expression()\n          }\n      )\n    )\n    \n    return self.callExpr()\n  )\n  \n  def callExpr() (\n    local start @= self.getPos()\n    local expr @= self.func()\n    \n    if self.peek() == \"(\" (\n      self.consume()\n      \n      local args @= []\n      local end = self.peek() == \")\"\n      while !end (\n        local out @= self.expression()\n        if out != null (\n          void args.append(out)\n        )\n        void self.consumeWhitespace()\n        if self.peek() == \",\" (\n          void self.consume()\n        )\n        void self.consumeWhitespace()\n        if self.peek() == \")\" or self.atEnd() (\n          end = true\n        )\n      )\n      void self.expect(\")\")\n      \n      return {\n        kind: \"call\",\n        args,\n        func: expr,\n        start, end: self.getPos()\n      }\n    )\n    \n    return expr\n  )\n  \n  def func() (\n    local start @= self.getPos()\n    \n    local is = false\n    if self.peek() == \"(\" (\n      local end = false\n      local depth = 0\n      while !end (\n        local tkn @= self.consume()\n        if tkn == \"(\" (\n          depth ++\n        )\n        if tkn == \")\" (\n          depth --\n        )\n        \n        if tkn == \")\" and depth == 0 (\n          end = true\n          is = true\n        )\n        if self.atEnd() (\n          end = true\n        )\n      )\n    )\n    void self.consumeWhitespace()\n    if is and self.peek() == \"~\" (\n      self.pointer = start.i\n      \n      local args @= []\n      void self.consume()\n      void self.consumeWhitespace()\n      local end = self.peek() == \")\"\n      if self.peek() == \")\" (\n        void self.consume()\n      )\n      while !end (\n        local tkn @= self.expectText()\n        void args.append({\n          name: tkn\n        })\n        \n        void self.consumeWhitespace()\n        local ntkn = self.expects([\",\",\")\"])\n        void self.consumeWhitespace()\n        if ntkn == \")\" or self.atEnd() (\n          end = true\n        )\n      )\n      void self.consumeWhitespace()\n      void self.expect(\"~\")\n      void self.consumeWhitespace()\n      local body @= self.statement(true)\n      return {\n        kind: \"func\",\n        args,\n        body,\n        start, end: self.getPos()\n      }\n    )\n    self.pointer = start.i\n    \n    return self.objProperty()\n  )\n  \n  def objProperty() (\n    local expr @= self.primary()\n    void self.consumeWhitespace()\n    \n    while (self.peek() == \"[\" or self.peek() == \".\") and !self.atEnd() (\n      if self.peek() == \"[\" (\n        void self.consume()\n        local key @= self.expression()\n        void self.expect(\"]\")\n      ) else if self.peek() == \".\" (\n        void self.consume()\n        local key @= self.expectText()\n      ) else (\n        throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n      )\n      expr @= {\n        kind: \"prop\",\n        obj: expr,\n        key\n      }\n      void self.consumeWhitespace()\n    )\n    \n    return expr\n  )\n  \n  def primary() (\n    void self.consumeWhitespace()\n    \n    if self.peek() == \"(\" (\n      void self.consume()\n      local expr @= self.expression()\n      void self.expect(\")\")\n      return expr\n    )\n    \n    if self.peek() == \"[\" (\n      return self.arr()\n    )\n    \n    if self.peek() == \"{\" (\n      return self.obj()\n    )\n    \n    if [\"'\",\"\\\"\",\"`\"].contains(self.peek()) (\n      return self.str()\n    )\n    \n    if self.peek().match(\"/^[0-9]+$/\") != null (\n      return self.num()\n    )\n    \n    if self.peek().match(\"/^[a-zA-Z_]\\\\w*$/\") != null (\n      local start @= self.getPos()\n      return {\n        kind: \"var\",\n        name: self.consume(),\n        start, end: self.getPos()\n      }\n    )\n    \n    throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n  )\n  \n  def obj() (\n    void self.expect(\"{\")\n    void self.consumeWhitespace()\n    \n    local pairs @= []\n    \n    local end = self.peek() == \"}\"\n    while !end (\n      void self.consumeWhitespace()\n      local name @= self.expectText()\n      void self.consumeWhitespace()\n      void self.expect(\":\")\n      void self.consumeWhitespace()\n      local value @= self.expression()\n      \n      void pairs.append({ name, value })\n      \n      void self.consumeWhitespace()\n      if self.peek() == \"}\" (\n        end = true\n      ) else (\n        void self.expect(\",\")\n      )\n    )\n    void self.expect(\"}\")\n    \n    return {\n      kind: \"obj\",\n      pairs\n    }\n  )\n  \n  def arr() (\n    void self.expect(\"[\")\n    \n    local elems @= []\n    \n    local end = self.peek() == \"]\"\n    while !end (\n      local expr @= self.expression()\n      void elems.append(expr)\n      \n      void self.consumeWhitespace()\n      if self.peek() == \"]\" or self.atEnd() (\n        end = true\n      ) else (\n        void self.expect(\",\")\n      )\n      void self.consumeWhitespace()\n    )\n    \n    void self.expect(\"]\")\n    \n    return {\n      kind: \"arr\",\n      elems\n    }\n  )\n  \n  def str() (\n    local start @= self.getPos()\n    local q @= self.expects([\"'\",\"\\\"\",\"`\"])\n    local content = \"\"\n    local end = false\n    while (!end) (\n      local tkn @= self.peek()\n      if tkn == \"\\\\\" (\n        void self.consume()\n        local tkn = self.consume()\n        local char = tkn[1]\n        switch char (\n          case \"n\"\n            char = \"\\n\"\n            break\n        )\n        content ++= char ++ tkn.trim(2,-1)\n        continue\n      )\n      \n      if q == tkn (\n        end = true\n      ) else (\n        content ++= self.consume()\n      )\n      if self.atEnd() (\n        end = true\n      )\n    )\n    void self.expect(q)\n    return {\n      kind: \"str\",\n      val: content,\n      start, end: self.getPos()\n    }\n  )\n  \n  def num() (\n    if self.peek().match(\"/^[0-9]+$/\") == null (\n      throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n    )\n    \n    local start @= self.getPos()\n    local val @= self.consume()\n    \n    if self.peek() == \".\" (\n      val ++= self.consume()\n      if self.peek().match(\"/^[0-9]+$/\") == null (\n        throw \"unexpected token '\" ++ self.peek() ++ \"'\"\n      )\n      val ++= self.consume()\n    )\n    \n    val @= val.toNum()\n    \n    return {\n      kind: \"num\",\n      val,\n      start, end: self.getPos()\n    }\n  )\n)\n"], [".osl", "error", "\nobject Editors = {\n\n}\n\nclass Error (\n  boolean isError = true\n  \n  def init(string type, object data) (\n    self.type = type\n    self.data @= data\n    \n    local err @= rwl.error.Errors[type]\n    if err == null (\n      self.txt = \"unknown error type\" + type\n      return\n    )\n    self.txt = err(data)\n  )\n  \n  def stringify() (\n    return \"Error<\" ++ self.type ++ \">:\\n\" ++ self.txt.split(\"\\n\").map(l -> \"    \" ++ l).join(\"\\n\")\n  )\n)\n"], [".osl", "value", "\nclass RTRValue (\n  boolean isReturnVal = false\n  def callFunc() (\n    throw \"cannot call\" + self.stringify(true) + \"as function\"\n  )\n\n  def getRtrType() (\n    throw self.name + \"has not implemented getRtrType()\"\n    return rtr.value.RTRTypeValue({\n      name: \"?\"\n    })\n  )\n\n  def stringify() (\n    return \"<\" ++ self.getRtrType().getName() ++ \">\"\n  )\n  def numbify() (\n    return NaN\n  )\n  def boolify() (\n    return true\n  )\n  def arrify() (\n    return []\n  )\n  def length() (\n    return 0\n  )\n  def getItem(key) (\n    return null\n  )\n  def setItem(key, value) (\n    throw \"cannot set items on\" + self.stringify(true)\n  )\n  def keys() (\n    return []\n  )\n  def values() (\n    return []\n  )\n  def has(key) (\n    return false\n  )\n  def isEqual(other) (\n    return self.getRtrType().isEqual(other.getRtrType())\n  )\n)\n\nclass RTRTypeValue (\n  def init(object data) (\n    self.data @= data\n  )\n  \n  def stringify() (\n    return self.getName()\n  )\n  def getName() (\n    if self.data.name != null (\n      return self.data.name\n    )\n    return \"?\"\n  )\n  def isEqual(object other) (\n    return self.data.name == other.data.name\n  )\n)\n\nclass RTRLiteralValue extends RTRValue (\n  boolean isLiteral = true\n)\n\nclass RTRStrValue extends RTRLiteralValue (\n  def init(string value) (\n    self.value @= value\n  )\n  \n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"str\"\n    })\n  )\n  \n  def stringify(format) (\n    return format ? self.value.JsonStringify() self.value\n  )\n  def numbify() (\n    return self.value.toNum()\n  )\n  def boolify() (\n    return self.value.len > 0\n  )\n  def arrify() (\n    return self.value.split(\"\").map(e -> rtr.value.RTRStrValue(e))\n  )\n  def length() (\n    return self.value.len\n  )\n  def getItem(index) (\n    return rtr.value.RTRStrValue(self.value[index.numbify() + 1])\n  )\n  def isEqual(other) (\n    return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n  )\n)\n\nclass RTRNumValue extends RTRLiteralValue (\n  def init(number value) (\n    self.value @= value\n  )\n  \n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"num\"\n    })\n  )\n  \n  def stringify() (\n    return self.value.toStr()\n  )\n  def numbify() (\n    return self.value\n  )\n  def boolify() (\n    return self.value > 0\n  )\n  def arrify() (\n    return self.value.toStr().split(\"\").map(e -> rtr.value.RTRStrValue(e))\n  )\n  def length() (\n    return self.value.toStr().length\n  )\n  def getItem(index) (\n    return self.value.toStr()[index.numbify() + 1]\n  )\n  def isEqual(other) (\n    return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n  )\n)\n\nclass RTRBoolValue extends RTRLiteralValue (\n  def init(boolean value) (\n    self.value @= value\n  )\n  \n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"bool\"\n    })\n  )\n  \n  def stringify() (\n    return self.value.toStr()\n  )\n  def numbify() (\n    return self.value.toNum()\n  )\n  def boolify() (\n    return self.value\n  )\n  def isEqual(other) (\n    return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n  )\n)\n\nclass RTRFuncValue extends RTRValue (\n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"func\"\n    })\n  )\n)\n\nclass RTROslFuncValue extends RTRFuncValue (\n  def init(func) (\n    self.func @= func\n  )\n  \n  def callFunc(object inst, array args) (\n    return self.func(args, inst) ?? rtr.value.RTRNullValue()\n  )\n)\n\nclass RTRAstFuncValue extends RTRFuncValue (\n  def init(array args, object body) (\n    self.args @= args\n    self.body @= body\n  )\n  \n  def callFunc(object inst, array args) (\n    local s @= {}\n    for i self.args.len (\n      local a @= self.args[i]\n      local v @= args[i] ?? rtr.value.RTRNullValue()\n      s[a.name] @= [v, {}]\n    )\n    \n    void inst.newScope(s)\n    void inst.declScopeVar(\"@return\", 0)\n    \n    local exprOut @= inst.runStatement(self.body)\n    \n    local ret @= inst.getScopeVar(\"@return\") ?? 0\n    if ret == 0 (\n      ret @= exprOut\n    )\n    \n    void inst.popScope()\n    \n    return ret\n  )\n)\n\nclass RTRNullValue extends RTRValue (\n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"null\"\n    })\n  )\n  \n  def boolify() (\n    return false\n  )\n  def isEqual(other) (\n    return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value\n  )\n)\n\nclass RTRArrValue extends RTRValue (\n  def init(array elements) (\n    self.elements @= elements\n  )\n  \n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"arr\"\n    })\n  )\n  \n  def stringify() (\n    local el @= self.elements.map(e -> e.stringify(true))\n    return \"[\" ++ el.join(\", \") ++ \"]\"\n  )\n  def boolify() (\n    return self.elements.len > 0\n  )\n  def arrify() (\n    return self.elements\n  )\n  def length() (\n    return self.elements.len\n  )\n  def keys() (\n    local arr2 @= []\n    for i self.elements.len (\n      void arr2.append(i - 1)\n    )\n    return arr2\n  )\n  def values() (\n    return self.elements\n  )\n  def getItem(index) (\n    return self.elements[index.numbify() + 1]\n  )\n)\n\nclass RTRObjValue extends RTRValue (\n  def init(object value) (\n    self.value @= value\n  )\n  \n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"obj\"\n    })\n  )\n  \n  def stringify() (\n    local el @= self.value.getEntries().map(e -> e[1] ++ \":\" + e[2].stringify(true))\n    return \"{\" ++ el.join(\", \") ++ \"}\"\n  )\n  def boolify() (\n    return self.value.getKeys().len > 0\n  )\n  def arrify() (\n    return self.value.getKeys().map(e -> rtr.value.RTRStrValue(e))\n  )\n  def length() (\n    return self.value.getKeys().len\n  )\n  def keys() (\n    return self.value.getKeys()\n  )\n  def values() (\n    return self.value.getValues()\n  )\n  def has(key) (\n    return self.value.getKeys().contains(key)\n  )\n  def getItem(key) (\n    return self.value[key.stringify()]\n  )\n  def setItem(key, value) (\n    self.value[key.stringify()] @= value\n  )\n)\n"], [".osl", "rwl", "\nclass RTRDocument extends rtr.value.RTRValue (\n  def init(object doc) (\n    self.doc @= doc\n  )\n\n  def getRtrType() (\n    return rtr.value.RTRTypeValue({\n      name: \"document\"\n    })\n  )\n  \n  def setItem(key, value) (\n    switch key.stringify() (\n      case \"title\"\n        self.doc.title = value.stringify()\n        break\n      case \"icon\"\n        self.doc.icon = value.stringify()\n        break\n      default\n        throw \"unknown property\" + key.stringify() + \"on document\"\n    )\n  )\n)\n\n// applies all rwl related apis to rtr\ndef addToInst(object doc, object rtrInst) (\n  local mods @= rtrInst.modules.getValues()\n  for i mods.len (\n    addToMod(doc, mods[i])\n  )\n)\n\ndef addToMod(object doc, object mod) (\n  void mod.declScopeVar(\"document\", RTRDocument(doc))\n)\n"]]], [".folder", "shared", [[".osl", "graphics", "\nusesCanvas = false\n\n_canvasID = null\n_canvas = null\n\ndef init() (\n  if self.usesCanvas (\n    self._canvasID = OuidNew()\n    self._canvas @= shared.canvas.createCanvas(self._canvasID, window.width, window.height)\n    log self\n  )\n)\n\n// cursor\ncursor_x = 0\ncursor_y = 0\ndef goto(number x, number y) (\n  self.cursor_x = x\n  self.cursor_y = y\n)\n\ndef change_x(number x) (\n  self.cursor_x += x\n)\ndef change_y(number y) (\n  self.cursor_y += y\n)\ndef change(number x, number y) (\n  self.cursor_x += x\n  self.cursor_y += y\n)\n\n// utils\ndef getTextWidth(string text) (\n  return text.len\n)\n\n// rendering\ndef box(array area, string color) (\n  c color\n  pen \"size\" 1\n  goto area[1] area[2]\n  pen \"down\"\n  goto area[3] area[2]\n  goto area[3] area[4]\n  goto area[1] area[4]\n  goto area[1] area[2]\n  pen \"up\"\n)\n\ndef filledBox(array area, rounding, string color) (\n  local x = rwl.area.centerX(area)\n  local y = rwl.area.centerY(area)\n  local w = rwl.area.width(area)\n  local h = rwl.area.height(area)\n  \n  c color\n  \n  if typeof(rounding) == \"number\" (\n    goto x y\n    square w - (rounding * 2) h - (rounding * 2) (rounding * 2)\n  ) else if typeof(rounding) == \"array\" (\n    // could rework this to have it be corner - rounding for pos\n    // so it would have higher parity with canvas?\n    goto x y\n    frame area[1] y x area[2] (\n      local r = min(rounding[1] * 2, min(w, h) / 2)\n      square w - r h - r r\n    )\n    frame x y area[3] area[2] (\n      local r = min(rounding[2] * 2, min(w, h) / 2)\n      square w - r h - r r\n    )\n    frame area[1] area[4] x y (\n      local r = min(rounding[3] * 2, min(w, h) / 2)\n      square w - r h - r r\n    )\n    frame x area[4] area[3] y (\n      local r = min(rounding[4] * 2, min(w, h) / 2)\n      square w - r h - r r\n    )\n  )\n)\n\ndef ctext(string text, number size, string color) (\n  void ptext(text, self.cursor_x, self.cursor_y, size, color)\n)\ndef ptext(string text, number x, number y, number size, string color) (\n  goto x y\n  text text size : c#color\n)\n"], [".osl", "utils", "\ndef removeIndents(str) (\n  local lines @= str.split(\"\\n\")\n  local indent = null\n  for i lines.len (\n    local l2 = lines[i].match(\"/^( *)(.+)$/\")\n    if l2[2].len > 0 (\n      indent = min(indent ?? 9999, l2[2].len)\n    )\n  )\n  for i lines.len (\n    lines[i] = lines[i].trim(indent + 1, -1)\n  )\n  return lines.join(\"\\n\")\n)\n\ndef jsFunc(string js) (\n  local f @= js.eval()\n  local f2 @= () -> ()\n  f2.code @= f\n  return f2\n)\n"], [".osl", "document", "\nclass Document (\n  def init() (\n    void self.createInsts()\n    \n    void self.createWorker()\n  )\n  \n  def close() (\n    void self.killWorker()\n  )\n  \n  def createWorker() (\n    //log \"create worker\"\n    void killWorker()\n    self.worker @= worker(shared.tab_worker)\n    self.worker.document @= self\n  )\n  \n  def killWorker() (\n    if self.worker != null (\n      //log \"kill worker\"\n      void self.worker.kill()\n      self.worker = null\n    )\n  )\n  \n  def createInsts() (\n    self.title = \"New Tab\"\n    if self.url != null (\n      self.title = self.url.getTitle()\n    )\n    self.icon = null\n    \n    self.rtrInst @= rtr.main.RTR()\n    self.rwlInst @= rwl.main.RWL(shared.document.empty, self.rtrInst)\n  )\n  \n  def updateInsts() (\n    // inject rwl apis\n    void rtr.rwl.addToInst(self, self.rtrInst)\n    \n    // start onloads\n    void self.rtrInst.startModules()\n  )\n  \n  def update(array area) (\n    void self.rwlInst.update(area)\n  )\n  \n  def render(array area) (\n    if self.worker != null (\n      self.worker.area @= area\n      if !self.worker.alive (\n        self.rwlInst.errored = true\n        self.rwlInst.errormsg = \"tab worker died, check code for syntax errors\\nyou can also check js console\"\n      )\n    )\n    \n    goto rwl.area.centerX(area) rwl.area.centerY(area)\n    square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n    \n    if self.loading (\n      goto rwl.area.centerX(area) rwl.area.centerY(area)\n      direction timer * 720\n      icon \"sync\" .75 : c#shared.theme.text\n      direction 90\n      return\n    )\n    \n    //log self.rwlInst\n    void self.rwlInst.render(area)\n  )\n  \n  def checkResp() (\n    if self.resp == null (\n      self.loading = false\n      return\n    )\n    \n    if self.resp.isFinished (\n      if self.resp.isValid (\n        self.loading = false\n        \n        void self.createInsts()\n        void self.loadText(self.resp.content)\n        \n        self.resp = null\n      )\n    ) else (\n      self.loading = true\n      void self.resp.update()\n    )\n  )\n  \n  def loadAst(object ast) (\n    void self.createInsts()\n    void self.rwlInst.loadFromAst(ast)\n    void self.updateInsts()\n  )\n  \n  def loadText(string text) (\n    void self.createWorker()\n    self.worker.parseText = text\n  )\n  \n  def loadUrl(object url) (\n    self.url @= url\n    void self.createInsts()\n    self.resp @= net.fetch.url(url)\n  )\n  \n  def getIcon() (\n    return self.icon\n  )\n  def getTitle() (\n    return self.title\n  )\n)\n\ndef init() (\n  local parser @= rwl.ast.Parser(import(\"./src/assets/empty.rwl\"))\n  self.empty @= parser.parse()\n)\n"], [".osl", "tab", "\nclass Tab (\n  def init(object document) (\n    self.document @= document\n  )\n  \n  def redirect(object url) (\n    void self.document.loadUrl(url)\n  )\n)\n"], [".osl", "url", "\nclass Url (\n  def init(string text) (\n    void self.parse(text)\n  )\n  \n  def parse(string text) (\n    self.text = text\n    local s @= text.match(\"/^((\\\\w+):\\\\/\\\\/)/\")\n    local match @= text.match(\"/^((\\\\w+):\\\\/\\\\/)?(((\\\\w+)\\\\.)?(\\\\w+)(\\\\.(\\\\w+))?\\\\/?(([\\\\/w]+)?(\\\\/(\\\\w+\\\\.\\\\w+))?))\\\\/?/\")\n    \n    self.scheme = match[3] ?? s[3] ?? shared.config.url.defaults.scheme\n    \n    if self.scheme == \"local\" (\n      self.domain_name = text.trim(\"local://\".len + 1, -1)\n      local usrPath = \"origin/(c) users/\" ++ username\n      if self.domain_name.toLower().startsWith(usrPath.toLower()) (\n        self.domain_name = \"~\" ++ self.domain_name.trim(usrPath.len + 1, -1)\n      )\n      self.domain_top = null\n      self.domain_sub = null\n      self.path = null\n      self.params @= {}\n      self.resource = null\n      self.text = \"local://\" ++ self.domain_name\n      return\n    )\n    \n    if match[9] != null (\n      local domain_name = match[7]\n      local domain_top = match[9]\n      local domain_sub = match[6]\n    ) else (\n      if match[6] != null (\n        local domain_name = match[6]\n        local domain_top = match[7]\n        local domain_sub = null\n      ) else (\n        local domain_name = match[7]\n        local domain_top = null\n        local domain_sub = null\n      )\n    )\n    \n    self.domain_name = domain_name ?? shared.config.url.defaults.name\n    self.domain_top = domain_top ?? shared.config.url.defaults.top\n    self.domain_sub = domain_sub\n    self.path = match[13]\n    self.params @= {}\n    self.resource = match[10] ?? \"index.rwl\"\n  )\n  \n  def format() (\n    local sub = self.domain_sub != null ? self.domain_sub ++ \".\" \"\"\n    local top = self.domain_top != null ? \".\" ++ self.domain_top \"\"\n    local txt = self.scheme ++ \"://\" ++ sub ++ domain_name ++ top\n    if self.path != null (\n      txt ++= \"/\" ++ self.path\n    )\n    if self.file_name != \"index.osl\" (\n      txt ++= \"/\" ++ self.file_name\n    )\n    return txt\n  )\n  \n  def getTitle() (\n    if self.scheme == \"local\" (\n      return self.domain_name.split(\"/\")[-1].split(\".\")[1]\n    )\n    return self.domain_name\n  )\n)\n"], [".osl", "theme", "\ndef load() (\n  self.back = user.theme.background\n  self.prim = user.theme.primary\n  self.seco = user.theme.secondary\n  self.tert = user.theme.tertiary\n  self.text = user.theme.text\n)\n\nload()\n"], [".osl", "config", "\nclass net (\n  servers = {\n    //rtr: {\n    //  url: \"http://localhost:3000/\",\n    //  \n    //  // <server>/<command>\n    //  commands: {\n    //    tlds: \"tlds\"\n    //  }\n    //}\n  }\n  \n  def refresh() (\n    for i self.servers.len (\n      local s @= self.servers.getValues()[i]\n      s.tlds @= (s.url ++ s.commands.tlds).httpGet()\n    )\n  )\n)\n\nnet.refresh()\n\nclass url (\n  class defaults (\n    scheme = \"rtr\"\n    name = \"unknown\"\n    top = \"web\"\n  )\n)\n"], [".osl", "url-old", "\n  def parse(string text) (\n    local scheme = shared.config.url.defaults.scheme\n    local name = shared.config.url.defaults.name\n    local top = shared.config.url.defaults.top\n    local sub = null\n    local path = null\n    local resource = \"index.rwl\"\n    \n    local tokens = text.split(\"://\")\n    if tokens.len > 1 (\n      scheme = tokens.shift()\n      text = tokens.join(\"://\")\n    )\n    \n    if scheme == \"local\" (\n      self.scheme = scheme\n      self.domain_name = text\n      self.domain_top = null\n      self.domain_sub = null\n      self.path = null\n      self.params @= {}\n      self.resource = null\n      return\n    )\n    \n    tokens = text.split(\"/\")\n    if tokens.len == 0 (\n      tokens @= [text]\n    )\n    if tokens[-1].split(\".\").len > 1 (\n      resource = tokens.pop()\n    )\n    path = tokens.join(\"/\")\n    \n    text = tokens.shift() ?? \"\"\n    \n    tokens = text.split(\".\")\n    if tokens.len == 1 (\n      name = tokens[1]\n    )\n    if tokens.len == 2 (\n      top = tokens[2]\n      name = tokens[1]\n    )\n    if tokens.len >= 2 (\n      top = tokens.pop()\n      name = tokens.pop()\n      sub = tokens.join(\".\")\n    )\n    \n    self.scheme = scheme\n    self.domain_name = name\n    self.domain_top = top\n    self.domain_sub = sub\n    self.path = path\n    self.params @= {}\n    self.resource = resource\n  )"], [".osl", "tab_worker", "\ndef oncreate() (\n  \n)\n\ndef onframe() (\n  if self.parseText != null (\n    local parser @= rwl.ast.Parser(self.parseText)\n    if self != null (\n      //log self\n      void self.document.loadAst(parser.parse())\n      self.parseText = null\n    )\n  )\n)\n"]]], [".folder", "layouts", [[".folder", "shared", [[".osl", "utils", "\ndef getContentArea() (\n  return [\n    window.left,\n    window.bottom,\n    window.right,\n    window.top - 50\n  ]\n)\n"], [".osl", "topbar", "\narray defaultButtons = [\n  {\n    icon: \"close\",\n    click: window.close\n  },\n  {\n    icon: \"down\",\n    click: window.minimise\n  },\n  {\n    icon: \"maximise\",\n    click: window.fullscreen\n  }\n]\n\ndef winButtons(array buttons, boolean background) (\n  if background (\n    local w = buttons.len * 25\n    \n    loc -2 2 w / -2 - 7.5 -20\n    square w - 5 18 10 : c#shared.theme.prim\n  )\n  \n  loc -2 2 -20 -20\n  change_x 25\n  for i buttons.len (\n    local button @= buttons[i]\n    \n    c shared.theme.text\n    icon button.icon 0.6 * (button.icon_size ?? 1) : hover_size#1.1 chx#-25\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        void button.click()\n      )\n    )\n  )\n)\n"], [".osl", "state", "\ndebug = false\n\ndef init() (\n  void self.updateTab()\n  void self.selectTab(1)\n  \n  self.tabs @= []\n)\n\ndef resetDragbox() (\n  self.dragbox @= [[2,2,0,0],[-2,2,-90,-40]]\n)\n\ndef applyDragbox() (\n  window.setDragbox(self.dragbox[1], self.dragbox[2])\n  \n  if self.debug (\n    c #fff\n    loc self.dragbox[1][1] self.dragbox[1][2] self.dragbox[1][3] self.dragbox[1][4]\n    pen \"down\"\n    loc self.dragbox[2][1] self.dragbox[2][2] self.dragbox[2][3] self.dragbox[2][4]\n    pen \"up\"\n  )\n)\n\ndef openTabDocument(object document) (\n  local tab @= shared.tab.Tab(document)\n  void self.tabs.append(tab)\n  void self.selectTab(self.tabs.len)\n)\n\ndef openEmptyTab() (\n  void self.openTabDocument(shared.document.Document())\n)\n\ndef closeTab(number index) (\n  void self.tabs[index].document.close()\n  void self.tabs.delete(index)\n  \n  if index < self.currentTab (\n    self.currentTab --\n  )\n  \n  void self.selectTab(self.currentTab)\n)\n\ndef selectTab(number index) (\n  self.currentTab @= index\n  void self.updateTab()\n  inputs[layouts.shared.urlbar.inputId] = self.currentDocument.url.text\n)\n\ndef updateTab() (\n  self.currentDocument @= self.tabs[self.currentTab].document\n  //self.currentDocument ??= shared.document.Document()\n)\n"], [".osl", "urlbar", "\ninputId = \"browser_url\"\n\ndef update(array area) (\n  local defaultText = \"blehh\"\n  \n  goto rwl.area.centerX(area) rwl.area.centerY(area) + 2.5\n  \n  local w = rwl.area.width(area) - 15\n  local h = rwl.area.height(area) - 0\n  \n  square w - 5 h - 18 15 : c#shared.theme.prim\n  input w h - 5 self.inputId defaultText 0 shared.theme.text\n  \n  if inputs.selected.id == self.inputId (\n    if \"enter\".onKeyDown() (\n      void self.goto()\n    )\n  )\n  \n  //void shared.graphics.box(area, #f00)\n)\n\ndef goto() (\n  local url = inputs[self.inputId]\n  \n  url @= shared.url.Url(url)\n  \n  local tab @= layouts.shared.state.tabs[layouts.shared.state.currentTab]\n  void tab.redirect(url)\n)\n"], [".osl", "view", "\ndef render(array area) (\n  local devtoolsData @= devtools.main ?? { width: 0, anchor: \"l\" }\n  \n  local devtoolsArea @= rwl.area.copy(area)\n  local contentArea @= rwl.area.copy(area)\n  switch devtoolsData.anchor (\n    case \"l\"\n      contentArea[1] += devtoolsData.width\n      devtoolsArea[3] = contentArea[1]\n      break\n    case \"r\"\n      contentArea[3] -= devtoolsData.width\n      devtoolsArea[1] = contentArea[3]\n      break\n  )\n  \n  devtoolsArea[1] += 5\n  \n  if layouts.shared.state.currentDocument != null (\n    void layouts.shared.state.currentDocument.checkResp()\n    void layouts.shared.state.currentDocument.render(contentArea)\n  )\n  \n  if typeof(devtools) == \"object\" (\n    void devtools.main.update(devtoolsArea, area)\n  )\n)\n"]]], [".folder", "chromeLike", [[".osl", "main", "\ndef init() (\n  void shared.document.init()\n  void layouts.shared.state.init()\n)\n\ndef update() (\n  void shared.theme.load()\n\n  window.show()\n  window_colour = shared.theme.back\n  \n  void layouts.shared.state.resetDragbox()\n\n  local btns @= layouts.shared.topbar.defaultButtons\n  void layouts.shared.topbar.winButtons(btns, false)\n  \n  void layouts.chromeLike.topbar.tabs()\n  \n  void layouts.shared.urlbar.update([\n    window.left,\n    window.top - 45 - 30,\n    window.right,\n    window.top - 44\n  ])\n  \n  void layouts.shared.view.render([\n    window.left,\n    window.bottom,\n    window.right,\n    window.top - 45 - 32.5\n  ])\n  \n  void layouts.shared.state.applyDragbox()\n)\n"], [".osl", "topbar", "\ndef tabs() (\n  local space = window.width - 100 - 17.5 - 15\n  \n  local hovered = false\n  \n  local x = 0\n  local tabMax = space / layouts.shared.state.tabs.len - 5\n  for i layouts.shared.state.tabs.len (\n    local tab @= layouts.shared.state.tabs[i]\n    \n    local title = tab.document.getTitle()\n    local icon = tab.document.getIcon()\n    \n    local pad = 15 + 27.5\n    if icon != null (\n      pad += 20\n    )\n    //local width = title.len * 9 + pad\n    local width = 200\n    //width = max(width, 200)\n    width = min(width, tabMax)\n    \n    local lx = x\n    x += 2.5 + (width / 2)\n    \n    loc 2 2 x + (width / 2) - 17.5 -20\n    square 15 15 0 0 1\n    local close_touching = mouse_touching\n    \n    loc 2 2 x -20\n    \n    square width - 17.5 17.5 15 0 1\n    c mouse_touching ? shared.theme.seco shared.theme.prim\n    if layouts.shared.state.currentTab == i (\n      c shared.theme.tert\n    )\n    square width - 17.5 17.5 15\n    \n    if mouse_touching and !close_touching (\n      layouts.shared.state.dragbox @= [\n        [2, 2, lx, 0],\n        [2, 2, lx + width, -20]\n      ]\n      hovered = true\n      \n      cursor \"pointer\"\n      if onclick (\n        void layouts.shared.state.selectTab(i)\n      )\n    )\n    \n    square width - 17.5 17.5 10 : c#shared.theme.prim\n    \n    if icon != null (\n      lx += 20\n      loc 2 2 lx -20\n      icon icon .9 : c#user.theme.text\n      lx += 5\n    )\n    lx += 10\n    \n    loc 2 2 lx -20\n    text title.trimText(width - pad / 9) 9 : c#shared.theme.text tooltip#title\n    \n    lx += 5\n    loc 2 2 x + (width / 2) - 17.5 -20\n    square 15 15 0 0 1\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        void layouts.shared.state.closeTab(i)\n        i --\n      )\n    )\n    icon \"close\" .5\n    \n    x += 2.5 + (width / 2)\n  )\n  \n  x += 17.5\n  loc 2 2 x -20\n  square 17.5 17.5 15 : c#shared.theme.prim hover_c#shared.theme.seco\n  if mouse_touching (\n    cursor \"pointer\"\n    if onclick (\n      void layouts.shared.state.openEmptyTab()\n    )\n  )\n  icon \"add\" .6 : c#user.theme.text\n  x += 20\n  \n  loc -2 2 -90 -20\n  line 0 -20 0 20 : c#shared.theme.prim w#1\n  \n  if !hovered (\n    layouts.shared.state.dragbox[1][3] += x\n  )\n)\n"]]], [".folder", "summit", [[".osl", "main", "\ndef init() (\n  void shared.document.init()\n  void layouts.shared.state.init()\n)\n\ndef update() (\n  void shared.theme.load()\n  \n  window.show()\n  window_colour = #000\n  \n  glass:frame window.left window.top window.right window.bottom; frame \"clear\"\n  \n  void layouts.shared.state.resetDragbox()\n  \n  layouts.shared.state.dragbox[1][3] = max(layouts.summit.sidebar.width, 30)\n  \n  void layouts.summit.sidebar.update([\n    window.left + layouts.summit.sidebar.width - layouts.summit.sidebar.open_width,\n    window.bottom,\n    window.left + layouts.summit.sidebar.width,\n    window.top\n  ])\n  \n  void layouts.summit.topbar.update([\n    window.left + layouts.summit.sidebar.width,\n    window.top - 37.5,\n    window.right - 5,\n    window.top - 5\n  ])\n  \n  void layouts.shared.view.render([\n    window.left + layouts.summit.sidebar.width,\n    window.bottom + 5,\n    window.right - 5,\n    window.top - 42.5\n  ])\n  \n  void layouts.shared.state.applyDragbox()\n)\n"], [".osl", "sidebar", "\nopen_width = 250\n\nwidth = 200\ntar_width = open_width\nopen = true\n\ndef update(array area) (\n  goto rwl.area.centerX(area) rwl.area.centerY(area)\n  square rwl.area.width(area) - 20 rwl.area.height(area) - 20 10 : c#shared.theme.back\n  \n  frame area[1] + 10 area[4] - 10 area[3] - 10 area[4] - 35 (\n    //square 1000 1000 1000 : c#fff\n    goto frame.right - 12.5 0\n    square 20 20 0 0 1 : c#fff\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        self.open = false\n      )\n    )\n    goto frame.right - 12.5 0\n    icon \"left\" .6 : c#shared.theme.text\n    \n    goto frame.left + 12.5 0\n    square 20 20 0 0 1 : c#fff\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        void layouts.shared.state.openEmptyTab()\n      )\n    )\n    icon \"add\" .6 : c#shared.theme.text\n  )\n  \n  void layouts.shared.urlbar.update([\n    area[1] + 10,\n    area[4] - 40 - 32.5,\n    area[3] - 10,\n    area[4] - 40 - 2.5\n  ])\n  \n  local height = 1000\n  c shared.theme.prim\n  frame area[1] + 5 area[4] - 40 - 35 area[3] - 5 area[2] + 5 height \"browser_sidebar\" (\n    local y = frame.top + frame.scroll\n    \n    for i layouts.shared.state.tabs.len (\n      local tab @= layouts.shared.state.tabs[i]\n      \n      local title = tab.document.getTitle()\n      local icon = tab.document.getIcon()\n      y -= 20\n      \n      local close_touching = false\n      \n      goto frame.right - 22.5 y\n      square 15 15 0 0 1\n      local close_touching = mouse_touching\n      \n      goto 0 y\n      c layouts.shared.state.currentTab == i ? shared.theme.seco shared.theme.prim\n      square frame.width - 25 20 15 : hover_c#shared.theme.tert\n      if mouse_touching and !close_touching (\n        cursor \"pointer\"\n        if onclick (\n          void layouts.shared.state.selectTab(i)\n        )\n      )\n      square frame.width - 25 20 10 : c#shared.theme.back\n      \n      goto frame.left + 15 y\n      if icon != null (\n        icon icon .9 : c#user.theme.text chx#7.5\n        change_x 15\n      )\n      text title.trimText(frame.right - x_position / 9 - 4) 9 : c#shared.theme.text tooltip#title\n      \n      goto frame.right - 22.5 y\n      square 15 15 0 0 1\n      if mouse_touching (\n        cursor \"pointer\"\n        if onclick (\n          void layouts.shared.state.closeTab(i)\n          i --\n        )\n      )\n      icon \"close\" .5\n      \n      y -= 20\n    )\n  )\n  \n  // clicking on the left side of the window opens the sidebar\n  if self.width < 25 (\n    goto window.left 0\n    square 20 window.height 0 0 1\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        self.open = true\n      )\n    )\n  )\n  \n  self.tar_width = self.open ? self.open_width 5\n  self.width += self.tar_width - self.width * min(delta_time, 0.02) * 10\n)\n"], [".osl", "topbar", "\ndef update(array area) (\n  goto rwl.area.centerX(area) rwl.area.centerY(area)\n  square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n  \n  local btns @= layouts.shared.topbar.defaultButtons\n  void layouts.shared.topbar.winButtons(btns, false)\n  \n  local titlebarX = max(area[1], window.left + 30)\n  goto titlebarX + 10 rwl.area.centerY(area)\n  if layouts.shared.state.currentDocument != null (\n    local icn = layouts.shared.state.currentDocument.getIcon()\n    if icn != null (\n      icon icn 1 : c#fff chx#7.5\n      change_x 17.5\n    )\n    text layouts.shared.state.currentDocument.getTitle() 10 : c#shared.theme.text\n  )\n  \n  frame area[1] area[4] titlebarX area[2] (\n    goto 0 0\n    square frame.width - 5 25 0 0 1\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        layouts.summit.sidebar.open = true\n      )\n    )\n    icon \"right\" .6 : c#shared.theme.text chx#5\n  )\n)\n"]]]]], [".folder", "assets", [[".rwl", "empty", "root {\n  \"grahhh\"\n}"]]], [".folder", "net", [[".osl", "fetch", "\ndef url(object url) (\n  if url.scheme == \"local\" (\n    local f @= open(url.domain_name).toStr()\n    local r @= net.response.ValidResponse(url)\n    r.fetch @= def() -> (\n      self.content = self.f\n      self.isFinished = true\n    )\n    r.f @= f\n    return r\n  )\n\n  local servers @= shared.config.net.servers\n  local server @= servers[url.scheme]\n  \n  if server == null (\n    local r @= net.response.NoResponse(url, \"scheme '\" ++ url.scheme ++ \"' not found\")\n    return r\n  )\n  \n  local resource = url.domain_top\n  resource ++= \"/\"\n  if url.domain_sub != null (\n    resource ++= url.domain_sub\n    resource ++= \".\"\n  )\n  resource ++= url.domain_name\n  if url.resource != null (\n    resource ++= \"/\"\n    resource ++= url.resource\n  )\n  \n  local tld = server.tlds[url.domain_top]\n  \n  if tld == null (\n    local r @= net.response.NoResponse(url, \"tld '\" ++ url.domain_top ++ \"' not found\")\n    return r\n  )\n  \n  local realUrl = tld ++ \"/\" ++ resource\n  \n  local r @= net.response.ValidResponse(url)\n  r.fetch @= def() -> (\n    local o = self.realUrl.getAsync()\n    if o != \"Loading\" and o != \"404: Not Found\" (\n      self.content = o\n      self.isFinished = true\n    )\n  )\n  r.realUrl = realUrl\n  \n  return r\n)\n"], [".osl", "response", "\nclass Response (\n  isValid = false\n  \n  def init(object url, string content) (\n    self.url @= url\n    self.content = content\n    \n    self.isFinished = true\n  )\n)\n\nclass NoResponse extends Response (\n  \n)\n\nclass ValidResponse extends Response (\n  isValid = true\n  \n  def init(object url) (\n    self.url @= url\n    \n    self.isFinished = false\n  )\n  \n  def update() (\n    void self.fetch()\n  )\n)\n"]]], [".folder", "devtools", [[".folder", "menus", [[".osl", "elements", "\nnumber indent = 20\n\nnumber x = 0\nnumber y = 0\n\nnumber maxX = 0\n\ndef drawElements(array elements) (\n  for i elements.len (\n    if elements[i] != null (\n      drawElement(elements[i])\n    )\n    if i < elements.len (\n      text \",\" 10\n    )\n  )\n)\n\ndef drawElement(object element) (\n  if element.children != null or element.kind == \"script\" (\n    self.y -= 15\n    goto 0 self.y\n    \n    element.dvt_open ??= false\n    \n    goto self.x self.y\n    square 20 20 0 0 1 : c#fff\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        element.dvt_open = !element.dvt_open\n      )\n    )\n    icon element.dvt_open ? \"down\" \"right\" .5 : c#shared.theme.text\n    \n    text element.blockName ?? element.name 10 : chx#15\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        element.dvt_open = !element.dvt_open\n      )\n    )\n    \n    self.y -= 15\n    \n    if element.dvt_open (\n      text \"{\" 10 : chx#10\n      self.maxX = max(self.maxX, x_position)\n      self.x += self.indent\n      \n      if element.kind == \"script\" (\n        local content = element.body\n        local lines @= content.split(\"\\n\")\n        local line_height = 25\n        local height = lines.len - 1 * line_height + 5\n        \n        local cy = self.y - 2.5\n        self.y -= height\n        \n        for i lines.len (\n          cy -= line_height / 2\n          \n          goto self.x cy\n          \n          self.maxX = max(self.maxX, x_position + (lines[i].len * 10))\n          text lines[i].trimText(frame.right - x_position - 17.5 / 8) 10 : c#shared.theme.text\n          \n          cy -= line_height / 2\n        )\n      ) else (\n        drawElements(element.children)\n      )\n      \n      self.x -= self.indent\n      \n      self.y -= 15\n      goto self.x - 5 self.y\n      text \"}\" 10\n      self.y -= 15\n    ) else (\n      if element.kind == \"script\" (\n        text \"{\" 10 : chx#10\n        drawTooLong() : chx#10\n        text \"}\" 10 : chx#10\n      ) else (\n        text \"{\" 10 : chx#10\n        drawMiniChildren(element.children) : chx#10\n        text \"}\" 10 : chx#10\n      )\n      self.maxX = max(self.maxX, x_position)\n    )\n  ) else (\n    self.y -= 15\n    goto self.x self.y\n    drawValue(element.value)\n    self.y -= 15\n  )\n)\n\ndef drawValue(object value) (\n  switch value.type (\n    case \"str\"\n      text value.value.JsonStringify() 10\n      break\n    case \"num\"\n      text value.value 10\n      break\n  )\n)\n\ndef drawMiniChildren(array children) (\n  if children.len == 0 (\n    change_x -20\n    return\n  )\n  \n  change_x 5\n  for i children.len (\n    drawMiniChild(children[i])\n    if i < children.len (\n      text \", \" 6\n    )\n  )\n  change_x 5\n  \n  change_x -20\n)\n\ndef drawMiniChild(object element) (\n  if element.children != null or element.kind == \"script\" (\n    text element.blockName ?? element.name 7\n    text \"{\" 7 : chx#10\n    drawTooLong()\n    text \"}\" 7 : chx#20\n  ) else (\n    text \"Element\" 7\n  )\n)\n\ndef drawTooLong() (\n  text \"...\" 8 : chx#5\n  change_x -15\n)\n\ndef update() (\n  local document @= layouts.shared.state.currentDocument\n  local elements @= document.rwlInst.elements\n  \n  local s = frame.scroll_h * -1\n  self.x = frame.left + s + 15\n  local startX = self.x - 20\n  self.y = frame.top + frame.scroll\n  local startY = self.y\n  \n  self.width = 0\n  self.maxX = 0\n  \n  if elements != null (\n    drawElements(elements)\n  )\n  \n  self.width = self.maxX - startX\n  self.height = startY - self.y + 5\n)\n"], [".osl", "console", "\ndef getInst() (\n  return layouts.shared.state.currentDocument.rtrInst\n)\n\ndef topbar() (\n  local inst @= self.getInst()\n  \n  goto frame.left + 10 0\n  square 15 15 0 0 1\n  if inst != null (\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        inst.console @= []\n      )\n    )\n    c shared.theme.text\n  ) else (\n    if mouse_touching (\n      cursor \"not-allowed\"\n    )\n    c shared.theme.seco\n  )\n  icon \"w 2.5 cutcircle 0 0 10 0 180 line -6 -6 6 6\" .7\n)\n\ndef update() (\n  local inst @= self.getInst()\n  \n  local y = frame.top\n  local start = y\n  \n  for ii inst.console.len (\n    local item @= inst.console[ii]\n    local lines @= item[2].wrapText(frame.width - 10 / 10).split(\"\\n\")\n    local height = lines.len * 20\n    \n    local col = null\n    if item[1] == \"err\" (\n      col = #f00\n    )\n    \n    local ly = y\n    local sy = y\n    \n    y -= 5\n    y -= height\n    y -= 5\n    \n    if col != null (\n      frame frame.left y frame.right ly (\n        c col\n        pen \"opacity\" 20\n        pen \"size\" 10000\n        pen \"down\"\n        pen \"up\"\n      )\n    )\n    \n    for i lines.len (\n      ly -= 10\n      goto frame.left + 5 ly - 5\n      text lines[i] 10 : c#shared.theme.text\n      ly -= 10\n    )\n    \n    pen \"size\" 2 : c#shared.theme.prim\n    \n    goto 0 sy\n    line frame.left 0 frame.right 0\n    \n    goto 0 y\n    line frame.left 0 frame.right 0\n  )\n)\n"], [".osl", "network", ""], [".osl", "storage", ""]]], [".osl", "main", "\nstring anchor = \"r\"\nnumber width = 350\nnumber resizingEdge = 0\n\nmenu = \"console\"\n\ndef update(array area, array rawArea) (\n  goto rwl.area.centerX(area) rwl.area.centerY(area)\n  square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back\n  \n  local h = 25\n  frame area[1] area[4] area[3] area[4] - h (\n    void devtools.topbar.update()\n  )\n  \n  if mouse_y > area[2] and mouse_y < area[4] (\n    if anchor == \"r\" and abs(mouse_x - area[1]) < 5 (\n      cursor \"col-resize\"\n      goto mouse_x mouse_y\n      square 100 100 0 0 1\n      if onclick (\n        self.resizingEdge = 1\n      )\n    )\n    if anchor == \"l\" and abs(mouse_x - area[3]) < 5 (\n      cursor \"col-resize\"\n      goto mouse_x mouse_y\n      square 100 100 0 0 1\n      if onclick (\n        self.resizingEdge = 3\n      )\n    )\n  )\n  \n  if !mouse_down (\n    self.resizingEdge = 0\n  )\n  \n  if self.resizingEdge != 0 (\n    self.width = abs(mouse_x - area[4 - self.resizingEdge])\n  )\n  self.width = min(self.width, rwl.area.width(rawArea) - 200)\n  self.width = max(self.width, 200)\n  \n  local menu @= devtools.menus[self.menu]\n  \n  c shared.theme.prim\n  local topbarH = 0\n  if menu.topbar != null (\n    topbarH = 25\n    frame area[1] area[4] - h area[3] area[4] - h - topbarH (\n      void menu.topbar()\n    )\n    local w = rwl.area.width(area)\n    goto rwl.area.centerX(area) area[4] - h - topbarH\n    pen \"size\" 2\n    line w / -2 -1 w / 2 -1 : c#shared.theme.prim\n    topbarH += 1\n  )\n  \n  c shared.theme.prim\n  frame area[1] area[4] - h - topbarH area[3] area[2] [menu.width,menu.height] \"devtools_\" ++ self.menu (\n    if menu != null (\n      if menu.update != null (\n        void menu.update()\n      )\n    ) else (\n      goto 0 0\n      centext \"no open devtools menu\" 9 : c#shared.theme.prim\n    )\n  )\n)\n"], [".osl", "topbar", "\ntabs_scroll = 0\ntabs_width = 0\n\ndef update() (\n  goto 0 -5\n  square frame.width - 10 frame.height 10 : c#shared.theme.prim\n  \n  square frame.width frame.height 0 0 1\n  if mouse_touching (\n    self.tabs_scroll += scroll.x.velocity + scroll.y.velocity * scroll.multiplier * 1.5\n  )\n  \n  self.tabs_scroll = min(self.tabs_scroll, self.tabs_width - frame.width)\n  self.tabs_scroll = max(self.tabs_scroll, 0)\n  \n  local x = frame.left - self.tabs_scroll\n  local start = x\n  local menus @= devtools.menus.getEntries()\n  for i menus.len (\n    local menu @= menus[i]\n    \n    local title = menu[1].toTitle()\n    local w = title.len * 8 + 10\n    \n    x += w / 2\n    \n    goto x 0\n    square w - 10 10 10 0 1\n    c devtools.main.menu == menu[1] ? shared.theme.seco shared.theme.prim\n    if mouse_touching (\n      c shared.theme.tert\n      cursor \"pointer\"\n      if onclick (\n        devtools.main.menu = menu[1]\n      )\n    )\n    pen \"size\" 2\n    line w / -2 -11 w / 2 -11\n    centext title 8 : c#shared.theme.text\n    \n    x += w / 2\n  )\n  self.tabs_width = x - start\n)\n"]]], [".folder", "archive", [[".osl", "devtools", "\ndef drawElement(object element) (\n  self.y -= 15\n  goto 0 self.y\n  square frame.width - 15 30 - 15 10 : c#shared.theme.back hover_c#shared.theme.prim\n  \n  element.dvt_open ??= false\n  \n  if element.children != null or element.kind == \"script\" (\n    goto frame.left + 15 + self.x self.y\n    square 20 20 0 0 1 : c#fff\n    if mouse_touching (\n      cursor \"pointer\"\n      if onclick (\n        element.dvt_open = !element.dvt_open\n      )\n    )\n    icon element.dvt_open ? \"down\" \"right\" .5 : c#shared.theme.text\n    \n    text element.blockName ?? element.name 10 : chx#15\n    \n    self.x += self.indent\n    self.y -= 15\n    \n    if element.dvt_open (\n      if element.kind == \"script\" (\n        local content = element.body\n        local lines @= content.split(\"\\n\")\n        local line_height = 15\n        local height = lines.len - 1 * line_height + 10\n        \n        self.y -= height / 2\n        goto 0 self.y\n        square frame.width - 15 height - 15 10 : c#shared.theme.back hover_c#shared.theme.prim\n        self.y += height / 2\n        \n        self.y -= 5\n        \n        for i lines.len (\n          self.y -= line_height / 2\n          goto frame.left + 15 + self.x self.y\n          text lines[i].trimText(frame.right - x_position - 17.5 / 8) 8 : c#shared.theme.text\n          self.y -= line_height / 2\n        )\n        \n        self.y -= height\n      ) else (\n        drawElements(element.children)\n      )\n    ) else (\n      // todo\n    )\n    \n    self.x -= self.indent\n  ) else (\n    self.y -= 15\n  )\n)"]]]]], [".rwl", "main", "root [color=theme:prim] {\n  frame [Horizontal] {\n    section [size=100, rounding_tr=20, rounding_br=20] {\n      \"fr\" [color=theme:seco],\n      \"str\",\n      15\n    },\n    section {\n      frame [Vertical] {\n        section [size=50] {\n          \"maybe?\" [color=theme:text, anchor=\"l\", padding=10, size=15]\n        },\n        section [color=theme:back, rounding=20, margin_r=10, margin_b=10, padding=20] {\n          \"blehhh\" [color=theme:text],\n          \"fr\",\n          \":P\" [anchor=\"bl\",size=5]\n        }\n      }\n    }\n  },\n  script {\n    event(onload) {\n      for(i, range(1,10)) {\n        log(i);\n      }\n      \n      document.title = \"gay\";\n      document.icon = \"flag-progress\";\n    }\n  }\n}"], [".json", "opal", "{\"name\": \"phosphorus\", \"version\": \"1.0.0\", \"description\": \"rotur web engine\", \"main\": \"script.osl\", \"dependencies\": {}, \"tags\": [], \"include\": [\"./main.rwl\", \"./src/assets/empty.rwl\"]}"], [".osl", "script", "import as \"glass\" from \"packages\"\n\n// import overwrite\n__import @= import;import @= i -> (i.endsWith(\".osl\") ? __import(i) open(i))\n\nobject rwl @= {\n  main: import(\"./src/rwl/main.osl\"),\n  config: import(\"./src/rwl/config.osl\"),\n  area: import(\"./src/rwl/area.osl\"),\n  error: import(\"./src/rwl/error.osl\"),\n  value: import(\"./src/rwl/value.osl\"),\n  debug: import(\"./src/rwl/debug.osl\"),\n  ast: import(\"./src/rwl/ast.osl\")\n}\n\nobject rtr @= {\n  main: import(\"./src/rtr/main.osl\"),\n  ast: import(\"./src/rtr/ast.osl\"),\n  error: import(\"./src/rtr/error.osl\"),\n  value: import(\"./src/rtr/value.osl\")\n}\n\nrtr.rwl @= import(\"./src/rtr/rwl.osl\")\n\nobject shared @= {\n  graphics: import(\"./src/shared/graphics.osl\"),\n  utils: import(\"./src/shared/utils.osl\"),\n  document: import(\"./src/shared/document.osl\"),\n  tab: import(\"./src/shared/tab.osl\"),\n  url: import(\"./src/shared/url.osl\"),\n  theme: import(\"./src/shared/theme.osl\"),\n  config: import(\"./src/shared/config.osl\"),\n  tab_worker: import(\"./src/shared/tab_worker.osl\")\n}\n\nobject layouts @= {\n  shared: {\n    state: import(\"./src/layouts/shared/state.osl\"),\n    utils: import(\"./src/layouts/shared/utils.osl\"),\n    topbar: import(\"./src/layouts/shared/topbar.osl\"),\n    urlbar: import(\"./src/layouts/shared/urlbar.osl\"),\n    view: import(\"./src/layouts/shared/view.osl\")\n  },\n  chromeLike: {\n    main: import(\"./src/layouts/chromeLike/main.osl\"),\n    topbar: import(\"./src/layouts/chromeLike/topbar.osl\")\n  },\n  summit: {\n    main: import(\"./src/layouts/summit/main.osl\"),\n    sidebar: import(\"./src/layouts/summit/sidebar.osl\"),\n    topbar: import(\"./src/layouts/summit/topbar.osl\")\n  }\n}\n\nobject net @= {\n  fetch: import(\"./src/net/fetch.osl\"),\n  response: import(\"./src/net/response.osl\")\n}\n\nobject devtools @= {\n  main: import(\"./src/devtools/main.osl\"),\n  topbar: import(\"./src/devtools/topbar.osl\"),\n  \n  menus: {\n    elements: import(\"./src/devtools/menus/elements.osl\"),\n    console: import(\"./src/devtools/menus/console.osl\"),\n    network: import(\"./src/devtools/menus/network.osl\"),\n    storage: import(\"./src/devtools/menus/storage.osl\")\n  }\n}\n\nvoid layouts.chromeLike.main.init()\n\nlocal document2 @= shared.document.Document()\nlocal document @= shared.document.Document()\nvoid document.loadUrl(shared.url.Url(\"local://~/projects/phosphorus/main.rwl\"))\nvoid layouts.shared.state.openTabDocument(document)\nvoid layouts.shared.state.openTabDocument(document2)\n\nvoid layouts.shared.state.selectTab(1)\n\nvoid window.resize(900,500)\n\nmainloop:\n  //void layouts.chromeLike.main.update()\n  void layouts.summit.main.update()\n  \n  // file dropping\n  if file_dropped != 0 (\n    local data @= open(file_dropped,[3,2,1])\n    local path = data[1] ++ \"/\" ++ data[2] ++ data[3]\n    local document @= shared.document.Document()\n    void document.loadUrl(shared.url.Url(\"local://\" ++ path))\n    void layouts.shared.state.openTabDocument(document)\n    file_dropped = 0\n  )"]]]