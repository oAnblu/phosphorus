opal_imports = {}
def import(path) (
  switch path (

case "./src/devtools/menus/storage.osl"
  class __imports__968375a74382766e626cb371cd10b43a (
    
  )
  return __imports__968375a74382766e626cb371cd10b43a
case "./src/devtools/menus/network.osl"
  class __imports__b4ec205ca81f7630cd7f76511fd744fb (
    
  )
  return __imports__b4ec205ca81f7630cd7f76511fd744fb
case "./src/devtools/menus/console.osl"
  class __imports__ac7f1c744ff0d794c130cdf96196926d (
    def getInst() (
      return layouts.shared.state.currentDocument.rtrInst
    )
    
    def topbar() (
      local inst @= self.getInst()
      
      goto frame.left + 10 0
      square 15 15 0 0 1
      if inst != null (
        if mouse_touching (
          cursor "pointer"
          if onclick (
            inst.console @= []
          )
        )
        c shared.theme.text
      ) else (
        if mouse_touching (
          cursor "not-allowed"
        )
        c shared.theme.seco
      )
      icon "w 2.5 cutcircle 0 0 10 0 180 line -6 -6 6 6" .7
    )
    
    def update() (
      local inst @= self.getInst()
      
      local y = frame.top + frame.scroll
      local start = y
      
      for ii inst.console.len (
        local item @= inst.console[ii]
        local lines @= item[2].wrapText(frame.width - 10 / 10).split("\n")
        local height = lines.len * 20
        
        local col = null
        if item[1] == "err" or item[1] == "repl-err" (
          col = #f00
        )
        
        local ly = y
        local sy = y
        
        y -= 5
        y -= height
        y -= 5
        
        if col != null (
          frame frame.left y frame.right ly (
            c col
            pen "opacity" 20
            pen "size" 10000
            pen "down"
            pen "up"
          )
        )
        
        local offsetX = 5
        
        if item[1].startsWith("repl") (
          goto frame.left + offsetX + 5 ly - 15
          
          if item[1] == "repl-in" (
            icon "right" .5 : c#shared.theme.text
          )
          if item[1] == "repl-ret" (
            icon "left" .5 : c#shared.theme.text
          )
          if item[1] == "repl-err" (
            icon "left" .5 : c#shared.theme.text
          )
          offsetX += 20
        )
        
        c shared.theme.text
        for i lines.len (
          ly -= 10
          goto frame.left + offsetX ly - 5
          text lines[i] 10
          ly -= 10
        )
        
        pen "size" 2 : c#shared.theme.prim
        
        goto 0 sy
        line frame.left 0 frame.right 0
        
        goto 0 y
        line frame.left 0 frame.right 0
      )
      
      // repl
      y -= 15
      goto frame.left + 12.5 y
      icon "right" .5 : c#shared.theme.text
      
      local inputId = "devtools_repl_" ++ inst.ouid
      goto 12.5 y
      input frame.width - 35 30 inputId null 0 shared.theme.text : c#shared.theme.back
      
      if "enter".onKeyDown() and inputs.selected.id == inputId (
        local inp = inputs[inputId]
        
        void inst.console.append(["repl-in", inp])
        
        promiseData = inp
        promiseData2 @= inst
        self.runPromise @= Promise.new(def() -> (
          local parser @= rtr.ast.Parser("event(onload){return(" ++ promiseData ++ ");}")
          self.ast @= parser.parse()
          self.mod @= rtr.main.Module(self.ast)
          void rtr.rwl.addToMod(layouts.shared.state.currentDocument, self.mod)
          void promiseData2.addModule(self.mod)
          local ret @= mod.runEventRaw({
            name: "onload"
          }, {})
          return ret
        ))
        
        inputs[inputId] = ""
      )
      
      if self.runPromise != null (
        local ret @= self.runPromise.worker.return
        if ret != null (
          void inst.console.append(["repl-ret", ret.stringify(true)])
          self.runPromise = null
        )
      )
      
      y -= 15
      
      self.height = start - y - 10
    )
  )
  return __imports__ac7f1c744ff0d794c130cdf96196926d
case "./src/devtools/menus/elements.osl"
  class __imports__7de0f89117b2e081473955ae82bcf430 (
    number indent = 20
    
    number x = 0
    number y = 0
    
    number maxX = 0
    
    def drawElements(array elements) (
      for i elements.len (
        if elements[i] != null (
          drawElement(elements[i])
        )
        if i < elements.len (
          text "," 10
        )
      )
    )
    
    def drawElement(object element) (
      if element.children != null or element.kind == "script" (
        self.y -= 15
        goto 0 self.y
        
        element.dvt_open ??= false or true
        
        goto self.x self.y
        square 20 20 0 0 1 : c#fff
        if mouse_touching (
          cursor "pointer"
          if onclick (
            element.dvt_open = !element.dvt_open
          )
        )
        icon element.dvt_open ? "down" "right" .5 : c#shared.theme.text
        
        text element.blockName ?? element.name 10 : chx#15
        if mouse_touching (
          cursor "pointer"
          devtools.main.hoveredElement = element.elemI
          if onclick (
            element.dvt_open = !element.dvt_open
          )
        )
        
        drawHeader(element.header)
        
        self.y -= 15
        
        if element.dvt_open (
          text "{" 10 : chx#10
          self.maxX = max(self.maxX, x_position)
          self.x += self.indent
          
          if element.kind == "script" (
            local content = element.body
            local lines @= content.split("\n")
            local line_height = 25
            local height = lines.len - 1 * line_height + 5
            
            local cy = self.y - 2.5
            self.y -= height
            
            for i lines.len (
              cy -= line_height / 2
              
              goto self.x cy
              
              //self.maxX = max(self.maxX, x_position + (lines[i].len * 10))
              //text lines[i].trimText(frame.right - x_position - 17.5 / 8) 10 : c#shared.theme.text
              text lines[i] 10 : c#shared.theme.text
              
              cy -= line_height / 2
            )
          ) else (
            drawElements(element.children)
          )
          
          self.x -= self.indent
          
          self.y -= 15
          goto self.x - 5 self.y
          text "}" 10
          self.y -= 15
        ) else (
          if element.kind == "script" (
            text "{" 10 : chx#10
            drawTooLong() : chx#10
            text "}" 10 : chx#10
          ) else (
            text "{" 10 : chx#10
            drawMiniChildren(element.children) : chx#10
            text "}" 10 : chx#10
          )
          self.maxX = max(self.maxX, x_position)
        )
      ) else if element.kind == "element" (
        self.y -= 15
        goto self.x self.y
        drawValue(element.value)
        drawHeader(element.header)
        local s = x_position
        self.maxX = max(self.maxX, x_position)
        local w = x_position - self.x
        goto x_position + self.x / 2 self.y
        square w 20 0 0 1
        if mouse_touching (
          devtools.main.hoveredElement = element.elemI
        )
        goto s self.y
        self.y -= 15
      ) else if element.kind == "icon" (
        self.y -= 15
        goto self.x self.y
        text "Icon" 10
        drawHeader(element.header)
        self.maxX = max(self.maxX, x_position)
        self.y -= 15
      )
    )
    
    def drawHeader(object header) (
      if header.flags.len == 0 and header.pairs.len == 0 (
        return
      )
      
      change_x 7.5
      text "[" 10
      for i header.flags.len (
        local flag = header.flags[i]
        text flag 8
        if i < header.flags.len or header.pairs.len > 0 (
          text ", " 8
        )
      )
      
      for i header.pairs.len (
        local pair @= header.pairs[i]
        text pair[1] 10
        text "=" 8
        drawValue(pair[2])
        if i < header.pairs.len (
          text ", " 8
        )
      )
      text "]" 10
    )
    
    def drawValue(object value) (
      switch value.type (
        case "str"
          text value.value.JsonStringify() 10
          break
        case "num"; case "color"
          text value.value 10
          break
        case "percentage"
          text value.value.toStr() ++ "%" 10
          break
      )
    )
    
    def drawMiniChildren(array children) (
      if children.len == 0 (
        change_x -20
        return
      )
      
      change_x 5
      for i children.len (
        drawMiniChild(children[i])
        if i < children.len (
          text ", " 8
        )
      )
      change_x 5
      
      change_x -20
    )
    
    def drawMiniChild(object element) (
      if element.children != null or element.kind == "script" (
        text element.blockName ?? element.name 7
        text "{" 7 : chx#10
        drawTooLong()
        text "}" 7 : chx#20
      ) else (
        text "Element" 7
      )
    )
    
    def drawTooLong() (
      text "..." 8 : chx#5
      change_x -15
    )
    
    def update() (
      local document @= layouts.shared.state.currentDocument
      local elements @= document.rwlInst.elements
      if typeof(elements) != "array" (
        elements @= []
      )
      
      local s = frame.scroll_h * -1
      self.x = frame.left + s + 15
      local startX = self.x
      self.y = frame.top + frame.scroll
      local startY = self.y
      
      self.width = 0
      self.maxX = 0
      
      if elements != null (
        drawElements(elements)
      )
      
      //self.width = self.maxX - startX
      self.width = self.maxX - startX
      self.height = startY - self.y + 5
    )
  )
  return __imports__7de0f89117b2e081473955ae82bcf430
case "./src/layouts/summit/topbar.osl"
  class __imports__6a477e7780a631dfc33d414269cd6008 (
    def update(array area) (
      goto rwl.area.centerX(area) rwl.area.centerY(area)
      square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back
      
      local btns @= layouts.shared.topbar.defaultButtons
      void layouts.shared.topbar.winButtons(btns, false)
      
      local titlebarX = max(area[1], window.left + 30)
      goto titlebarX + 10 rwl.area.centerY(area)
      if layouts.shared.state.currentDocument != null (
        local icn = layouts.shared.state.currentDocument.getIcon()
        if icn != null (
          icon icn 1 : c#fff chx#7.5
          change_x 17.5
        )
        text layouts.shared.state.currentDocument.getTitle() 10 : c#shared.theme.text
      )
      
      frame area[1] area[4] titlebarX area[2] (
        goto 0 0
        square frame.width - 5 25 0 0 1
        if mouse_touching (
          cursor "pointer"
          if onclick (
            layouts.summit.sidebar.open = true
          )
        )
        icon "right" .6 : c#shared.theme.text chx#5
      )
    )
  )
  return __imports__6a477e7780a631dfc33d414269cd6008
case "./src/layouts/summit/sidebar.osl"
  class __imports__3dfd082eaa91cc9b8340f13c6baac410 (
    open_width = 250
    
    width = 200
    tar_width = open_width
    open = true
    
    def update(array area) (
      goto rwl.area.centerX(area) rwl.area.centerY(area)
      square rwl.area.width(area) - 20 rwl.area.height(area) - 20 10 : c#shared.theme.back
      
      frame area[1] + 10 area[4] - 10 area[3] - 10 area[4] - 35 (
        //square 1000 1000 1000 : c#fff
        goto frame.right - 12.5 0
        square 20 20 0 0 1 : c#fff
        if mouse_touching (
          cursor "pointer"
          if onclick (
            self.open = false
          )
        )
        goto frame.right - 12.5 0
        icon "left" .6 : c#shared.theme.text
        
        goto frame.left + 12.5 0
        square 20 20 0 0 1 : c#fff
        if mouse_touching (
          cursor "pointer"
          if onclick (
            void layouts.shared.state.openEmptyTab()
          )
        )
        icon "add" .6 : c#shared.theme.text
      )
      
      void layouts.shared.urlbar.update([
        area[1] + 10,
        area[4] - 40 - 32.5,
        area[3] - 10,
        area[4] - 40 - 2.5
      ])
      
      local height = 1000
      c shared.theme.prim
      frame area[1] + 5 area[4] - 40 - 35 area[3] - 5 area[2] + 5 height "browser_sidebar" (
        local y = frame.top + frame.scroll
        
        for i layouts.shared.state.tabs.len (
          local tab @= layouts.shared.state.tabs[i]
          
          local title = tab.document.getTitle()
          local icon = tab.document.getIcon()
          y -= 20
          
          local close_touching = false
          
          goto frame.right - 22.5 y
          square 15 15 0 0 1
          local close_touching = mouse_touching
          
          goto 0 y
          c layouts.shared.state.currentTab == i ? shared.theme.seco shared.theme.prim
          square frame.width - 25 20 15 : hover_c#shared.theme.tert
          if mouse_touching and !close_touching (
            cursor "pointer"
            if onclick (
              void layouts.shared.state.selectTab(i)
            )
          )
          square frame.width - 25 20 10 : c#shared.theme.back
          
          goto frame.left + 15 y
          if icon != null (
            icon icon .9 : c#user.theme.text chx#7.5
            change_x 15
          )
          text title.trimText(frame.right - x_position / 9 - 4) 9 : c#shared.theme.text tooltip#title
          
          goto frame.right - 22.5 y
          square 15 15 0 0 1
          if mouse_touching (
            cursor "pointer"
            if onclick (
              void layouts.shared.state.closeTab(i)
              i --
            )
          )
          icon "close" .5
          
          y -= 20
        )
      )
      
      // clicking on the left side of the window opens the sidebar
      if self.width < 25 (
        goto window.left 0
        square 20 window.height 0 0 1
        if mouse_touching (
          cursor "pointer"
          if onclick (
            self.open = true
          )
        )
      )
      
      self.tar_width = self.open ? self.open_width 5
      self.width += self.tar_width - self.width * min(delta_time, 0.02) * 10
    )
  )
  return __imports__3dfd082eaa91cc9b8340f13c6baac410
case "./src/layouts/summit/main.osl"
  class __imports__70bd3fa18cef0c20ca734751135b82d8 (
    def init() (
      void shared.document.init()
      void layouts.shared.state.init()
    )
    
    def update() (
      void shared.theme.load()
      void shared.input.update()
      
      window.show()
      window_colour = #000
      
      glass:frame window.left window.top window.right window.bottom; frame "clear"
      
      void layouts.shared.state.resetDragbox()
      
      layouts.shared.state.dragbox[1][3] = max(layouts.summit.sidebar.width, 30)
      
      void layouts.summit.sidebar.update([
        window.left + layouts.summit.sidebar.width - layouts.summit.sidebar.open_width,
        window.bottom,
        window.left + layouts.summit.sidebar.width,
        window.top
      ])
      
      void layouts.summit.topbar.update([
        window.left + layouts.summit.sidebar.width,
        window.top - 37.5,
        window.right - 5,
        window.top - 5
      ])
      
      void layouts.shared.view.render([
        window.left + layouts.summit.sidebar.width,
        window.bottom + 5,
        window.right - 5,
        window.top - 42.5
      ])
      
      void layouts.shared.state.applyDragbox()
    )
  )
  return __imports__70bd3fa18cef0c20ca734751135b82d8
case "./src/layouts/chromeLike/topbar.osl"
  class __imports__0f6f8e5da8ad7dfb8f0386ba0c4b7fd4 (
    def tabs() (
      local space = window.width - 100 - 17.5 - 15
      
      local hovered = false
      
      local x = 0
      local tabMax = space / layouts.shared.state.tabs.len - 5
      for i layouts.shared.state.tabs.len (
        local tab @= layouts.shared.state.tabs[i]
        
        local title = tab.document.getTitle()
        local icon = tab.document.getIcon()
        
        local pad = 15 + 27.5
        if icon != null (
          pad += 20
        )
        //local width = title.len * 9 + pad
        local width = 200
        //width = max(width, 200)
        width = min(width, tabMax)
        
        local lx = x
        x += 2.5 + (width / 2)
        
        loc 2 2 x + (width / 2) - 17.5 -20
        square 15 15 0 0 1
        local close_touching = mouse_touching
        
        loc 2 2 x -20
        
        square width - 17.5 17.5 15 0 1
        c mouse_touching ? shared.theme.seco shared.theme.prim
        if layouts.shared.state.currentTab == i (
          c shared.theme.tert
        )
        square width - 17.5 17.5 15
        
        if mouse_touching and !close_touching (
          layouts.shared.state.dragbox @= [
            [2, 2, lx, 0],
            [2, 2, lx + width, -20]
          ]
          hovered = true
          
          cursor "pointer"
          if onclick (
            void layouts.shared.state.selectTab(i)
          )
        )
        
        square width - 17.5 17.5 10 : c#shared.theme.prim
        
        if icon != null (
          lx += 20
          loc 2 2 lx -20
          icon icon .9 : c#user.theme.text
          lx += 5
        )
        lx += 10
        
        loc 2 2 lx -20
        text title.trimText(width - pad / 9) 9 : c#shared.theme.text tooltip#title
        
        lx += 5
        loc 2 2 x + (width / 2) - 17.5 -20
        square 15 15 0 0 1
        if mouse_touching (
          cursor "pointer"
          if onclick (
            void layouts.shared.state.closeTab(i)
            i --
          )
        )
        icon "close" .5
        
        x += 2.5 + (width / 2)
      )
      
      x += 17.5
      loc 2 2 x -20
      square 17.5 17.5 15 : c#shared.theme.prim hover_c#shared.theme.seco
      if mouse_touching (
        cursor "pointer"
        if onclick (
          void layouts.shared.state.openEmptyTab()
        )
      )
      icon "add" .6 : c#user.theme.text
      x += 20
      
      loc -2 2 -90 -20
      line 0 -20 0 20 : c#shared.theme.prim w#1
      
      if !hovered (
        layouts.shared.state.dragbox[1][3] += x
      )
    )
  )
  return __imports__0f6f8e5da8ad7dfb8f0386ba0c4b7fd4
case "./src/layouts/chromeLike/main.osl"
  class __imports__34355e72215dbff81e1963b1534949ee (
    def init() (
      void shared.document.init()
      void layouts.shared.state.init()
    )
    
    def update() (
      void shared.theme.load()
      void shared.input.update()
    
      window.show()
      window_colour = shared.theme.back
      
      void layouts.shared.state.resetDragbox()
    
      local btns @= layouts.shared.topbar.defaultButtons
      void layouts.shared.topbar.winButtons(btns, false)
      
      void layouts.chromeLike.topbar.tabs()
      
      void layouts.shared.urlbar.update([
        window.left,
        window.top - 45 - 30,
        window.right,
        window.top - 44
      ])
      
      void layouts.shared.view.render([
        window.left,
        window.bottom,
        window.right,
        window.top - 45 - 32.5
      ])
      
      void layouts.shared.state.applyDragbox()
    )
  )
  return __imports__34355e72215dbff81e1963b1534949ee
case "./src/layouts/shared/view.osl"
  class __imports__5228a5cd2bf6a46e3a340119920c2e17 (
    def render(array area) (
      local contentArea @= rwl.area.copy(area)
      
      if devtools.main.open (
        local devtoolsData @= devtools.main ?? { width: 0, anchor: "l" }
        
        local devtoolsArea @= rwl.area.copy(area)
        switch devtoolsData.anchor (
          case "l"
            contentArea[1] += devtoolsData.width
            devtoolsArea[3] = contentArea[1]
            break
          case "r"
            contentArea[3] -= devtoolsData.width
            devtoolsArea[1] = contentArea[3]
            break
        )
      
        devtoolsArea[1] += 5
      )
      
      if layouts.shared.state.currentDocument != null (
        void layouts.shared.state.currentDocument.checkResp()
        void layouts.shared.state.currentDocument.render(contentArea)
      )
      
      void devtools.main.alwaysUpdate()
      if devtools.main.open (
        void devtools.main.update(devtoolsArea, area)
      )
    )
  )
  return __imports__5228a5cd2bf6a46e3a340119920c2e17
case "./src/layouts/shared/urlbar.osl"
  class __imports__e1f3f683350eb46be2bb39ac4a8762b8 (
    inputId = "browser_url"
    
    def update(array area) (
      local defaultText = "blehh"
      
      goto rwl.area.centerX(area) rwl.area.centerY(area) + 2.5
      
      local w = rwl.area.width(area) - 15
      local h = rwl.area.height(area) - 0
      
      square w - 5 h - 18 15 : c#shared.theme.prim
      input w h - 5 self.inputId defaultText 0 shared.theme.text
      
      if inputs.selected.id == self.inputId (
        if "enter".onKeyDown() (
          void self.goto()
        )
      )
      
      //void shared.graphics.box(area, #f00)
    )
    
    def goto() (
      local url = inputs[self.inputId]
      
      url @= shared.url.Url(url)
      
      local tab @= layouts.shared.state.tabs[layouts.shared.state.currentTab]
      void tab.redirect(url)
    )
  )
  return __imports__e1f3f683350eb46be2bb39ac4a8762b8
case "./src/layouts/shared/topbar.osl"
  class __imports__bce8e403422ca1f602a36f77e9c471c6 (
    array defaultButtons = [
      {
        icon: "close",
        click: window.close
      },
      {
        icon: "down",
        click: window.minimise
      },
      {
        icon: "maximise",
        click: window.fullscreen
      }
    ]
    
    def winButtons(array buttons, boolean background) (
      if background (
        local w = buttons.len * 25
        
        loc -2 2 w / -2 - 7.5 -20
        square w - 5 18 10 : c#shared.theme.prim
      )
      
      loc -2 2 -20 -20
      change_x 25
      for i buttons.len (
        local button @= buttons[i]
        
        c shared.theme.text
        icon button.icon 0.6 * (button.icon_size ?? 1) : hover_size#1.1 chx#-25
        if mouse_touching (
          cursor "pointer"
          if onclick (
            void button.click()
          )
        )
      )
    )
  )
  return __imports__bce8e403422ca1f602a36f77e9c471c6
case "./src/layouts/shared/utils.osl"
  class __imports__bd7a86c2700e28469496d9f67248c0b2 (
    def getContentArea() (
      return [
        window.left,
        window.bottom,
        window.right,
        window.top - 50
      ]
    )
  )
  return __imports__bd7a86c2700e28469496d9f67248c0b2
case "./src/layouts/shared/state.osl"
  class __imports__d1763f06b30a5d5d9c10608cf0f00c3e (
    debug = false
    
    def init() (
      void self.updateTab()
      void self.selectTab(1)
      
      self.tabs @= []
    )
    
    def resetDragbox() (
      self.dragbox @= [[2,2,0,0],[-2,2,-90,-40]]
    )
    
    def applyDragbox() (
      window.setDragbox(self.dragbox[1], self.dragbox[2])
      
      if self.debug (
        c #fff
        loc self.dragbox[1][1] self.dragbox[1][2] self.dragbox[1][3] self.dragbox[1][4]
        pen "down"
        loc self.dragbox[2][1] self.dragbox[2][2] self.dragbox[2][3] self.dragbox[2][4]
        pen "up"
      )
    )
    
    def openTabDocument(object document) (
      local tab @= shared.tab.Tab(document)
      void self.tabs.append(tab)
      void self.selectTab(self.tabs.len)
    )
    
    def openEmptyTab() (
      void self.openTabDocument(shared.document.Document())
    )
    
    def closeTab(number index) (
      void self.tabs[index].document.close()
      void self.tabs.delete(index)
      
      if index < self.currentTab (
        self.currentTab --
      )
      
      void self.selectTab(self.currentTab)
    )
    
    def selectTab(number index) (
      self.currentTab @= index
      void self.updateTab()
    )
    
    def updateTab() (
      self.currentDocument @= self.tabs[self.currentTab].document
      inputs[layouts.shared.urlbar.inputId] = self.currentDocument.url.text
      //self.currentDocument ??= shared.document.Document()
    )
  )
  return __imports__d1763f06b30a5d5d9c10608cf0f00c3e
case "./src/devtools/rightclick.osl"
  class __imports__0598a8fc1c085cefe2171384b023fe8b (
    array topbar_more = [
      ["Dock",
        {"left": def() -> (
          void shared.settings.set("devtools", "dockside", "l")
        )},
        {"right": def() -> (
          void shared.settings.set("devtools", "dockside", "r")
        )}
      ]
    ]
  )
  return __imports__0598a8fc1c085cefe2171384b023fe8b
case "./src/devtools/topbar.osl"
  class __imports__3261b0e52c0051dec0dc6394c943d033 (
    tabs_scroll = 0
    tabs_width = 0
    
    def update() (
      square frame.width frame.height 0 0 1
      if mouse_touching (
        self.tabs_scroll += scroll.x.velocity + scroll.y.velocity * scroll.multiplier * 1.5
      )
      
      self.tabs_scroll = min(self.tabs_scroll, self.tabs_width - frame.width)
      self.tabs_scroll = max(self.tabs_scroll, 0)
      
      local x = frame.left - self.tabs_scroll
      local start = x
      local menus @= devtools.menus.getEntries()
      for i menus.len (
        local menu @= menus[i]
        
        local title = menu[1].toTitle()
        local w = title.len * 8 + 10
        
        x += w / 2
        
        goto x 0
        square w - 10 10 10 0 1
        c devtools.main.menu == menu[1] ? shared.theme.seco shared.theme.prim
        if mouse_touching (
          c shared.theme.tert
          cursor "pointer"
          if onclick (
            devtools.main.menu = menu[1]
          )
        )
        pen "size" 2
        line w / -2 -11 w / 2 -11
        centext title 8 : c#shared.theme.text
        
        x += w / 2
      )
      self.tabs_width = x - start
    )
  )
  return __imports__3261b0e52c0051dec0dc6394c943d033
case "./src/devtools/main.osl"
  class __imports__87f5572a1b07abb6f61e525f0557da7a (
    string anchor = "r"
    number width = 350
    boolean open = false
    
    number saveWidth = 350
    number resizingEdge = 0
    
    hoveredElement = 0
    
    menu = "console"
    
    def alwaysUpdate() (
      self.hoveredElement = 0
    )
    
    def update(array area, array rawArea) (
      goto rwl.area.centerX(area) rwl.area.centerY(area)
      square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back
      
      local h = 25
      frame area[1] area[4] area[3] area[4] - h (
        goto 0 -5
        square frame.width - 10 frame.height 10 : c#shared.theme.prim
        
        goto frame.right - 12.5 0
        icon "more-vertical" .5 : c#shared.theme.text
        if mouse_touching (
          cursor "pointer"
          if onclick (
            local p @= Promise.new(() -> (
              while mouse_down (
                defer
              )
              open_rightclick devtools.rightclick.topbar_more
            ))
            p.data @= devtools.rightclick.topbar_more
          )
        )
      )
      frame area[1] area[4] area[3] - 25 area[4] - h (
        void devtools.topbar.update()
      )
      
      if mouse_y > area[2] and mouse_y < area[4] (
        if anchor == "r" and abs(mouse_x - area[1]) < 5 (
          cursor "col-resize"
          goto mouse_x mouse_y
          square 100 100 0 0 1
          if onclick (
            self.resizingEdge = 1
          )
        )
        if anchor == "l" and abs(mouse_x - area[3]) < 5 (
          cursor "col-resize"
          goto mouse_x mouse_y
          square 100 100 0 0 1
          if onclick (
            self.resizingEdge = 3
          )
        )
      )
      
      if !mouse_down (
        self.resizingEdge = 0
      )
      
      if self.resizingEdge != 0 (
        self.width = abs(mouse_x - area[4 - self.resizingEdge])
      )
      self.width = min(self.width, rwl.area.width(rawArea) - 200)
      self.width = max(self.width, 200)
      
      local menu @= devtools.menus[self.menu]
      
      c shared.theme.prim
      local topbarH = 0
      if menu.topbar != null (
        topbarH = menu.topbarHeight ?? 25
        frame area[1] area[4] - h area[3] area[4] - h - topbarH (
          void menu.topbar()
        )
        local w = rwl.area.width(area)
        goto rwl.area.centerX(area) area[4] - h - topbarH
        pen "size" 2
        line w / -2 -1 w / 2 -1 : c#shared.theme.prim
        topbarH += 1
      )
      
      c shared.theme.prim
      local bottombarH = 0
      if menu.bottombar != null (
        bottombarH = menu.bottombarHeight ?? 25
        frame area[1] area[4] - h area[3] area[4] - h - bottombarH (
          void menu.bottombar()
        )
        local w = rwl.area.width(area)
        goto rwl.area.centerX(area) area[2] + bottombarH
        pen "size" 2
        line w / -2 1 w / 2 1 : c#shared.theme.prim
        bottombarH += 1
      )
      
      c shared.theme.prim
      frame area[1] area[4] - h - topbarH area[3] area[2] + bottombarH [menu.width,menu.height] "devtools_" ++ self.menu (
        if menu != null (
          if menu.update != null (
            void menu.update()
          )
        ) else (
          goto 0 0
          centext "no open devtools menu" 9 : c#shared.theme.prim
        )
      )
    )
  )
  return __imports__87f5572a1b07abb6f61e525f0557da7a
case "./src/net/response.osl"
  class __imports__f336b41d073413cbdabb122f71c530f0 (
    class Response (
      isValid = false
      
      def init(object url, string content) (
        self.url @= url
        self.content = content
        
        self.isFinished = true
      )
    )
    
    class NoResponse extends Response (
      
    )
    
    class ValidResponse extends Response (
      isValid = true
      
      def init(object url) (
        self.url @= url
        
        self.isFinished = false
      )
      
      def update() (
        void self.fetch()
      )
    )
  )
  return __imports__f336b41d073413cbdabb122f71c530f0
case "./src/net/fetch.osl"
  class __imports__d974ce5692d372884f5c4f8f8bf1ab18 (
    def url(object url) (
      if url.scheme == "local" (
        local f @= open(url.domain_name).toStr()
        local r @= net.response.ValidResponse(url)
        r.fetch @= def() -> (
          self.content = self.f
          self.isFinished = true
        )
        r.f @= f
        return r
      )
    
      local servers @= shared.config.net.servers
      local server @= servers[url.scheme]
      
      if server == null (
        local r @= net.response.NoResponse(url, "scheme '" ++ url.scheme ++ "' not found")
        return r
      )
      
      local resource = url.domain_top
      resource ++= "/"
      if url.domain_sub != null (
        resource ++= url.domain_sub
        resource ++= "."
      )
      resource ++= url.domain_name
      if url.resource != null (
        resource ++= "/"
        resource ++= url.resource
      )
      
      local tld = server.tlds[url.domain_top]
      
      if tld == null (
        local r @= net.response.NoResponse(url, "tld '" ++ url.domain_top ++ "' not found")
        return r
      )
      
      local realUrl = tld ++ "/" ++ resource
      
      local r @= net.response.ValidResponse(url)
      r.fetch @= def() -> (
        local o = self.realUrl.getAsync()
        if o != "Loading" and o != "404: Not Found" (
          self.content = o
          self.isFinished = true
        )
      )
      r.realUrl = realUrl
      
      return r
    )
  )
  return __imports__d974ce5692d372884f5c4f8f8bf1ab18
case "./src/shared/save.osl"
  class __imports__adb9c40aa8851930265661f644c37fb1 (
    def setName(string name) (
      save name "set_directory"
    )
    
    def exists(string fileName) (
      return fileName.saveExists()
    )
    
    def get(string fileName) (
      if !self.exists(fileName) (
        throw fileName ++ "does not exist"
      )
    
      return fileName.saveGet().toStr()
    )
    
    def set(string fileName, string data) (
      save fileName "set" data
    )
  )
  return __imports__adb9c40aa8851930265661f644c37fb1
case "./src/shared/settings.osl"
  class __imports__b9d870002d9a38c65f33053e346a5da3 (
    object entries = {
      devtools: {
        dockside: {
          type: "string",
          desc: "what side devtools is anchored to",
          default: "r",
          applySetting: def(string value) -> (
            devtools.main.anchor = value
          )
        }
      }
    }
    
    object _data = {}
    
    def load() (
      local br @= shared.config.browser
      void shared.save.setName(br.name ++ "@" ++ br.save_developer)
      if !shared.save.exists("settings.json") (
        void self.write()
      )
      self._data @= self.deserialize(shared.save.get("settings.json"))
      void self.applySettings()
    )
    
    def write() (
      void shared.save.set("settings.json", self.serialize())
    )
    
    def get(string category, string entry) (
      return self._data[category][entry]
    )
    def set(string category, string entry, value) (
      local entryData @= self.entries[category][entry]
      if entryData == null (
        throw "setting" + category ++ "/" ++ entry + "doesnt exist"
      )
      
      if entryData.type != typeof(value) (
        throw "expected" + entry.type + "for" + category ++ "/" ++ entry + "but got" + typeof(value)
      )
      self._data[category][entry] @= value
      void self.write()
      void self.applySettings()
    )
    
    def applySettings() (
      local categoryData @= self.entries.getEntries()
      for categoryI categoryData.len (
        local category @= categoryData[categoryI]
        local entryData @= category[2].getEntries()
        for entryI entryData.len (
          local entry @= entryData[entryI]
          local value = self._data[category[1]][entry[1]] ?? entry[2].default
          if entry[2].applySetting != null (
            void entry[2].applySetting(value)
          )
        )
      )
    )
    
    def serialize() (
      local out @= {}
      local categoryData @= self.entries.getEntries()
      for categoryI categoryData.len (
        local category @= categoryData[categoryI]
        out[category[1]] @= {}
        local entryData @= category[2].getEntries()
        for entryI entryData.len (
          local entry @= entryData[entryI]
          local value = self._data[category[1]][entry[1]] ?? entry[2].default
          out[category[1]][entry[1]] @= value
        )
      )
      return out.JsonStringify()
    )
    def deserialize(string data) (
      local raw @= data.JsonParse()
      
      local out @= {}
      local categoryData @= self.entries.getEntries()
      for categoryI categoryData.len (
        local category @= categoryData[categoryI]
        out[category[1]] @= {}
        local entryData @= category[2].getEntries()
        for entryI entryData.len (
          local entry @= entryData[entryI]
          local value = raw[category[1]][entry[1]] ?? entry[2].default
          out[category[1]][entry[1]] @= value
        )
      )
      return out
    )
  )
  return __imports__b9d870002d9a38c65f33053e346a5da3
case "./src/shared/input.osl"
  class __imports__f477f9b400e164d253c3bfeb6a54c186 (
    boolean rwlLeftClick = false
    
    def reset() (
      self.rwlLeftClick = false
    )
    
    def update() (
      self.leftClick = mouse_left and !self.leftDown
      self.leftDown = mouse_left
      if self.leftClick (
        self.rwlLeftClick = true
      )
      
      // TODO: make a keybind system?
      if "`".onKeyDown() (
        devtools.main.open = !devtools.main.open
      )
    )
  )
  return __imports__f477f9b400e164d253c3bfeb6a54c186
case "./src/shared/tab_worker.osl"
  class __imports__ed11349f32bd7389fac05d89b56e016d (
    def oncreate() (
      
    )
    
    def onframe() (
      if self.parseText != null (
        local parser @= rwl.ast.Parser(self.parseText)
        if self != null (
          //log self
          void self.document.loadAst(parser.parse())
          self.parseText = null
        )
      )
      if self.document != null (
        void self.document.rwlInst.interactUpdate({
          rtr: self.document.rtrInst
        })
        void self.document.rtrUpdate()
        //void self.document.rwlInst.checkElemUpdate()
        local mods @= self.document.rtrInst.modules.getValues()
        for i mods.len (
          void mods[i].runEventQueue()
        )
      )
    )
  )
  return __imports__ed11349f32bd7389fac05d89b56e016d
case "./src/shared/config.osl"
  class __imports__9f198a2aa8925b082e5f887a2bba9b67 (
    class net (
      servers = {
        //rtr: {
        //  url: "http://localhost:3000/",
        //  
        //  // <server>/<command>
        //  commands: {
        //    tlds: "tlds"
        //  }
        //}
      }
      
      def refresh() (
        for i self.servers.len (
          local s @= self.servers.getValues()[i]
          s.tlds @= (s.url ++ s.commands.tlds).httpGet()
        )
      )
    )
    
    net.refresh()
    
    class url (
      class defaults (
        string scheme = "rtr"
        string name = "unknown"
        string top = "web"
      )
    )
    
    class browser (
      string name = "phosphorus"
      array developers = ["flufi"]
      string version = "1.0.0a"
      
      // browserName@developer
      string save_developer = "rotur"
      
      class phosphorus (
        string version = "1.0.0a"
        
        boolean usesCanvas = false
      )
    )
  )
  return __imports__9f198a2aa8925b082e5f887a2bba9b67
case "./src/shared/theme.osl"
  class __imports__5876b7f6fcd5ce7f0fafd1a44ec4bd74 (
    def load() (
      self.back = user.theme.background
      self.prim = user.theme.primary
      self.seco = user.theme.secondary
      self.tert = user.theme.tertiary
      self.text = user.theme.text
      self.accent = global_accent
    )
    
    load()
  )
  return __imports__5876b7f6fcd5ce7f0fafd1a44ec4bd74
case "./src/shared/url.osl"
  class __imports__a1d00c2cd890aa6e92598446ff24f924 (
    class Url (
      def init(string text) (
        void self.parse(text)
      )
      
      def parse(string text) (
        self.text = text
        local s @= text.match("/^((\\w+):\\/\\/)/")
        local match @= text.match("/^((\\w+):\\/\\/)?(((\\w+)\\.)?(\\w+)(\\.(\\w+))?\\/?(([\\/w]+)?(\\/(\\w+\\.\\w+))?))\\/?/")
        
        self.scheme = match[3] ?? s[3] ?? shared.config.url.defaults.scheme
        
        if self.scheme == "local" (
          self.domain_name = text.trim("local://".len + 1, -1)
          local usrPath = "origin/(c) users/" ++ username
          if self.domain_name.toLower().startsWith(usrPath.toLower()) (
            self.domain_name = "~" ++ self.domain_name.trim(usrPath.len + 1, -1)
          )
          self.domain_top = null
          self.domain_sub = null
          self.path = null
          self.params @= {}
          self.resource = null
          self.text = "local://" ++ self.domain_name
          return
        )
        
        if match[9] != null (
          local domain_name = match[7]
          local domain_top = match[9]
          local domain_sub = match[6]
        ) else (
          if match[6] != null (
            local domain_name = match[6]
            local domain_top = match[7]
            local domain_sub = null
          ) else (
            local domain_name = match[7]
            local domain_top = null
            local domain_sub = null
          )
        )
        
        self.domain_name = domain_name ?? shared.config.url.defaults.name
        self.domain_top = domain_top ?? shared.config.url.defaults.top
        self.domain_sub = domain_sub
        self.path = match[13]
        self.params @= {}
        self.resource = match[10] ?? "index.rwl"
      )
      
      def format() (
        local sub = self.domain_sub != null ? self.domain_sub ++ "." ""
        local top = self.domain_top != null ? "." ++ self.domain_top ""
        local txt = self.scheme ++ "://" ++ sub ++ domain_name ++ top
        if self.path != null (
          txt ++= "/" ++ self.path
        )
        if self.file_name != "index.rwl" (
          txt ++= "/" ++ self.file_name
        )
        return txt
      )
      
      def getTitle() (
        if self.scheme == "local" (
          return self.domain_name.split("/")[-1].split(".")[1]
        )
        return self.domain_name
      )
    )
  )
  return __imports__a1d00c2cd890aa6e92598446ff24f924
case "./src/shared/tab.osl"
  class __imports__0ffc38803b2c8e6e0623c0ea1ffbcc28 (
    class Tab (
      def init(object document) (
        self.document @= document
      )
      
      def redirect(object url) (
        void self.document.loadUrl(url)
      )
    )
  )
  return __imports__0ffc38803b2c8e6e0623c0ea1ffbcc28
case "./src/shared/document.osl"
  class __imports__af13446f70bd7836009892ffef4b5078 (
    class Document (
      def init() (
        void self.createInsts()
        
        self.started = false
        
        void self.createWorker()
      )
      
      def close() (
        void self.killWorker()
      )
      
      def createWorker() (
        //log "create worker"
        void self.killWorker()
        self.worker @= worker(shared.tab_worker)
        self.worker.document @= self
      )
      
      def killWorker() (
        if self.worker != null (
          //log "kill worker"
          void self.worker.kill()
          self.worker = null
        )
      )
      
      def createInsts() (
        self.title = "New Tab"
        if self.url != null (
          self.title = self.url.getTitle()
        )
        self.icon = null
        
        self.rtrInst @= rtr.main.RTR()
        self.rwlInst @= rwl.main.RWL(shared.document.empty, self.rtrInst)
      )
      
      def updateInsts() (
        // inject rwl apis
        void rtr.rwl.addToInst(self, self.rtrInst)
      )
      
      def update(array area) (
        void self.rwlInst.update(area)
      )
      
      def rtrUpdate() (
        if !self.started and self.rwlInst.hasUpdated (
          void self.rtrInst.startModules()
          self.started = true
        )
      )
      
      def render(array area) (
        if self.worker != null (
          self.worker.area @= area
          if !self.worker.alive (
            self.rwlInst.errored = true
            self.rwlInst.errormsg = "tab worker died, check js console"
          )
        )
        
        goto rwl.area.centerX(area) rwl.area.centerY(area)
        square rwl.area.width(area) - 10 rwl.area.height(area) - 10 10 : c#shared.theme.back
        
        if self.loading (
          goto rwl.area.centerX(area) rwl.area.centerY(area)
          direction timer * 720
          icon "sync" .75 : c#shared.theme.text
          direction 90
          return
        )
        
        //log self.rwlInst
        void self.rwlInst.render(area)
      )
      
      def checkResp() (
        if self.resp == null (
          self.loading = false
          return
        )
        
        if self.resp.isFinished (
          if self.resp.isValid (
            self.loading = false
            
            void self.createInsts()
            void self.loadText(self.resp.content)
            
            self.resp = null
          )
        ) else (
          self.loading = true
          void self.resp.update()
        )
      )
      
      def loadAst(object ast) (
        void self.createInsts()
        void self.rwlInst.loadFromAst(ast)
        void self.updateInsts()
        self.started = false
      )
      
      def loadText(string text) (
        void self.createWorker()
        self.worker.parseText = text
      )
      
      def loadUrl(object url) (
        self.url @= url
        void self.createInsts()
        self.resp @= net.fetch.url(url)
      )
      
      def getIcon() (
        return self.icon
      )
      def getTitle() (
        return self.title
      )
    )
    
    def init() (
      local parser @= rwl.ast.Parser(import("./src/assets/empty.rwl"))
      self.empty @= parser.parse()
    )
  )
  return __imports__af13446f70bd7836009892ffef4b5078
case "./src/shared/utils.osl"
  class __imports__ace3e4fea1b83d3f4a6cf8da09fee544 (
    def removeIndents(str) (
      local lines @= str.split("\n")
      local indent = null
      for i lines.len (
        local l2 = lines[i].match("/^( *)(.+)$/")
        if l2[2].len > 0 (
          indent = min(indent ?? 9999, l2[2].len)
        )
      )
      for i lines.len (
        lines[i] = lines[i].trim(indent + 1, -1)
      )
      return lines.join("\n")
    )
    
    def jsFunc(string js) (
      local f @= js.eval()
      local f2 @= () -> ()
      f2.code @= f
      return f2
    )
  )
  return __imports__ace3e4fea1b83d3f4a6cf8da09fee544
case "./src/shared/graphics.osl"
  class __imports__8840a5e065c53e817186a2216f863bca (
    _canvasID = null
    _canvas = null
    
    def init() (
      if shared.config.browser.phosphorus.usesCanvas (
        self._canvasID = OuidNew()
        self._canvas @= shared.canvas.createCanvas(self._canvasID, window.width, window.height)
        log self
      )
    )
    
    // cursor
    cursor_x = 0
    cursor_y = 0
    def goto(number x, number y) (
      self.cursor_x = x
      self.cursor_y = y
    )
    
    def change_x(number x) (
      self.cursor_x += x
    )
    def change_y(number y) (
      self.cursor_y += y
    )
    def change(number x, number y) (
      self.cursor_x += x
      self.cursor_y += y
    )
    
    // utils
    def getTextWidth(string text) (
      return text.len
    )
    
    // rendering
    def box(array area, string color) (
      c color
      pen "size" 1
      goto area[1] area[2]
      pen "down"
      goto area[3] area[2]
      goto area[3] area[4]
      goto area[1] area[4]
      goto area[1] area[2]
      pen "up"
    )
    
    def filledBox(array area, rounding, string color) (
      local x = rwl.area.centerX(area)
      local y = rwl.area.centerY(area)
      local w = rwl.area.width(area)
      local h = rwl.area.height(area)
      
      c color
      
      if typeof(rounding) == "number" (
        goto x y
        square w - (rounding * 2) h - (rounding * 2) (rounding * 2)
      ) else if typeof(rounding) == "array" (
        // could rework this to have it be corner - rounding for pos
        // so it would have higher parity with canvas?
        x = round(x)
        y = round(y)
        goto x y
        frame area[1] y + 1 x area[2] (
          local r = min(rounding[1] * 2, min(w, h) / 2)
          square w - r h - r r
        )
        frame x y + 1 area[3] area[2] (
          local r = min(rounding[2] * 2, min(w, h) / 2)
          square w - r h - r r
        )
        frame area[1] area[4] x y (
          local r = min(rounding[3] * 2, min(w, h) / 2)
          square w - r h - r r
        )
        frame x area[4] area[3] y (
          local r = min(rounding[4] * 2, min(w, h) / 2)
          square w - r h - r r
        )
      )
    )
    
    def filledTransparentArea(array area, string color, number opacity) (
      frame area[1] area[4] area[3] area[2] (
        c color
        pen "opacity" opacity
        pen "size" 9999
        goto 0 0
        pen "down"
        pen "up"
      )
    )
    
    def ctext(string text, number size, string color) (
      void ptext(text, self.cursor_x, self.cursor_y, size, color)
    )
    def ptext(string text, number x, number y, number size, string color) (
      goto x y
      text text size : c#color
    )
    
    def cicon(string src, number size, string color) (
      void picon(text, self.cursor_x, self.cursor_y, size, color)
    )
    def picon(string src, number x, number y, number size, string color) (
      goto x y
      icon src size : c#color
    )
  )
  return __imports__8840a5e065c53e817186a2216f863bca
case "./src/rtr/value.osl"
  class __imports__b2506e9c8a1f71d53780de64c11f25a1 (
    class RTRValue (
      def callFunc() (
        throw "cannot call" + self.stringify(true) + "as function"
      )
    
      def getRtrType() (
        throw self.name + "has not implemented getRtrType()"
        return rtr.value.RTRTypeValue({
          name: "?"
        })
      )
    
      def stringify() (
        return "<" ++ self.getRtrType().getName() ++ ">"
      )
      def numbify() (
        return NaN
      )
      def boolify() (
        return true
      )
      def arrify() (
        return []
      )
      def length() (
        return 0
      )
      def getItem(key) (
        return null
      )
      def setItem(key, value) (
        throw "cannot set items on" + self.stringify(true)
      )
      def keys() (
        return []
      )
      def values() (
        return []
      )
      def has(key) (
        return false
      )
      def isEqual(other) (
        return self.getRtrType().isEqual(other.getRtrType())
      )
    )
    
    class RTRTypeValue (
      def init(object data) (
        self.data @= data
      )
      
      def stringify() (
        return self.getName()
      )
      def getName() (
        if self.data.name != null (
          return self.data.name
        )
        return "?"
      )
      def isEqual(object other) (
        return self.data.name == other.data.name
      )
    )
    
    class RTRLiteralValue extends RTRValue (
      boolean isLiteral = true
    )
    
    class RTRStrValue extends RTRLiteralValue (
      def init(string value) (
        self.value @= value
      )
      
      def getRtrType() (
        return rtr.value.RTRTypeValue({
          name: "str"
        })
      )
      
      def stringify(format) (
        return format ? self.value.JsonStringify() self.value
      )
      def numbify() (
        return self.value.toNum()
      )
      def boolify() (
        return self.value.len > 0
      )
      def arrify() (
        return self.value.split("").map(e -> rtr.value.RTRStrValue(e))
      )
      def length() (
        return self.value.len
      )
      def getItem(index) (
        return rtr.value.RTRStrValue(self.value[index.numbify() + 1])
      )
      def isEqual(other) (
        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value
      )
    )
    
    class RTRNumValue extends RTRLiteralValue (
      def init(number value) (
        self.value @= value
      )
      
      def getRtrType() (
        return rtr.value.RTRTypeValue({
          name: "num"
        })
      )
      
      def stringify() (
        return self.value.toStr()
      )
      def numbify() (
        return self.value
      )
      def boolify() (
        return self.value > 0
      )
      def arrify() (
        return self.value.toStr().split("").map(e -> rtr.value.RTRStrValue(e))
      )
      def length() (
        return self.value.toStr().length
      )
      def getItem(index) (
        return self.value.toStr()[index.numbify() + 1]
      )
      def isEqual(other) (
        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value
      )
    )
    
    class RTRBoolValue extends RTRLiteralValue (
      def init(boolean value) (
        self.value @= value
      )
      
      def getRtrType() (
        return rtr.value.RTRTypeValue({
          name: "bool"
        })
      )
      
      def stringify() (
        return self.value.toStr()
      )
      def numbify() (
        return self.value.toNum()
      )
      def boolify() (
        return self.value
      )
      def isEqual(other) (
        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value
      )
    )
    
    class RTRColorValue extends RTRLiteralValue (
      def init(string value) (
        self.value @= value
      )
      
      def getRtrType() (
        return rtr.value.RTRTypeValue({
          name: "color"
        })
      )
      
      def stringify() (
        return self.value.toStr()
      )
      def boolify() (
        return !!self.value
      )
      def isEqual(other) (
        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value
      )
    )
    
    class RTRFuncValue extends RTRValue (
      def getRtrType() (
        return rtr.value.RTRTypeValue({
          name: "func"
        })
      )
    )
    
    class RTROslFuncValue extends RTRFuncValue (
      def init(func, extra) (
        self.func @= func
        self.extra @= extra
      )
      
      def callFunc(object inst, array args) (
        return self.func(args, inst, extra) ?? rtr.value.RTRNullValue()
      )
    )
    
    class RTRAstFuncValue extends RTRFuncValue (
      def init(array args, object body) (
        self.args @= args
        self.body @= body
      )
      
      def callFunc(object inst, array args) (
        local s @= {}
        for i self.args.len (
          local a @= self.args[i]
          local v @= args[i] ?? rtr.value.RTRNullValue()
          s[a.name] @= [v, {}]
        )
        
        void inst.newScope(s)
        void inst.declScopeVar("@return", 0)
        
        local exprOut @= inst.runStatement(self.body)
        
        local ret @= inst.getScopeVar("@return") ?? 0
        if ret == 0 (
          ret @= exprOut
        )
        
        void inst.popScope()
        
        return ret
      )
    )
    
    class RTRNullValue extends RTRValue (
      def getRtrType() (
        return rtr.value.RTRTypeValue({
          name: "null"
        })
      )
      
      def boolify() (
        return false
      )
      def isEqual(other) (
        return self.getRtrType().isEqual(other.getRtrType()) and self.value === other.value
      )
    )
    
    class RTRArrValue extends RTRValue (
      def init(array elements) (
        self.elements @= elements
      )
      
      def getRtrType() (
        return rtr.value.RTRTypeValue({
          name: "arr"
        })
      )
      
      def stringify() (
        local el @= self.elements.map(e -> e.stringify(true))
        return "[" ++ el.join(", ") ++ "]"
      )
      def boolify() (
        return self.elements.len > 0
      )
      def arrify() (
        return self.elements
      )
      def length() (
        return self.elements.len
      )
      def keys() (
        local arr2 @= []
        for i self.elements.len (
          void arr2.append(i - 1)
        )
        return arr2
      )
      def values() (
        return self.elements
      )
      def getItem(index) (
        return self.elements[index.numbify() + 1]
      )
      // setItem
    )
    
    class RTRObjValue extends RTRValue (
      def init(object value) (
        self.value @= value
      )
      
      def getRtrType() (
        return rtr.value.RTRTypeValue({
          name: "obj"
        })
      )
      
      def stringify() (
        local el @= self.value.getEntries().map(e -> e[1] ++ ":" + e[2].stringify(true))
        return "{" ++ el.join(", ") ++ "}"
      )
      def boolify() (
        return self.value.getKeys().len > 0
      )
      def arrify() (
        return self.value.getKeys().map(e -> rtr.value.RTRStrValue(e))
      )
      def length() (
        return self.value.getKeys().len
      )
      def keys() (
        return self.value.getKeys()
      )
      def values() (
        return self.value.getValues()
      )
      def has(key) (
        return self.value.getKeys().contains(key)
      )
      def getItem(key) (
        return self.value[key.stringify()]
      )
      def setItem(key, value) (
        self.value[key.stringify()] @= value
      )
    )
  )
  return __imports__b2506e9c8a1f71d53780de64c11f25a1
case "./src/rtr/error.osl"
  class __imports__a51b04c580d521af176787ba84843c9a (
    object Editors = {
    
    }
    
    class Error (
      boolean isError = true
      
      def init(string type, object data) (
        self.type = type
        self.data @= data
        
        local err @= rwl.error.Errors[type]
        if err == null (
          self.txt = "unknown error type" + type
          return
        )
        self.txt = err(data)
      )
      
      def stringify() (
        return "Error<" ++ self.type ++ ">:\n" ++ self.txt.split("\n").map(l -> "    " ++ l).join("\n")
      )
    )
  )
  return __imports__a51b04c580d521af176787ba84843c9a
case "./src/rtr/ast.osl"
  class __imports__2691a00e099698fa56c4748f2551eb65 (
    class Parser (
      def init(string text) (
        void self.tokenise(text)
      )
      
      def parse() (
        self.pointer = 1
        
        local out @= self.blockContent(true)
        
        if !self.atEnd() (
          throw "unexpected token" + self.peek()
        )
        
        return { elements: out }
      )
      
      def peek(amount) (
        amount ??= 1
        return self.tokens[self.pointer + amount - 1]
      )
      def consume() (
        local tkn = self.peek()
        self.pointer ++
        return tkn
      )
      def consumeWhitespace() (
        while self.peek().match("/^\\s$/") != null (
          void self.consume()
        )
      )
      def atEnd() (
        return self.pointer >= self.tokens.len
      )
      def expect(string token) (
        local tkn @= self.consume()
        if tkn != token (
          throw "expected '" ++ token ++ "' got '" ++ tkn ++ "'"
        )
        return tkn
      )
      def expects(array tokens) (
        local tkn @= self.consume()
        if !tokens.contains(tkn) (
          throw "expected '" ++ tokens.join(" or ") ++ "' got '" ++ tkn ++ "'"
        )
        return tkn
      )
      def expectText() (
        local tkn @= self.consume()
        if !tkn.match("/^[a-zA-Z_0-9]+$/") (
          throw "identifier must consist of letters or _"
        )
        return tkn
      )
      def getPos() (
        local ln = 1
        local col = 0
        local i = self.pointer
        for t self.pointer (
          col ++
          if self.tokens[t] == "\n" (
            ln ++
            col = 0
          )
        )
        return { ln, col, i }
      )
      
      def tokenise(string text) (
        self.tokens @= []
        local splitChars @= [
          "(",")",
          "[","]",
          "{","}",
          ",",";",":","=",".","#",
          "+","-","*","/","%","^",
          "\\",
          "'","\"","`",
          " ","\n",
          "!","?"
        ]
        local buf = ""
        for i text.len (
          if splitChars.contains(text[i]) (
            if buf.len > 0 (
              void self.tokens.append(buf)
            )
            void self.tokens.append(text[i])
            buf = ""
          ) else (
            buf ++= text[i]
          )
        )
        if buf.len > 0 (
          self.tokens.append(buf)
        )
      )
      
      // statements
      def blockContent(top) (
        local statements @= []
        local end = peek() == "}"
        while !end (
          if top (
            local out @= self.topLevelStatement()
          ) else (
            local out @= self.statement()
          )
          if out != null (
            void statements.append(out)
          )
          void self.consumeWhitespace()
          if self.peek() == ";" (
            void self.consume()
          )
          if self.peek() == "}" or self.atEnd() (
            end = true
          )
        )
        return statements
      )
      
      def topLevelStatement() (
        void self.consumeWhitespace()
        
        if self.peek() == "event" (
          return self.event()
        )
        
        throw "unexpected token '" ++ self.peek() ++ "'"
      )
      
      def event() (
        local start @= self.getPos()
        void self.expect("event")
        void self.consumeWhitespace()
        void self.expect("(")
        void self.consumeWhitespace()
        local target @= self.eventTarget()
        void self.consumeWhitespace()
        void self.expect(")")
        void self.consumeWhitespace()
        local body @= self.block()
        
        return {
          kind: "event",
          target,
          body,
          start, end: self.getPos()
        }
      )
      
      def statement(noSemicolon) (
        void self.consumeWhitespace()
        
        // statements
        if self.peek() == "{" (
          local start @= self.getPos()
          local body @= self.block()
          return {
            kind: "block",
            body,
            start, end: self.getPos()
          }
        )
        
        if self.peek() == "if" (
          local start @= self.getPos()
          void self.consume()
          void self.consumeWhitespace()
          void self.expect("(")
          local ifCond @= self.expression()
          void self.expect(")")
          void self.consumeWhitespace()
          local ifBody @= self.statement()
          
          local elifs @= []
          
          void self.consumeWhitespace()
          while self.peek() == "elif" (
            void self.consume()
            void self.consumeWhitespace()
            void self.expect("(")
            local elifCond @= self.expression()
            void self.expect(")")
            void self.consumeWhitespace()
            local elifBody @= self.statement()
            
            void elifs.append({
              cond: elifCond,
              body: elifBody
            })
            void self.consumeWhitespace()
          )
          
          local elseBody = null
          void self.consumeWhitespace()
          if self.peek() == "else" (
            void self.consume()
            void self.consumeWhitespace()
            local elseBody @= self.statement()
          )
          
          return {
            kind: "branch",
            cond: ifCond,
            body: ifBody,
            elifs,
            elseBody,
            start, end: self.getPos()
          }
        )
        
        if ["while","until"].contains(self.peek()) (
          local start @= self.getPos()
          local kind @= self.consume()
          void self.consumeWhitespace()
          void self.expect("(")
          local cond @= self.expression()
          void self.expect(")")
          void self.consumeWhitespace()
          local body @= self.statement()
          
          return {
            kind,
            cond,
            body,
            start, end: self.getPos()
          }
        )
        
        if self.peek() == "repeat" (
          local start @= self.getPos()
          void self.consume()
          void self.consumeWhitespace()
          void self.expect("(")
          local amount @= self.expression()
          void self.expect(")")
          void self.consumeWhitespace()
          local body @= self.statement()
          
          return {
            kind: "repeat",
            amount,
            body,
            start, end: self.getPos()
          }
        )
        
        if self.peek() == "for" (
          local start @= self.getPos()
          void self.consume()
          void self.consumeWhitespace()
          void self.expect("(")
          local var @= self.expectText()
          void self.consumeWhitespace()
          void self.expect(",")
          void self.consumeWhitespace()
          local arr @= self.expression()
          void self.expect(")")
          void self.consumeWhitespace()
          local body @= self.statement()
          return {
            kind: "for",
            var,
            arr,
            body,
            start, end: self.getPos()
          }
        )
        
        local expr @= self.expression()
        if expr != null (
          void self.consumeWhitespace()
          if !noSemicolon (
            void self.expect(";")
          )
          
          return {
            kind: "expression",
            expr
          }
        ) else (
          throw "unexpected token '" ++ self.peek() ++ "'"
        )
      )
      
      def block() (
        local start @= self.getPos()
        void self.expect("{")
        void self.consumeWhitespace()
        local elements @= self.blockContent()
        void self.consumeWhitespace()
        void self.expect("}")
        return { elements, start, end: self.getPos() }
      )
      
      // event targets
      def eventTarget() (
        local start @= self.getPos()
        
        local target @= self.target()
        
        void self.consumeWhitespace()
        
        if self.peek() == ":" (
          void self.consume()
          local eventName = self.expectText()
          return {
            kind: "property",
            target,
            eventName,
            start, end: self.getPos()
          }
        )
        
        self.pointer = start.i
        
        return {
          kind: "global",
          target: self.expectText(),
          start, end: self.getPos()
        }
      )
      
      // targets
      def target() (
        local start @= self.getPos()
        
        if self.peek() == "*" (
          void self.consume()
          return {
            kind: "any"
          }
        )
        
        local kind = "element"
        
        if self.peek() == "#" (
          void self.consume()
          void self.consumeWhitespace()
          kind = "id"
        )
        
        local name = self.expectText()
        
        return {
          kind,
          name
        }
      )
      
      // expressions
      def expression() (
        return self.declare()
      )
      
      def declare() (
        if self.peek().match("/^[a-zA-Z_]\\w*$/") != null (
          local start @= self.getPos()
          local ptr = self.pointer
          local tar = self.consume()
          void self.consumeWhitespace()
          if self.peek() == ":" and self.peek(2) == "=" (
            void self.consume()
            void self.consume()
            void self.consumeWhitespace()
            
            local val @= self.expression()
            
            return {
              kind: "decl",
              tar,
              val,
              start, end: self.getPos()
            }
          )
          self.pointer = ptr
        )
        
        return self.assignment()
      )
      
      def assignment() (
        local start @= self.getPos()
        local expr @= self.equality()
        void self.consumeWhitespace()
        
        local op = null
        
        if self.peek() ++ self.peek(2) == "??" and self.peek(3) == "=" (
          op = self.peek() ++ self.peek(2)
        )
        
        if self.peek(2) == "=" and ["+","-","*","/","%","^"].contains(self.peek()) (
          op = self.peek()
        )
        
        if op != null or self.peek() == "=" (
          if op != null (
            loop op.len (
              void self.consume()
            )
          )
          void self.consume()
          void self.consumeWhitespace()
          
          local val @= self.expression()
          
          return {
            kind: "asi",
            op,
            tar: expr,
            val,
            start, end: self.getPos()
          }
        )
        
        return expr
      )
      
      def equality() (
        local expr @= self.comparison()
        void self.consumeWhitespace()
        
        while ["==","!="].contains(self.peek() ++ self.peek(2)) (
          local op @= self.consume() ++ self.consume()
          local right @= self.comparison()
          expr @= {
            kind: "binary",
            op,
            left: expr,
            right
          }
        )
        
        return expr
      )
      
      def comparison() (
        local expr @= self.term()
        
        local end = false
        while !end (
          void self.consumeWhitespace()
          if [">","<"].contains(self.peek()) (
            local op @= self.consume()
            local isEql = self.peek() == "="
            if isEql (
              op ++= self.consume()
            )
            
            local right @= self.factor()
            
            expr @= {
              kind: "binary",
              op,
              left: expr,
              right
            }
          ) else (
            end = true
          )
        )
        
        return expr
      )
      
      def term() (
        local expr @= self.factor()
        void self.consumeWhitespace()
        
        while ["+","-"].contains(self.peek()) and self.peek(2) != "=" (
          local op @= self.consume()
          local right @= self.factor()
          expr @= {
            kind: "binary",
            op,
            left: expr,
            right
          }
          void self.consumeWhitespace()
        )
        
        return expr
      )
      
      def factor() (
        local expr @= self.otherBinary()
        void self.consumeWhitespace()
        
        while ["*","/"].contains(self.peek()) and self.peek(2) != "=" (
          local op @= self.consume()
          local right @= self.otherBinary()
          expr @= {
            kind: "binary",
            op,
            left: expr,
            right
          }
          void self.consumeWhitespace()
        )
        
        return expr
      )
      
      def otherBinary() (
        local expr @= self.coalescence()
        void self.consumeWhitespace()
        
        while ["%","^"].contains(self.peek()) and self.peek(2) != "=" (
          local op @= self.consume()
          local right @= self.coalescence()
          expr @= {
            kind: "binary",
            op,
            left: expr,
            right
          }
          void self.consumeWhitespace()
        )
        
        return expr
      )
      
      def coalescence() (
        local expr @= self.unary()
        void self.consumeWhitespace()
        
        while self.peek() ++ self.peek(2) == "??" and self.peek(3) != "=" (
          local op @= self.consume() ++ self.consume()
          local right @= self.unary()
          expr @= {
            kind: "binary",
            op,
            left: expr,
            right
          }
          void self.consumeWhitespace()
        )
        
        return expr
      )
      
      def unary() (
        if self.peek(2) != "=" (
          switch self.peek() (
            case "-"; case "+"; case "!"; case "?"
              return {
                kind: "unary",
                type: self.consume(),
                expr: self.expression()
              }
          )
        )
        
        return self.callExpr()
      )
      
      def callExpr() (
        local start @= self.getPos()
        local expr @= self.func()
        
        if self.peek() == "(" (
          void self.consume()
          
          local args @= []
          local end = self.peek() == ")"
          while !end (
            local out @= self.expression()
            if out != null (
              void args.append(out)
            )
            void self.consumeWhitespace()
            if self.peek() == "," (
              void self.consume()
            )
            void self.consumeWhitespace()
            if self.peek() == ")" or self.atEnd() (
              end = true
            )
          )
          void self.expect(")")
          
          return {
            kind: "call",
            args,
            func: expr,
            start, end: self.getPos()
          }
        )
        
        return expr
      )
      
      def func() (
        local start @= self.getPos()
        
        local is = false
        if self.peek() == "(" (
          local end = false
          local depth = 0
          while !end (
            local tkn @= self.consume()
            if tkn == "(" (
              depth ++
            )
            if tkn == ")" (
              depth --
            )
            
            if tkn == ")" and depth == 0 (
              end = true
              is = true
            )
            if self.atEnd() (
              end = true
            )
          )
        )
        void self.consumeWhitespace()
        if is and self.peek() == "~" (
          self.pointer = start.i
          
          local args @= []
          void self.consume()
          void self.consumeWhitespace()
          local end = self.peek() == ")"
          if self.peek() == ")" (
            void self.consume()
          )
          while !end (
            local tkn @= self.expectText()
            void args.append({
              name: tkn
            })
            
            void self.consumeWhitespace()
            local ntkn = self.expects([",",")"])
            void self.consumeWhitespace()
            if ntkn == ")" or self.atEnd() (
              end = true
            )
          )
          void self.consumeWhitespace()
          void self.expect("~")
          void self.consumeWhitespace()
          local body @= self.statement(true)
          return {
            kind: "func",
            args,
            body,
            start, end: self.getPos()
          }
        )
        self.pointer = start.i
        
        return self.objProperty()
      )
      
      def objProperty() (
        local expr @= self.primary()
        void self.consumeWhitespace()
        
        while (self.peek() == "[" or self.peek() == ".") and !self.atEnd() (
          if self.peek() == "[" (
            void self.consume()
            local key @= self.expression()
            void self.expect("]")
          ) else if self.peek() == "." (
            void self.consume()
            local key @= self.expectText()
          ) else (
            throw "unexpected token '" ++ self.peek() ++ "'"
          )
          expr @= {
            kind: "prop",
            obj: expr,
            key
          }
          if self.peek() == "(" (
            void self.consume()
            
            local args @= []
            local end = self.peek() == ")"
            while !end (
              local out @= self.expression()
              if out != null (
                void args.append(out)
              )
              void self.consumeWhitespace()
              if self.peek() == "," (
                void self.consume()
              )
              void self.consumeWhitespace()
              if self.peek() == ")" or self.atEnd() (
                end = true
              )
            )
            void self.expect(")")
            
            expr @= {
              kind: "call",
              args,
              func: expr
            }
          )
          void self.consumeWhitespace()
        )
        
        return expr
      )
      
      def primary() (
        void self.consumeWhitespace()
        
        if self.peek() == "(" (
          void self.consume()
          local expr @= self.expression()
          void self.expect(")")
          return expr
        )
        
        if self.peek() == "[" (
          return self.arr()
        )
        
        if self.peek() == "{" (
          return self.obj()
        )
        
        if ["'","\"","`"].contains(self.peek()) (
          return self.str()
        )
        
        if self.peek().match("/^[0-9]+$/") != null (
          return self.num()
        )
        
        if self.peek().match("/^[a-zA-Z_]\\w*$/") != null (
          local start @= self.getPos()
          return {
            kind: "var",
            name: self.consume(),
            start, end: self.getPos()
          }
        )
        
        throw "unexpected token '" ++ self.peek() ++ "'"
      )
      
      def obj() (
        void self.expect("{")
        void self.consumeWhitespace()
        
        local pairs @= []
        
        local end = self.peek() == "}"
        while !end (
          void self.consumeWhitespace()
          local name @= self.expectText()
          void self.consumeWhitespace()
          void self.expect(":")
          void self.consumeWhitespace()
          local value @= self.expression()
          
          void pairs.append({ name, value })
          
          void self.consumeWhitespace()
          if self.peek() == "}" (
            end = true
          ) else (
            void self.expect(",")
          )
        )
        void self.expect("}")
        
        return {
          kind: "obj",
          pairs
        }
      )
      
      def arr() (
        void self.expect("[")
        
        local elems @= []
        
        local end = self.peek() == "]"
        while !end (
          local expr @= self.expression()
          void elems.append(expr)
          
          void self.consumeWhitespace()
          if self.peek() == "]" or self.atEnd() (
            end = true
          ) else (
            void self.expect(",")
          )
          void self.consumeWhitespace()
        )
        
        void self.expect("]")
        
        return {
          kind: "arr",
          elems
        }
      )
      
      def str() (
        local start @= self.getPos()
        local q @= self.expects(["'","\"","`"])
        local content = ""
        local end = false
        while (!end) (
          local tkn @= self.peek()
          if tkn == "\\" (
            void self.consume()
            local tkn = self.consume()
            local char = tkn[1]
            switch char (
              case "n"
                char = "\n"
                break
            )
            content ++= char ++ tkn.trim(2,-1)
            continue
          )
          
          if q == tkn (
            end = true
          ) else (
            content ++= self.consume()
          )
          if self.atEnd() (
            end = true
          )
        )
        void self.expect(q)
        return {
          kind: "str",
          val: content,
          start, end: self.getPos()
        }
      )
      
      def num() (
        if self.peek().match("/^[0-9]+$/") == null (
          throw "unexpected token '" ++ self.peek() ++ "'"
        )
        
        local start @= self.getPos()
        local val @= self.consume()
        
        if self.peek() == "." (
          val ++= self.consume()
          if self.peek().match("/^[0-9]+$/") == null (
            throw "unexpected token '" ++ self.peek() ++ "'"
          )
          val ++= self.consume()
        )
        
        val @= val.toNum()
        
        return {
          kind: "num",
          val,
          start, end: self.getPos()
        }
      )
    )
  )
  return __imports__2691a00e099698fa56c4748f2551eb65
case "./src/rtr/main.osl"
  class __imports__954b63a69b7120a02fa83923726ef587 (
    class Module (
      def init(object ast) (
        void self.loadFromAst(ast)
        void self.initScope()
        void self.defScope()
        self.eventQueue @= []
      )
      def loadFromAst(object ast) (
        self.ast @= ast
        
        self.events @= []
        self.eventList @= []
        for i self.ast.elements.len (
          local topLevel @= self.ast.elements[i]
          if topLevel.kind == "event" (
            if topLevel.target.kind == "global" (
              if self.eventList.contains(topLevel.target.target) (
                throw topLevel.target.target + "event already exists on module"
              )
              void self.eventList.append(topLevel.target.target)
            )
            void self.events.append([
              topLevel.target,
              topLevel
            ])
          )
        )
      )
      
      def initScope() (
        self.scope @= []
      )
      def newScope(object vars) (
        void self.scope.append(vars)
      )
      def popScope() (
        return self.scope.pop()
      )
      def defScope() (
        // helper funcs
        local cFunc @= def(name, content) -> (
          void self.setScopeVar(name, rtr.value.RTROslFuncValue(content))
        )
        
        void self.newScope({})
        
        void self.setScopeVar("true", rtr.value.RTRBoolValue(true))
        void self.setScopeVar("false", rtr.value.RTRBoolValue(false))
        
        cFunc("log", def(args, inst) -> (
          local txt = args.map(a -> a.stringify()).join(" ")
          log txt
          void inst.inst.console.append(["log", txt])
        ))
        cFunc("error", def(args, inst) -> (
          local txt = args.map(a -> a.stringify()).join(" ")
          void inst.inst.console.append(["err", txt])
          throw txt
        ))
        cFunc("return", def(args, inst) -> (
          local val @= args[1]
          val ??= rtr.value.RTRNullValue()
          void inst.setScopeVar("@return", val)
        ))
        cFunc("typeof", def(args) -> (
          local val @= args[1] ?? rtr.value.RTRNullValue()
          return val.getRtrType()
        ))
        cFunc("length", def(args) -> (
          return rtr.value.RTRNumValue(args[1].length())
        ))
        
        // mathematical
        cFunc("min", def(args) -> (
          local v = args[1].numbify()
          for i args.len - 1 (
            local a @= args[i + 1].numbify()
            v = min(v, a)
          )
          return rtr.value.RTRNumValue(v)
        ))
        cFunc("max", def(args) -> (
          local v = args[1].numbify()
          for i args.len - 1 (
            local a @= args[i + 1].numbify()
            v = max(v, a)
          )
          return rtr.value.RTRNumValue(v)
        ))
        
        cFunc("abs", def(args) -> (
          return rtr.value.RTRNumValue(args[1].numbify().abs())
        ))
        cFunc("sqrt", def(args) -> (
          return rtr.value.RTRNumValue(args[1].numbify().sqrt())
        ))
        
        cFunc("round", def(args) -> (
          return rtr.value.RTRNumValue(args[1].numbify().round())
        ))
        cFunc("floor", def(args) -> (
          return rtr.value.RTRNumValue(args[1].numbify().floor())
        ))
        cFunc("ceil", def(args) -> (
          return rtr.value.RTRNumValue(args[1].numbify().ceiling())
        ))
        
        // string
        cFunc("join", def(args) -> (
          local txt = ""
          for i args.len (
            txt ++= args[i].stringify()
          )
          return rtr.value.RTRStrValue(txt)
        ))
        cFunc("split", def(args) -> (
          return rtr.value.RTRArrValue(args[1]
            .stringify()
            .split(args[2].stringify())
            .map(e -> rtr.value.RTRStrValue(e)))
        ))
        
        cFunc("chr", def(args) -> (
          return rtr.value.RTRStrValue(args[1].numbify().chr())
        ))
        cFunc("ord", def(args) -> (
          return rtr.value.RTRNumValue(args[1].stringify().ord())
        ))
        
        // array
        cFunc("item", def(args) -> (
          return args[1].getItem(args[2])
        ))
        cFunc("range", def(args) -> (
          return rtr.value.RTRArrValue((args[1].numbify() to args[2].numbify()).map(e -> rtr.value.RTRNumValue(e)))
        ))
        
        // object
        cFunc("keys", def(args) -> (
          return rtr.value.RTRArrValue(args[1].keys().map(e -> rtr.value.RTRStrValue(e)))
        ))
        cFunc("values", def(args) -> (
          return rtr.value.RTRArrValue(args[1].values())
        ))
        cFunc("has", def(args) -> (
          return rtr.value.RTRBoolValue(args[1].has(args[2].stringify()))
        ))
        cFunc("obj", def() -> (
          return rtr.value.RTRObjValue({})
        ))
        
        // logical
        cFunc("all", def(args) -> (
          return rtr.value.RTRBoolValue(args.every(a -> a.boolify()))
        ))
        cFunc("any", def(args) -> (
          return rtr.value.RTRBoolValue(args.some(a -> a.boolify()))
        ))
        cFunc("not", def(args) -> (
          return rtr.value.RTRBoolValue(!args[1].boolify())
        ))
      )
      def getScopeVarRaw(string key) (
        for rawI self.scope.len (
          local layer @= self.scope[self.scope.len - rawI + 1]
          if layer[key] != null (
            return layer[key]
          )
        )
        return null
      )
      def getScopeVar(string key) (
        return self.getScopeVarRaw(key)[1]
      )
      def getScopeVarMeta(string key) (
        return self.getScopeVarRaw(key)[2]
      )
      def setScopeVar(string key, val, meta) (
        meta ??= {}
        for rawI self.scope.len (
          local layer @= self.scope[self.scope.len - rawI + 1]
          if layer[key] != null (
            layer[key] @= [val, layer[key][2] ++ meta]
            return
          )
        )
        void self.declScopeVar(key, val, meta)
      )
      def declScopeVar(string key, val, meta) (
        self.scope[self.scope.len][key] @= [val, meta]
      )
      
      def findEligible(object target) (
        local evs @= []
        
        for i self.events.len (
          local ev @= self.events[i][2]
          
          if target.element != null (
            if ev.target.kind == "property" and ev.target.eventName == target.name (
              if ev.target.target.kind == "id" (
                if ev.target.target.name == target.element.id (
                  void evs.append(ev)
                )
              )
            )
          ) else if typeof(ev.target.target) == "string" (
            if ev.target.target == target.name (
              void evs.append(ev)
            )
          )
        )
        
        return evs
      )
      
      def runEvents(object target, object data) (
        void self.eventQueue.append([
          "events",
          target,
          data
        ])
      )
      def runEvent(object target, object data) (
        void self.eventQueue.append([
          "event",
          target,
          data
        ])
      )
      
      def runEventQueue() (
        for i self.eventQueue.len (
          local ev @= self.eventQueue.shift()
          
          if ev[1] == "events" (
            void self.runEventsRaw(ev[2], ev[3])
          )
          if ev[1] == "event" (
            void self.runEventRaw(ev[2], ev[3])
          )
        )
      )
      
      def runEventsRaw(object target, object data) (
        local evs @= self.findEligible(target)
        
        for i evs.len (
          void self.runBlock(evs[i].body)
        )
      )
      def runEventRaw(object target, object data) (
        local ev @= self.findEligible(target)[1]
        
        if ev == null (
          return rtr.value.RTRNullValue()
        )
        
        return self.runBlock(ev.body)
      )
      def runBlock(object block) (
        local elements @= block.elements
        local outVal @= rtr.value.RTRNullValue()
        void self.newScope({})
        for i elements.len (
          local out @= self.runStatement(elements[i])
          if self.getScopeVar("@return") ?? 0 != 0 (
            outVal @= self.getScopeVar("@return")
            break
          )
        )
        void self.popScope()
        return outVal
      )
      def runStatement(object statement) (
        switch statement.kind (
          case "expression"
            return self.runExpression(statement.expr)
          case "block"
            return self.runBlock(statement.body)
          
          case "branch"
            if self.runExpression(statement.cond).boolify() (
              return self.runStatement(statement.body)
            )
            for i statement.elifs.len (
              local elif @= statement.elifs[i]
              if self.runExpression(elif.cond).boolify() (
                return self.runStatement(elif.body)
              )
            )
            if statement.elseBody != null (
              return self.runStatement(statement.elseBody)
            )
            return rtr.value.RTRNullValue()
          
          case "while"
            local iters = 0
            while self.runExpression(statement.cond).boolify() and self.getScopeVar("@return") ?? 0 == 0 and iters < 999999 (
              void self.runStatement(statement.body)
              iters ++
            )
            return rtr.value.RTRNullValue()
          case "until"
            local iters = 0
            while !self.runExpression(statement.cond).boolify() and self.getScopeVar("@return") ?? 0 == 0 and iters < 999999 (
              void self.runStatement(statement.body)
              iters ++
            )
            return rtr.value.RTRNullValue()
          case "repeat"
            loop self.runExpression(statement.amount).numbify() (
              void self.runStatement(statement.body)
            )
            return rtr.value.RTRNullValue()
          case "for"
            local arr @= self.runExpression(statement.arr).arrify()
            for i arr.len (
              void self.newScope({})
              void self.declScopeVar(statement.var, arr[i])
              void self.runStatement(statement.body)
              void self.popScope()
            )
            return rtr.value.RTRNullValue()
          
          default
            throw "unknown statement type" + statement.kind
        )
      )
      def runExpression(object expression) (
        switch expression.kind (
          case "call"
            local func @= self.runExpression(expression.func)
            local args @= []
            for i expression.args.len (
              void args.append(self.runExpression(expression.args[i]))
            )
            return func.callFunc(self, args) ?? rtr.value.RTRNullValue()
          case "decl"
            local val @= self.runExpression(expression.val)
            
            void self.declScopeVar(expression.tar, val, {
              type: val.getRtrType()
            })
            
            return val
          case "asi"
            local val @= self.runExpression(expression.val)
            
            local existingMeta = null
            local existing = null
            switch expression.tar.kind (
              case "var"
                existingMeta @= self.getScopeVarMeta(expression.tar.name)
                existing @= self.getScopeVar(expression.tar.name)
                break
              case "prop"
                existing @= self.runExpression(expression.tar)
                break
            )
            
            if expression.op != null (
              val @= self.runOperation(existing, expression.op, val)
            )
            
            switch expression.tar.kind (
              case "var"
                if existingMeta != null (
                  local curType @= val.getRtrType()
                  if existingMeta.type != null (
                    if !existingMeta.type.isEqual(curType) (
                      throw "cannot assign" + curType.stringify() + "to" + existingMeta.type.stringify() + "variable" 
                    )
                  )
                )
                void self.setScopeVar(expression.tar.name, val)
                break
              case "prop"
                local obj @= self.runExpression(expression.tar.obj)
                local key @= expression.tar.key
                if typeof(key) == "string" (
                  key @= rtr.value.RTRStrValue(key)
                ) else (
                  key @= self.runExpression(key)
                )
                obj.setItem(key, val)
                break
              default
                throw "cannot assign to" + expression.tar.kind
            )
            
            return val
          case "unary"
            local val @= self.runExpression(expression.expr)
            switch expression.type (
              case "-"
                return rtr.value.RTRNumValue(-val.numbify())
              case "+"
                return rtr.value.RTRNumValue(val.numbify())
              case "!"
                return rtr.value.RTRBoolValue(!val.boolify())
              case "?"
                return rtr.value.RTRBoolValue(val.boolify())
            )
            return rtr.value.RTRNullValue()
          case "binary"
            local left @= self.runExpression(expression.left)
            local right @= self.runExpression(expression.right)
            return self.runOperation(left, expression.op, right)
          case "var"
            local val @= self.getScopeVar(expression.name)
            return val ?? rtr.value.RTRNullValue()
          case "prop"
            local obj @= self.runExpression(expression.obj)
            local key @= expression.key
            if typeof(key) == "string" (
              key @= rtr.value.RTRStrValue(key)
            ) else (
              key @= self.runExpression(key)
            )
            return obj.getItem(key) ?? rtr.value.RTRNullValue()
          
          case "str"
            return rtr.value.RTRStrValue(expression.val)
          case "num"
            return rtr.value.RTRNumValue(expression.val)
          case "func"
            return rtr.value.RTRAstFuncValue(expression.args, expression.body)
          case "arr"
            return rtr.value.RTRArrValue(expression.elems.map(e -> self.runExpression(e)))
          case "obj"
            local val @= {}
            for i expression.pairs.len (
              local pair @= expression.pairs[i]
              val[pair.name] @= self.runExpression(pair.value)
            )
            return rtr.value.RTRObjValue(val)
          
          default
            throw "unknown expression type" + expression.kind
        )
      )
      def runOperation(object left, op, object right) (
        local numT @= rtr.value.RTRNumValue.getRtrType()
        switch op (
          case "+"
            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (
              return rtr.value.RTRNumValue(left.numbify() + right.numbify())
            )
            return rtr.value.RTRStrValue(left.stringify() ++ right.stringify())
          case "-"
            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (
              return rtr.value.RTRNumValue(left.numbify() - right.numbify())
            )
            return rtr.value.RTRNumValue(NaN)
          case "*"
            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (
              return rtr.value.RTRNumValue(left.numbify() * right.numbify())
            )
            return rtr.value.RTRNumValue(NaN)
          case "/"
            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (
              return rtr.value.RTRNumValue(left.numbify() / right.numbify())
            )
            return rtr.value.RTRNumValue(NaN)
          case "%"
            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (
              return rtr.value.RTRNumValue(left.numbify() % right.numbify())
            )
            return rtr.value.RTRNumValue(NaN)
          case "^"
            if left.getRtrType().isEqual(numT) and right.getRtrType().isEqual(numT) (
              return rtr.value.RTRNumValue(left.numbify() ^ right.numbify())
            )
            return rtr.value.RTRNumValue(NaN)
          
          case "=="
            return rtr.value.RTRBoolValue(left.isEqual(right))
          case "!="
            return rtr.value.RTRBoolValue(left.isEqual(right))
          
          case ">"
            return rtr.value.RTRBoolValue(left.numbify() > right.numbify())
          case "<"
            return rtr.value.RTRBoolValue(left.numbify() < right.numbify())
          case ">="
            return rtr.value.RTRBoolValue(left.numbify() >= right.numbify())
          case "<="
            return rtr.value.RTRBoolValue(left.numbify() <= right.numbify())
        
          case "??"
            return left.getRtrType().data.name == "null" ? right left
        )
        
        return rtr.value.RTRNullValue()
      )
    )
    
    class RTR (
      def init() (
        self.modules @= {}
        self.console @= []
        self.ouid = OuidNew()
        
        self.started = false
      )
    
      def addModule(object mod) (
        local key @= OuidNew()
        mod.inst @= self
        self.modules[key] @= mod
        return key
      )
      
      def startModules() (
        if !self.started (
          self.started = true
          void self.runEvent({
           name: "onload"
          }, {})
        )
      )
      
      def runEvent(object target, object data) (
        local mods @= self.modules.getValues()
        for i mods.len (
          void mods[i].runEvent(target, data)
        )
      )
      def runEvents(object target, object data) (
        local mods @= self.modules.getValues()
        for i mods.len (
          void mods[i].runEvents(target, data)
        )
      )
    )
  )
  return __imports__954b63a69b7120a02fa83923726ef587
case "./src/rwl/ast.osl"
  class __imports__823191bbaeb9397e6eaf51c446a37c4c (
    class Parser (
      def init(string text) (
        void self.tokenise(text)
      )
      
      def parse() (
        self.pointer = 1
        
        local out @= {
          elements: self.blockContent()
        }
        
        if !self.atEnd() (
          throw "unexpected token '" ++ self.peek() ++ "'"
        )
        
        return out
      )
      
      def peek() (
        return self.tokens[self.pointer]
      )
      def consume() (
        local tkn = self.peek()
        self.pointer ++
        return tkn
      )
      def consumeWhitespace() (
        while self.peek().match("/^\\s$/") != null (
          void self.consume()
        )
      )
      def consumeSpaces() (
        local txt = ""
        while self.peek() == " " (
          txt ++= self.consume()
        )
        return txt
      )
      def atEnd() (
        return self.pointer >= self.tokens.len
      )
      def expect(string token) (
        local tkn @= self.consume()
        if tkn != token (
          throw "expected '" ++ token ++ "' got '" ++ tkn ++ "'"
        )
        return tkn
      )
      def expects(array tokens) (
        local tkn @= self.consume()
        if !tokens.contains(tkn) (
          throw "expected '" ++ tokens.join(" or ") ++ "' got '" ++ tkn ++ "'"
        )
        return tkn
      )
      def expectText() (
        local tkn @= self.consume()
        if !tkn.match("/^[a-zA-Z_0-9]+$/") (
          throw "identifier must consist of letters or _"
        )
        return tkn
      )
      def getPos() (
        local ln = 1
        local col = 0
        local i = self.pointer
        for t self.pointer (
          col ++
          if self.tokens[t] == "\n" (
            ln ++
            col = 0
          )
        )
        return { ln, col, i }
      )
      
      def tokenise(string text) (
        self.tokens @= []
        local splitChars @= [
          // rwl
          "{","}",
          "[","]",
          ",",
          " ",
          "\n",
          "/","\\","*",
          "'","\"","`",
          ":","#","%","=",
          // rtr
          "(",")",
          "[","]",
          "{","}",
          ",",";",":","=",".",
          "+","-","*","/","%","^",
          "\\",
          "'","\"","`",
          " ","\n",
          "!","?"
        ]
        local buf = ""
        for i text.len (
          if splitChars.contains(text[i]) (
            if buf.len > 0 (
              void self.tokens.append(buf)
            )
            void self.tokens.append(text[i])
            buf = ""
          ) else (
            buf ++= text[i]
          )
        )
        if buf.len > 0 (
          self.tokens.append(buf)
        )
      )
      
      // statements
      def blockContent() (
        local statements @= []
        local end = false
        while !end (
          local out @= self.statement()
          if out != null (
            void statements.append(out)
          )
          void self.consumeWhitespace()
          if self.peek() == "}" or self.atEnd() (
            end = true
          ) else (
            void self.expect(",")
          )
        )
        return statements
      )
      
      def statement() (
        void self.consumeWhitespace()
        
        local start @= self.getPos()
        local tkn @= self.peek()
        
        // void elements
        if ["icon","image"].contains(tkn) (
          void self.consume()
          void self.consumeWhitespace()
          local header @= self.header()
          
          return {
            data: {
              header
            },
            kind: tkn,
            start, end: self.getPos()
          }
        )
        
        // block
        if tkn.match("/^[a-zA-Z]+$/") != null (
          return self.blockStatement()
        )
        
        // element
        local value @= self.value()
        if value != null (
          void self.consumeWhitespace()
          local header @= self.header()
          
          return {
            data: {
              value,
              header
            },
            kind: "element",
            start, end: self.getPos()
          }
        )
      )
      
      def blockStatement() (
        local start @= self.getPos()
        local key @= self.consume()
        
        void self.consumeWhitespace()
        
        local header @= self.header()
        header.key = key
        
        void self.consumeWhitespace()
        
        if key == "script" (
          local content = ""
          local spaceContent = ""
          void self.expect("{")
          local end = false
          local depth = 1
          local stringType = null
          while !end (
            local tkn @= self.peek()
            
            if tkn == "'" (
              if stringType == "'" (
                stringType = null
              ) else if stringType == null (
                stringType = "'"
              )
            )
            
            if tkn == "\"" (
              if stringType == "\"" (
                stringType = null
              ) else if stringType == null (
                stringType = "\""
              )
            )
            
            if tkn == "`" (
              if stringType == "`" (
                stringType = null
              ) else if stringType == null (
                stringType = "`"
              )
            )
            
            if stringType == null (
              if tkn == "{" (
                depth ++
              )
              if tkn == "}" (
                depth --
              )
            )
            
            if self.atEnd() or (tkn == "}" and depth == 0 and stringType == null) (
              end = true
            ) else (
              if tkn == "\n" (
                spaceContent = ""
                void self.consume()
                if content != "" (
                  content ++= "\n"
                )
              ) else if tkn == " " (
                spaceContent ++= self.consume()
              ) else (
                content ++= spaceContent
                content ++= self.consume()
                spaceContent = ""
              )
            )
          )
          void self.expect("}")
        ) else (
          local content @= self.block()
        )
        
        return {
          kind: "block",
          data: {
            header,
            content
          },
          start, end: self.getPos()
        }
      )
      
      def block() (
        local start @= self.getPos()
        void self.expect("{")
        void self.consumeWhitespace()
        local elements @= self.blockContent()
        void self.consumeWhitespace()
        void self.expect("}")
        return { elements, start, end: self.getPos() }
      )
      
      // header stuff
      def header() (
        local start @= self.getPos()
        local attributes @= []
        if self.peek() == "[" (
          void self.expect("[")
          local end = self.peek() == "]"
          while !end (
            local out @= self.headerItem()
            if out != null (
              void attributes.append(out)
            )
            void self.consumeWhitespace()
            if self.peek() == "," (
              void self.consume()
            )
            if self.peek() == "]" or self.atEnd() (
              end = true
            )
          )
          void self.expect("]")
        )
        
        return { attributes, start, end: self.getPos() }
      )
      def headerItem() (
        void self.consumeWhitespace()
        local start @= self.getPos()
        local tkn @= self.consume()
        void self.consumeWhitespace()
        if self.peek() == "=" (
          if tkn.match("/^[a-zA-Z_]+$/") == null (
            throw "attribute key must consist of letters or _"
          )
          void self.consume()
          local value @= self.value()
          return {
            kind: "key",
            key: tkn,
            value,
            start, end: self.getPos()
          }
        )
        if tkn.match("/^[a-zA-Z_]+$/") != null (
          return {
            kind: "flag",
            data: tkn,
            start, end: self.getPos()
          }
        )
      )
      
      // values
      def value() (
        if ["'","\"","`"].contains(self.peek()) (
          return self.str()
        )
        
        if self.peek().match("/^[0-9]+$/") != null (
          return self.num()
        )
        
        if self.peek() == "#" (
          return self.color()
        )
        
        if self.peek().match("/^\\w+$/") != null (
          return self.property()
        )
      )
      
      def str() (
        local start @= self.getPos()
        local q @= self.expects(["'","\"","`"])
        local content = ""
        local end = false
        while (!end) (
          local tkn @= self.peek()
          if tkn == "\\" (
            void self.consume()
            local tkn = self.consume()
            local char = tkn[1]
            switch char (
              case "n"
                char = "\n"
                break
            )
            content ++= char ++ tkn.trim(2,-1)
            continue
          )
          
          if q == tkn (
            end = true
          ) else (
            content ++= self.consume()
          )
          if self.atEnd() (
            end = true
          )
        )
        void self.expect(q)
        return {
          type: "str",
          value: content,
          start, end: self.getPos()
        }
      )
      
      // and percentage
      def num() (
        if self.peek().match("/^[0-9]+$/") == null (
          throw "unexpected token '" ++ self.peek() ++ "'"
        )
        
        local start @= self.getPos()
        
        local value @= self.consume().toNum()
        
        local type = "num"
        
        if self.peek() == "%" (
          void self.consume()
          type = "percentage"
        )
        
        return {
          type,
          value,
          start, end: self.getPos()
        }
      )
      
      def color() (
        local start @= self.getPos()
        void self.expect("#")
        local value = self.consume()
        if ![3,6].contains(value.len) (
          throw "hex values can only be 3 or 6 characters long"
        )
        return {
          type: "color",
          value: "#" ++ value,
          start, end: self.getPos()
        }
      )
      
      def property() (
        local start @= self.getPos()
        local source = self.consume()
        if source.match("/^[a-zA-Z_]+$/") == null (
          throw "source must consist of letters or _"
        )
        
        void self.consumeWhitespace()
        void self.expect(":")
        void self.consumeWhitespace()
        
        local name = self.consume()
        if name.match("/^[a-zA-Z_]+$/") == null (
          throw "name must consist of letters or _"
        )
        
        return {
          type: "property",
          source,
          name,
          start, end: self.getPos()
        }
      )
    )
  )
  return __imports__823191bbaeb9397e6eaf51c446a37c4c
case "./src/rwl/debug.osl"
  class __imports__a02a29842cf0d752bb9291888afe9568 (
    def box(array area, color) (
      if !rwl.main.debug (
        return
      )
      void shared.graphics.box(area, color ?? #f00)
    )
  )
  return __imports__a02a29842cf0d752bb9291888afe9568
case "./src/rwl/value.osl"
  class __imports__b6b9b465fcf5c8c4f9d5fe786e8bce9c (
    class RWLValue (
      
    )
    
    class RWLStrValue extends RWLValue (
      type = "str"
      def init(string value) (
        self.value @= value
      )
    )
    
    class RWLNumValue extends RWLValue (
      type = "num"
      def init(number value) (
        self.value @= value
      )
    )
    
    class RWLPercentageValue extends RWLValue (
      type = "percentage"
      def init(number value) (
        self.value @= value
      )
    )
    
    class RWLColorValue extends RWLValue (
      type = "color"
      def init(string value) (
        self.value @= value
      )
    )
    
    def AstToValue(ast) (
      switch ast.type (
        case "str"
          return rwl.value.RWLStrValue(ast.value)
        case "num"
          return rwl.value.RWLNumValue(ast.value)
        case "percentage"
          return rwl.value.RWLPercentageValue(ast.value)
        case "color"
          return rwl.value.RWLColorValue(ast.value)
        case "property"
          switch ast.source (
            case "theme"
              local col = shared.theme[ast.name]
              if typeof(col) == "string" (
                return rwl.value.RWLColorValue(col)
              )
              break
            default
              return rwl.error.Error("UnknownPropertySource", {
                source: ast.source
              })
          )
          return rwl.error.Error("UnknownProperty", {
            property: ast.name,
            source: ast.source
          })
        default
          return rwl.error.Error("UnknownValueType", {
            valueType: ast.type
          })
      )
    )
  )
  return __imports__b6b9b465fcf5c8c4f9d5fe786e8bce9c
case "./src/rwl/error.osl"
  class __imports__c17b91d805bd65a760423a0b948a2c09 (
    object Errors = {
      UnknownElementKind: def(data) -> (
        return "unknown element kind:" + data.elementKind
      ),
      UnknownAttributeKind: def(data) -> (
        return "unknown attribute kind:" + data.attributeKind
      ),
      
      UnknownValueType: def(data) -> (
        return "unknown value type:" + data.valueType
      ),
      UnknownBlockType: def(data) -> (
        return "unknown block type:" + data.blockType
      ),
      
      InvalidAnchorName: def(data) -> (
        return "unknown anchor name" + data.name
      ),
      InvalidAlignmentName: def(data) -> (
        return "unknown anchor name" + data.name
      ),
      
      InvalidElemType: def(data) -> (
        return "cannot have" + data.valueType + "as element"
      ),
      
      ValueTypeMismatch: def(data) -> (
        if typeof(data.wanted) == "string" (
          data.wanted @= [data.wanted]
        )
        local forCtx = ""
        if data.attr != null (
          forCtx += "for" + data.attr
        )
        return "wanted" + data.wanted.join(" or ") + "got" + data.got ++ forCtx
      ),
      
      UnknownProperty: def(data) -> (
        return "unknown property" + data.property + "on" + data.source
      ),
      UnknownPropertySource: def(data) -> (
        return "unknown source" + data.source
      ),
      
      ElemInFrame: def(data) -> (
        return "element in a frame, only sections are allowed directly in frames"
      ),
      
      NoScriptType: def(data) -> (
        return "no script type attribute"
      ),
      InvalidScriptType: def(data) -> (
        return "unknown script type" + data.type
      ),
      InvalidScriptAttrType: def(data) -> (
        return "unknown script type attribute type" + data.type
      ),
      
      NoIconSrc: def(data) -> (
        return "icon has no src"
      )
    }
    
    class Error (
      boolean isError = true
      
      def init(string type, object data) (
        self.type = type
        self.data @= data
        
        local err @= rwl.error.Errors[type]
        if err == null (
          self.txt = "unknown error type" + type
          return
        )
        self.txt = err(data)
      )
      
      def stringify() (
        return "Error<" ++ self.type ++ ">:\n" ++ self.txt.split("\n").map(l -> "    " ++ l).join("\n")
      )
    )
  )
  return __imports__c17b91d805bd65a760423a0b948a2c09
case "./src/rwl/area.osl"
  class __imports__51b19cf190821eee598f3dc8fa9be944 (
    def copy(area) (
      return [area[1], area[2], area[3], area[4]]
    )
    
    def centerX(area) (
      return area[1] + area[3] / 2
    )
    
    def centerY(area) (
      return area[2] + area[4] / 2
    )
    
    def width(area) (
      return area[3] - area[1]
    )
    
    def height(area) (
      return area[4] - area[2]
    )
    
    def pad(area, pad) (
      return [
        area[1] + pad[1],
        area[2] + pad[2],
        area[3] - pad[3],
        area[4] - pad[4]
      ]
    )
    
    def margin(area, mar) (
      return [
        area[1] - mar[1],
        area[2] - mar[2],
        area[3] + mar[3],
        area[4] + mar[4]
      ]
    )
  )
  return __imports__51b19cf190821eee598f3dc8fa9be944
case "./src/rwl/config.osl"
  class __imports__997006161a7103fcb97a4e4d8f4a25b1 (
    goob = "hi"
  )
  return __imports__997006161a7103fcb97a4e4d8f4a25b1
case "./src/rwl/main.osl"
  class __imports__b471b13f60903428337025313115b852 (
    debug = false
    
    class RWLNode (
      // global attributes
      def initGlobal() (
        self.elemI = rwl.main.elemI
        rwl.main.elemI ++
        self.updateGlobal()
      )
      def updateGlobal(area, context) (
        self.id = null
        
        local id @= self.expectOnHeader("id", "str")
        if id.isError (
          return id
        )
        if id != null (
          self.id = id.value
        )
        
        self.cu_area @= area
        self.cu_context @= context
        void self.checkUpdate()
      )
      
      def updateFromCache() (
        if self.cu_area != null (
          void self.update(self.cu_area, self.cu_context)
        )
      )
      
      def updateParentFromCache() (
        if self.parent != null and self.parent.name != null (
          void self.parent.updateFromCache()
        ) else (
          void self.updateFromCache()
        )
      )
      
      def checkUpdate() (
        if self.needsUpdate (
          self.needsUpdate = false
          void self.updateFromCache()
        )
        
        // used when this was a branch like system
        //if self.children != null (
        //  for i self.children.len (
        //    void self.children[i].checkUpdate()
        //  )
        //)
      )
      
      def update() (
        
      )
      
      def topUpdate() (
        
      )
      
      def interactUpdate() (
        
      )
      
      def render() (
        
      )
      
      def renderDevtools() (
        
      )
      
      def expectOnHeader(string key, string type) (
        for attrI self.header.pairs.len (
          local attr @= self.header.pairs[attrI]
          if attr[2].isError (
            return attr[2]
          )
          if attr[1] == key (
            if attr[2].type != type (
              return rwl.error.Error("ValueTypeMismatch", {
                wanted: type,
                got: attr[2].type
              })
            ) else (
              return attr[2]
            )
          )
        )
        return null
      )
      
      def getAreaKeys(string name, pairs) (
        local l = 0
        local r = 0
        local b = 0
        local t = 0
        
        pairs ??= self.header.pairs
        for pairI pairs.len (
          local pair @= pairs[pairI]
          local n = pair[1]
          local value @= pair[2]
          
          if n == name (
            l = value.value
            r = value.value
            b = value.value
            t = value.value
          ) else if n == name ++ "_x" (
            l = value.value
            r = value.value
          ) else if n == name ++ "_y" (
            b = value.value
            t = value.value
          ) else if n == name ++ "_l" or n == name ++ "_left" (
            l = value.value
          ) else if n == name ++ "_r" or n == name ++ "_right" (
            r = value.value
          ) else if n == name ++ "_b" or n == name ++ "_bottom" (
            b = value.value
          ) else if n == name ++ "_t" or n == name ++ "_top" (
            t = value.value
          )
        )
        
        return [l, b, r, t]
      )
      
      def getPadding(pairs) (
        return self.getAreaKeys("padding", pairs)
      )
      def getMargin(pairs) (
        return self.getAreaKeys("margin", pairs)
      )
    )
    
    class RWLContainer extends RWLNode (
      kind = "block"
      def init(array children, object header) (
        self.children @= children
        self.header @= header
        void self.initGlobal()
      )
      
      def update(array area, object context) (
        void self.updateBackgroundColor()
        void self.updateBackground(area)
        void self.updateGlobal(area, context)
        
        local childArea @= rwl.area.pad(area, self.getPadding())
        
        self.area @= area
        self.childArea @= childArea
        
        return rwl.main.UpdateElements(self.children, childArea, {
          anchorX: "c",
          anchorY: "c",
          color: "#fff",
          inst: context.inst
        }, self)
      )
      
      def interactUpdate(object context) (
        for i self.children.len (
          void self.children[i].interactUpdate(context)
        )
      )
      
      def updateBackgroundColor() (
        local color @= self.expectOnHeader("color", "color")
        
        if color != null (
          self.color @= color.value
        )
      )
      
      def updateBackground(array area) (
        self.area @= area
        
        local allRounding @= self.expectOnHeader("rounding", "num")
        
        local rounding @= allRounding.value ?? 0
        
        local corners @= ["tl","tr","bl","br"]
        for i corners.len (
          local corner @= self.expectOnHeader("rounding_" ++ corners[i], "num")
          if corner != null (
            if typeof(rounding) != "array" (
              rounding @= []
              loop i - 1 (
                void rounding.append(allRounding.value ?? 0)
              )
            )
            void rounding.append(corner.value ?? 0)
          ) else (
            void rounding.append(allRounding.value ?? 0)
          )
        )
        self.rounding @= rounding
        
        void self.updateBackgroundColor()
      )
      
      def render() (
        if self.header.flags.contains("Hidden") (
          void self.renderDevtools()
          return
        )
        
        void self.renderBackground()
        if rwl.main.debug (
          void rwl.debug.box(self.area, #f00)
          void rwl.debug.box(self.childArea, #0f0)
        )
        void rwl.main.RenderElements(self.children)
        void self.renderDevtools()
      )
      
      def renderDevtools() (
        if self.elemI == devtools.main.hoveredElement (
          self.childArea ??= self.area
          
          // left
          void shared.graphics.filledTransparentArea([
            self.area[1],
            self.area[2],
            self.childArea[1],
            self.area[4]
          ], #f0f, 20)
          // right
          void shared.graphics.filledTransparentArea([
            self.childArea[3],
            self.area[2],
            self.area[3],
            self.area[4]
          ], #f0f, 20)
          // top
          void shared.graphics.filledTransparentArea([
            self.childArea[1],
            self.childArea[4],
            self.childArea[3],
            self.area[4]
          ], #f0f, 20)
          // bottom
          void shared.graphics.filledTransparentArea([
            self.childArea[1],
            self.area[2],
            self.childArea[3],
            self.childArea[2]
          ], #f0f, 20)
          
          if self.fullArea != null (
            // left
            void shared.graphics.filledTransparentArea([
              self.fullArea[1],
              self.fullArea[2],
              self.area[1],
              self.fullArea[4]
            ], #0f0, 20)
            // right
            void shared.graphics.filledTransparentArea([
              self.area[3],
              self.fullArea[2],
              self.fullArea[3],
              self.fullArea[4]
            ], #0f0, 20)
            // top
            void shared.graphics.filledTransparentArea([
              self.area[1],
              self.area[4],
              self.area[3],
              self.fullArea[4]
            ], #0f0, 20)
            // bottom
            void shared.graphics.filledTransparentArea([
              self.area[1],
              self.fullArea[2],
              self.area[3],
              self.area[2]
            ], #0f0, 20)
          )
          
          if self.name != "RWLFrame" (
            void shared.graphics.filledTransparentArea(self.childArea, #0ff, 20)
          )
        )
      )
      
      def renderBackground() (
        if self.color != null (
          void shared.graphics.filledBox(self.area, self.rounding, self.color)
        )
      )
    )
    
    class RWLRoot extends RWLContainer (
      blockName = "root"
      
      def init(array children, object header) (
        self.children @= children
        self.header @= header
        void self.initGlobal()
      )
    )
    
    class RWLFrame extends RWLContainer (
      blockName = "frame"
      
      def init(array children, object header) (
        self.children @= children
        self.header @= header
        void self.initGlobal()
      )
      
      def update(array area, object context) (
        void self.updateBackgroundColor()
        void self.updateBackground(area)
        void self.updateGlobal(area, context)
        
        local dir = "x"
        local flipped = false
        for flagI self.header.flags.len (
          switch self.header.flags[flagI] (
            case "Horizontal"
              dir = "x"
              break
            case "Vertical"
              dir = "y"
              break
            case "Flipped"
              flipped = !flipped
              break
          )
        )
        
        local amount = 0
        if dir == "x" (
          local total = rwl.area.width(area)
        ) else if dir == "y" (
          local total = rwl.area.height(area)
        )
        
        local frameContext @= {
          inst: context.inst
        }
        
        for i self.children.len (
          local child @= self.children[i]
          
          // defaults to remaining
          local size = total - amount
          local pairs @= child.header.pairs
          for pairI pairs.len (
            local pair @= pairs[pairI]
            local value @= pair[2]
            if pair[1] == "size" or (pair[1] == "width" and dir == "x") or (pair[1] == "height" and dir == "y") (
              switch value.type (
                case "num"
                  size = value.value
                  break
                case "percentage"
                  size = value.value / 100 * (total - amount)
                  break
                default
                  return rwl.error.Error("ValueTypeMismatch", {
                    wanted: ["num", "percentage"],
                    got: value.type
                  })
              )
              break
            )
          )
          
          if dir == "x" (
            local childArea @= [
              flipped ? (area[3] - amount - size) (area[1] + amount),
              area[2],
              flipped ? (area[3] - amount) (area[1] + amount + size),
              area[4]
            ]
          ) else if dir == "y" (
            local childArea @= [
              area[1],
              flipped ? (area[2] + amount) (area[4] - amount - size),
              area[3],
              flipped ? (area[2] + amount + size) (area[4] - amount)
            ]
          )
          
          child.fullArea @= childArea
          
          childArea @= rwl.area.pad(childArea, self.getMargin(pairs))
          
          if child.kind == "block" (
            local out @= child.update(childArea, frameContext)
            if out.isError (
              return out
            )
          ) else if ["icon"].contains(child.kind) (
            void child.update(childArea, frameContext)
          ) else (
            return rwl.error.Error("ElemInFrame", {})
          )
          amount += size
        )
        if dir == "x" (
          self.usedArea @= [
            flipped ? (area[3] - amount) (area[1]),
            area[2],
            flipped ? (area[3]) (area[1] + amount),
            area[4]
          ]
          self.unusedArea @= [
            flipped ? (area[1]) (area[1] + amount),
            area[2],
            flipped ? (area[3] - amount) (area[3]),
            area[4]
          ]
        ) else if dir == "y" (
          self.usedArea @= [
            area[1],
            flipped ? (area[2]) (area[4] - amount),
            area[3],
            flipped ? (area[2] + amount) (area[4])
          ]
          self.unusedArea @= [
            area[1],
            flipped ? (area[2] + amount) (area[2]),
            area[3],
            flipped ? (area[4]) (area[4] - amount)
          ]
        )
      )
      
      def render() (
        if self.header.flags.contains("Hidden") (
          void self.renderFrameDevtools()
          return
        )
        
        void self.renderBackground()
        void rwl.main.RenderElements(self.children)
        void self.renderFrameDevtools()
      )
      
      def renderFrameDevtools() (
        if self.elemI == devtools.main.hoveredElement (
          void shared.graphics.filledTransparentArea(self.usedArea, #0ff, 20)
          void shared.graphics.filledTransparentArea(self.unusedArea, #00f, 20)
        )
      )
    )
    
    class RWLSection extends RWLContainer (
      blockName = "section"
      
      def init(array children, object header) (
        self.children @= children
        self.header @= header
        void self.initGlobal()
      )
    )
    
    class RWLPositionedContainer extends RWLContainer (
      def update(array containerArea, object context) (
        void self.updateGlobal(containerArea, context)
        
        local height = self.expectOnHeader("height", "num").value ?? 20
        
        local margin @= self.getMargin()
        local padding @= self.getPadding()
        
        local anchor @= self.expectOnHeader("anchor", "str")
        if anchor.isError (
          return anchor
        )
        anchor = anchor["value"]
        
        if context.x == null or context.y == null (
          anchor ??= "c"
        )
        
        if anchor != null (
          if ["tl","t","tr",
              "l","c","r",
              "bl","b","br",
              "top left", "top", "top right",
              "left", "center", "right",
              "bottom left", "bottom", "bottom right"].contains(anchor).not() (
            return rwl.error.Error("InvalidAnchorName", {
              name: anchor
            })
          )
          
          local anchorX = rwl.area.centerX(containerArea)
          local anchorY = rwl.area.centerY(containerArea) + (height / 2 + margin[4])
          local anchorXType = "c"
          local anchorYType = "c"
          
          if anchor.endsWith("l") or anchor.endsWith("left") (
            anchorXType = "l"
          )
          if anchor.endsWith("r") or anchor.endsWith("right") (
            anchorXType = "r"
          )
          
          if anchor.startsWith("t") or anchor.endsWith("top") (
            anchorY = containerArea[4]
            anchorYType = "t"
          )
          if anchor.startsWith("b") or anchor.endsWith("bottom") (
            anchorY = containerArea[2] + height + margin[2] + margin[4]
            anchorYType = "b"
          )
          
          context.x = anchorX
          context.y = anchorY
          context.anchorX = anchorXType
          context.anchorY = anchorYType
        )
        
        context.y -= height / 2 + margin[4]
        
        local area @= [
          containerArea[1] + margin[1],
          context.y - (height / 2),
          containerArea[3] - margin[3],
          context.y + (height / 2)
        ]
        self.fullArea @= [
          containerArea[1],
          context.y - (height / 2) - margin[2],
          containerArea[3],
          context.y + (height / 2) + margin[4]
        ]
        
        context.y -= height / 2 + margin[2]
        
        void self.updateBackground(area)
        
        local childArea @= rwl.area.pad(area, padding)
        
        self.childArea @= childArea
        
        return rwl.main.UpdateElements(self.children, childArea, {
          anchorX: "c",
          anchorY: "c",
          color: "#fff",
          inst: context.inst
        }, self)
      )
      
      def render() (
        if self.header.flags.contains("Hidden") (
          void self.renderDevtools()
          return
        )
        
        void self.renderBackground()
        if rwl.main.debug (
          void rwl.debug.box(self.area, #f00)
          void rwl.debug.box(self.childArea, #0f0)
          void rwl.debug.box(self.outArea, #00f)
        )
        void rwl.main.RenderElements(self.children)
        void self.renderDevtools()
      )
    )
    
    class RWLButton extends RWLPositionedContainer (
      blockName = "button"
      
      def init(array children, object header) (
        self.children @= children
        self.header @= header
        void self.initGlobal()
      )
      
      def isHovered() (
        return mouse_x > self.area[1] and mouse_y > self.area[2] and mouse_x < self.area[3] and mouse_y < self.area[4]
      )
      
      def updateBackgroundColor() (
        local color @= self.expectOnHeader("color", "color")
        if color.isError (
          return color
        )
        if color != null (
          self.color @= color.value
        )
        
        local hover_color @= self.expectOnHeader("hover_color", "color")
        if hover_color.isError (
          return hover_color
        )
        if hover_color != null (
          self.hover_color @= hover_color.value
        )
      )
      
      def renderBackground() (
        local hov = self.isHovered()
        
        local col = self.color
        if self.hover_color != null and hov (
          col = self.hover_color
        )
        if col != null (
          void shared.graphics.filledBox(self.area, self.rounding, col)
        )
      )
      
      def interactUpdate(object context) (
        if context.topI < self.elemI (
          if self.isHovered() (
            context.top @= self
            context.topI = self.elemI
          )
        )
      )
      
      def topUpdate(object context) (
        //log "hi" context
        if shared.input.rwlLeftClick (
          void context.rtr.runEvents({
            name: "click",
            element: self
          }, {})
        )
      )
    )
    
    class RWLScript extends RWLNode (
      blockName = "script"
      kind = "script"
      
      def init(body, object header, object inst) (
        self.body @= body
        self.header @= header
        
        void self.parse()
        void self.makeModule(inst)
      )
      
      def parse() (
        self.ast @= null
        // TODO: try
        local parser @= rtr.ast.Parser(body)
        self.ast @= parser.parse()
      )
      
      def makeModule(object inst) (
        if self.ast != null (
          self.mod @= rtr.main.Module(self.ast)
          void inst.rtrInst.addModule(self.mod)
        )
      )
      
      def update(array area, object context) (
        if self.mod != null (
          void self.mod.runEvent({
            name: "onupdate"
          }, {})
        )
      )
      
      def start() (
        void self.mod.runEvent({
          name: "onload",
        }, {})
      )
    )
    
    class RWLElement extends RWLNode (
      kind = "element"
      def init(object value, object header) (
        self.value @= value
        self.header @= header
        void self.initGlobal()
      )
      
      def update(array area, object context) (
        void self.updateGlobal(area, context)
        local text = null
        
        switch self.value.type (
          case "str"; case "num"
            text = self.value.value.toStr()
            break
        )
        
        if text == null (
          return rwl.error.Error("InvalidElemType", {
            valueType: self.value.type
          })
        )
        
        // font
        //<font>
        local size @= self.expectOnHeader("size", "num")
        if size.isError (
          return size
        )
        size = size["value"] ?? 10
        
        local spacing @= self.expectOnHeader("spacing", "num")
        if spacing.isError (
          return spacing
        )
        spacing = spacing["value"] ?? 1
        
        local line_height @= self.expectOnHeader("line_height", "num")
        if line_height.isError (
          return line_height
        )
        line_height = spacing["line_height"] ?? 1
        
        // positioning
        local padding @= self.getPadding()
        
        local anchor @= self.expectOnHeader("anchor", "str")
        if anchor.isError (
          return anchor
        )
        anchor = anchor["value"]
        
        if context.x == null or context.y == null (
          anchor ??= "c"
        )
        
        if anchor != null (
          if ["tl","t","tr",
              "l","c","r",
              "bl","b","br",
              "top left", "top", "top right",
              "left", "center", "right",
              "bottom left", "bottom", "bottom right"].contains(anchor).not() (
            return rwl.error.Error("InvalidAnchorName", {
              name: anchor
            })
          )
          
          local anchorX = rwl.area.centerX(area)
          local anchorY = rwl.area.centerY(area) + (line_height * 1 * size)
          local anchorXType = "c"
          local anchorYType = "c"
          
          if anchor.endsWith("l") or anchor.endsWith("left") (
            anchorX = area[1] + padding[1]
            anchorXType = "l"
          )
          if anchor.endsWith("r") or anchor.endsWith("right") (
            anchorX = area[3] - padding[3]
            anchorXType = "r"
          )
          
          if anchor.startsWith("t") or anchor.endsWith("top") (
            anchorY = area[4] - padding[4]
            anchorYType = "t"
          )
          if anchor.startsWith("b") or anchor.endsWith("bottom") (
            anchorY = area[2] + padding[2]
            anchorYType = "b"
          )
          
          context.x = anchorX
          context.y = anchorY
          context.anchorX = anchorXType
          context.anchorY = anchorYType
        )
        
        local boxAlignment = context.anchorX
        
        local alignment @= self.expectOnHeader("alignment", "str")
        if alignment.isError (
          return alignment
        )
        alignment = alignment["value"]
        if alignment != null (
          if ["l","c","r",
              "left", "center", "right"].contains(alignment).not() (
            return rwl.error.Error("InvalidAlignmentName", {
              name: anchor
            })
          )
          
          if alignment.endsWith("l") or alignment.endsWith("left") (
            alignment = "l"
          )
          if alignment.endsWith("r") or alignment.endsWith("right") (
            alignment = "r"
          )
        )
        alignment ??= boxAlignment
        
        // appearance
        //<link>
        //<decoration>
        local color @= self.expectOnHeader("color", "color")
        if color.isError (
          return color
        )
        color = color.value
        if color != null (
          context.color = color
        )
        color ??= context.color
        
        local lines @= text.split("\n")
        local width = 0
        for lineI lines.len (
          width = max(width, lines[lineI].len * size * spacing)
        )
        local height = lines.len * line_height * 2 * size
        
        local x = context.x
        if boxAlignment == "l" (
          x += width / 2
        )
        if boxAlignment == "r" (
          x += width / -2
        )
        
        context.y -= height / (context.anchorY == "b" ? -2 2)
        
        self.lines @= []
        local y = context.y + (height / 2)
        for lineI lines.len (
          y -= size * line_height
          local lineW = shared.graphics.getTextWidth(lines[lineI]) * size
          local lx = x
          if alignment == "l" (
            lx += width / -2
          )
          if alignment == "r" (
            lx += width / 2 - lineW
          )
          if alignment == "c" (
            // account for char spacing
            lx += lineW * -.5
          )
          void self.lines.append([lines[lineI], lx, y, size, color])
          y -= size * line_height
        )
        
        self.debugArea @= [
          x - (width / 2),
          context.y - (height / 2),
          x + (width / 2),
          context.y + (height / 2)
        ]
        self.padding @= padding
        
        context.y -= height / (context.anchorY == "b" ? -2 2)
      )
      
      def render() (
        if self.header.flags.contains("Hidden") (
          void self.renderDevtools()
          return
        )
        
        for lineI self.lines.len (
          local line @= self.lines[lineI]
          void shared.graphics.ptext(line[1], line[2], line[3], line[4], line[5])
        )
        
        void rwl.debug.box(self.debugArea ?? [])
        void self.renderDevtools()
      )
      
      def renderDevtools() (
        if self.elemI == devtools.main.hoveredElement (
          void shared.graphics.filledTransparentArea(self.debugArea, #0ff, 20)
          
          local fullArea = rwl.area.margin(self.debugArea, self.padding)
         
          if fullArea != null (
            // left
            void shared.graphics.filledTransparentArea([
              fullArea[1],
              fullArea[2],
              self.debugArea[1],
              fullArea[4]
            ], #f0f, 20)
            // right
            void shared.graphics.filledTransparentArea([
              self.debugArea[3],
              fullArea[2],
              fullArea[3],
              fullArea[4]
            ], #f0f, 20)
            // top
            void shared.graphics.filledTransparentArea([
              self.debugArea[1],
              self.debugArea[4],
              self.debugArea[3],
              fullArea[4]
            ], #f0f, 20)
            // bottom
            void shared.graphics.filledTransparentArea([
              self.debugArea[1],
              fullArea[2],
              self.debugArea[3],
              self.debugArea[2]
            ], #f0f, 20)
          )
        )
      )
    )
    
    class RWLIcon extends RWLNode (
      kind = "icon"
      
      def update(array area, object context) (
        local scale @= self.expectOnHeader("scale", "num")
        if scale.isError (
          return scale
        )
        self.scale = size.value ?? 1
        
        local src @= self.expectOnHeader("src", "str")
        if src.isError (
          return src
        )
        if src == null (
          return rwl.error.Error("NoIconSrc", {})
        )
        self.src = src.value
        
        local color @= self.expectOnHeader("color", "color")
        if color.isError (
          return color
        )
        self.color = color.value
        
        // TODO: anchors?
        self.x = rwl.area.centerX(area)
        self.y = rwl.area.centerY(area)
      )
      
      def render() (
        if self.header.flags.contains("Hidden") (
          void self.renderDevtools()
          return
        )
        
        void shared.graphics.picon(self.src, self.x, self.y, self.scale, self.color ?? "#fff")
        void self.renderDevtools()
      )
      
      def init(object header) (
        self.header @= header
      )
    )
    
    def UpdateElements(array elements, array area, object context, object parentElem) (
      for i elements.len (
        elements[i].parent @= parentElem
        local out @= elements[i].update(area, context)
        if out.isError (
          return out
        )
      )
    )
    
    def RenderElements(array elements) (
      for i elements.len (
        //void
        void elements[i].render()
        void
      )
    )
    
    elemI = 0
    def AstToElement(ast, object inst) (
      def AstToHeader(header) (
        local flags @= []
        local pairs @= []
        for attrI header.attributes.len (
          local attr @= header.attributes[attrI]
          switch attr.kind (
            case "flag"
              flags.append(attr.data)
              break
            case "key"
              void pairs.append([attr.key, rwl.value.AstToValue(attr.value)])
              break
          )
        )
        return { flags, pairs }
      )
      //log "a" ast
      local header @= AstToHeader(ast.data.header)
      
      switch ast.kind (
        case "block"
          if ast.data.header.key != "script" (
            local children @= AstsToElements(ast.data.content.elements, inst)
          )
          if typeof(children) != "array" and children["isError"] (
            return children
          )
          switch ast.data.header.key (
            // top level
            case "root"
              return rwl.main.RWLRoot(children, header)
            
            // normal
            case "frame"
              return rwl.main.RWLFrame(children, header)
            case "section"
              return rwl.main.RWLSection(children, header)
            
            case "script"
              return rwl.main.RWLScript(shared.utils.removeIndents(ast.data.content), header, inst)
            
            case "button"
              return rwl.main.RWLButton(children, header)
            
            default
              return rwl.error.Error("UnknownBlockType", {
                blockType: ast.data.header.key
              })
              break
          )
          break
        
        case "element"
          return rwl.main.RWLElement(rwl.value.AstToValue(ast.data.value), header)
        
        case "icon"
          return rwl.main.RWLIcon(header)
        
        default
          return rwl.error.Error("UnknownElementKind", {
            elementKind: ast.kind
          })
          break
      )
    )
    
    def AstsToElements(elements, object inst) (
      local elems @= []
      for i elements.len (
        local out @= AstToElement(elements[i], inst)
        if out.isError (
          return out
        )
        void elems.append(out)
      )
      return elems
    )
    
    class RWL (
      def init(object ast, object rtrInst) (
        self.rtrInst @= rtrInst
        self.errored = false
        self.needsUpdate = true
        self.hasUpdated = false
        
        self._lastW = 0
        self._lastH = 0
        self._lastX = 0
        self._lastY = 0
        
        void self.loadFromAst(ast)
      )
      
      def loadFromAst(object ast) (
        self.ast @= ast
        self.elements @= rwl.main.AstsToElements(ast.elements, self)
        
        if typeof(self.elements) != "array" and self.elements.isError (
          error self.elements.stringify()
          self.errored = true
          return
        )
      )
      
      def update(array area) (
        self.hasUpdated = true
        if self.errored (
          return
        )
        
        local out @= rwl.main.UpdateElements(self.elements, area, {
          inst: self,
          root: true
        }, {})
        if out.isError (
          error out.stringify()
          self.errored = true
          self.errormsg = out.stringify()
        )
      )
      
      def checkUpdate(array area) (
        local w = rwl.area.width(area)
        local h = rwl.area.height(area)
        local x = rwl.area.centerX(area)
        local y = rwl.area.centerY(area)
        
        // if the width or height or x or y has changed, update
        if w != self._lastW or h != self._lastH or x != self._lastX or y != self._lastY (
          self.needsUpdate = true
          
          self._lastW = w
          self._lastH = h
          self._lastX = x
          self._lastY = y
        )
        
        if self.needsUpdate (
          void self.update(area)
          self.needsUpdate = false
        )
      )
      
      def interactUpdate(object context) (
        if self.errored (
          return
        )
      
        context.top = null
        context.topI = 0
        for i self.elements.len (
          void self.elements[i].interactUpdate(context)
        )
        
        if context.top != null (
          void context.top.topUpdate(context)
        )
        void shared.input.reset()
      )
      
      def checkElemUpdate() (
        if self.errored (
          return
        )
      
        for i self.elements.len (
          void self.elements[i].checkUpdate()
        )
      )
      
      def render(array area) (
        void self.checkUpdate(area)
      
        self.worker.area @= area
        if self.errored (
          goto rwl.area.centerX(area) rwl.area.centerY(area)
          centext "rwl errored :(" 12 : c#shared.theme.seco
          if self.errormsg != null (
            centext self.errormsg 8 : c#shared.theme.prim chy#-20
          )
          return
        )
        
        void rwl.main.RenderElements(self.elements)
      )
      
      def getElement(string id) (
        local queue @= [...self.elements]
        while queue.len > 0 (
          local elem @= queue.shift()
          
          if elem.id == id (
            return elem
          )
          
          if elem.children != null (
            for i elem.children.len (
              void queue.append(elem.children[i])
            )
          )
        )
      )
    )
  )
  return __imports__b471b13f60903428337025313115b852
case "./src/rtr/rwl.osl"
  class __imports__9a058537c83ea298ad90e68798b3ddc4 (
    class RTRDocument extends rtr.value.RTRValue (
      def init(object doc) (
        self.doc @= doc
      )
    
      def getRtrType() (
        return rtr.value.RTRTypeValue({
          name: "document"
        })
      )
      
      def getItem(key) (
        switch key.stringify() (
          // values
          case "title"
            return rtr.value.RTRStrValue(self.doc.title)
          case "icon"
            if self.doc.icon == null (
              return rtr.value.RTRNullValue()
            )
            return rtr.value.RTRStrValue(self.doc.icon)
          case "root"
            local elems @= self.doc.rwlInst.elements
            for i elems.len (
              local elem @= elems[i]
              if elem.name == "RWLRoot" (
                return rtr.rwl.RTRElement(elem)
              )
            )
            return rtr.value.RTRNullValue()
          
          // methods
          case "redirect"
            return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (
              void doc.doc.loadUrl(shared.url.Url(args[1].stringify()))
              void layouts.shared.state.updateTab()
            ), self)
          case "getElement"
            return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (
              local elem @= doc.doc.rwlInst.getElement(args[1].stringify())
              if elem == null (
                return rtr.value.RTRNullValue()
              )
              return rtr.rwl.RTRElement(elem)
            ), self)
          case "createTextElement"
            return rtr.value.RTROslFuncValue(def(args, _inst) -> (
              return rtr.rwl.RTRElement(rwl.main.RWLElement(rtr.rwl.rtrValueToRwlValue(args[1]), { flags: [], pairs: [] }))
            ))
          case "createScript"
            return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (
              local elem @= rwl.main.RWLScript(args[1].stringify(), { flags: [], pairs: [] }, doc.doc.rwlInst)
              void elem.start()
              return rtr.rwl.RTRElement(elem)
            ), self)
          case "createContainer"
            return rtr.value.RTROslFuncValue(def(args, _inst) -> (
              local kind = args[1].stringify()
              switch kind (
                case "frame"
                  return rtr.rwl.RTRElement(rwl.main.RWLFrame([], { flags: [], pairs: [] }))
                case "section"
                  return rtr.rwl.RTRElement(rwl.main.RWLSection([], { flags: [], pairs: [] }))
                case "button"
                  return rtr.rwl.RTRElement(rwl.main.RWLButton([], { flags: [], pairs: [] }))
                
                default
                  throw "unknown container type" + kind
              )
              return rtr.rwl.RTRElement(rwl.main.RWLElement(rtr.rwl.rtrValueToRwlValue(args[1]), { flags: [], pairs: [] }))
            ))
          
          default
            throw "unknown property" + key.stringify() + "on document"
        )
      )
      
      def setItem(key, value) (
        switch key.stringify() (
          case "title"
            self.doc.title = value.stringify()
            break
          case "icon"
            self.doc.icon = value.stringify()
            break
          default
            throw "cannot set property" + key.stringify() + "on document"
        )
      )
    )
    
    class RTRElement extends rtr.value.RTRValue (
      isRwlElem = true
      
      def init(object elem) (
        self.elem @= elem
      )
    
      def getRtrType() (
        return rtr.value.RTRTypeValue({
          name: "element"
        })
      )
      
      def stringify() (
        local txt = (self.elem.blockName ?? self.elem.kind).toStr()
        if self.elem.id != null (
          txt ++= ":" ++ self.elem.id
        )
        return "<" ++ txt ++ ">"
      )
      
      def getItem(key) (
        local k = key.stringify()
        
        switch k (
          case "toggleFlag"
            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (
              local flags @= elem.elem.header.flags
              local name = args[1].stringify()
              
              if flags.contains(name) (
                void flags.delete(flags.index(name))
              ) else (
                void flags.append(name)
              )
              
              elem.elem.needsUpdate = true
              void elem.elem.checkUpdate()
            ), self)
          case "addFlag"
            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (
              local flags @= elem.elem.header.flags
              local name = args[1].stringify()
              
              if !flags.contains(name) (
                void flags.append(name)
              )
              
              elem.elem.needsUpdate = true
              void elem.elem.checkUpdate()
            ), self)
          case "removeFlag"
            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (
              local flags @= elem.elem.header.flags
              local name = args[1].stringify()
              
              if flags.contains(name) (
                void flags.delete(flags.index(name))
              )
              
              elem.elem.needsUpdate = true
              void elem.elem.checkUpdate()
            ), self)
          case "hasFlag"
            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (
              local flags @= elem.elem.header.flags
              local name = args[1].stringify()
              
              return rtr.value.RTRBoolValue(flags.contains(name))
            ), self)
          
          case "addChild"
            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (
              if elem.elem.children == null (
                throw elem.kind + "cannot contain children"
              )
              if !args[1].isRwlElem (
                throw "argument is not rwl element"
              )
              void elem.elem.children.append(args[1].elem)
              
              void elem.elem.updateParentFromCache()
            ), self)
          case "popChild"
            return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (
              if elem.elem.children == null (
                throw elem.kind + "doesnt contain children"
              )
              local idx = args.len > 0 ? args[1].numbify() 1
              local out @= elem.elem.children[idx]
              if out != null (
                out @= rtr.rwl.RTRElement(out)
              ) else (
                out @= rtr.value.RTRNullValue()
              )
              void elem.elem.children.delete(idx)
              
              void elem.elem.updateParentFromCache()
              return out
            ), self)
        )
        
        for i self.elem.header.pairs.len (
          local pair @= self.elem.header.pairs[i]
          if pair[1] == k (
            return rtr.rwl.rwlValueToRtrValue(pair[2])
          )
        )
        return rtr.value.RTRNullValue()
      )
      
      def setItem(key, value) (
        local k = key.stringify()
        local v @= rtr.rwl.rtrValueToRwlValue(value)
        for i self.elem.header.pairs.len (
          local pair @= self.elem.header.pairs[i]
          if pair[1] == k (
            pair[2] @= v
            void self.elem.updateParentFromCache()
            return
          )
        )
        
        void self.elem.header.pairs.append([
          k, v
        ])
        
        void self.elem.updateParentFromCache()
      )
    )
    
    def rwlValueToRtrValue(object val) (
      switch val.type (
        case "str"
          return rtr.value.RTRStrValue(val.value)
        case "num"
          return rtr.value.RTRNumValue(val.value)
        // percentage
        // color
      )
      
      return rtr.value.RTRNullValue()
    )
    
    def rtrValueToRwlValue(object val) (
      local type @= val.getRtrType()
      
      switch type.data.name (
        case "str"
          return rwl.value.RWLStrValue(val.value)
        case "num"
          return rwl.value.RWLNumValue(val.value)
        case "color"
          return rwl.value.RWLColorValue(val.value)
      )
      
      throw "cannot set" + type.stringify() + "as rwl property"
    )
    
    // applies all rwl related apis to rtr
    def addToInst(object doc, object rtrInst) (
      local mods @= rtrInst.modules.getValues()
      for i mods.len (
        addToMod(doc, mods[i])
      )
    )
    
    def addToMod(object doc, object mod) (
      void mod.declScopeVar("document", RTRDocument(doc))
      void mod.declScopeVar("theme", rtr.value.RTRObjValue({
        back: rtr.value.RTRColorValue(shared.theme.back),
        prim: rtr.value.RTRColorValue(shared.theme.prim),
        seco: rtr.value.RTRColorValue(shared.theme.seco),
        tert: rtr.value.RTRColorValue(shared.theme.tert),
        text: rtr.value.RTRColorValue(shared.theme.text),
        accent: rtr.value.RTRColorValue(shared.theme.accent),
      }))
    )
  )
  return __imports__9a058537c83ea298ad90e68798b3ddc4
case "./src/assets/empty.rwl"
  return "  root {\n    \"grahhh\"\n  }"

case "./main.rwl"
  return "  root {\n    frame [Horizontal, id=\"bleh\"] {\n      section [\n        id=\"sidebar\",\n        size=150, color=theme:prim,\n        rounding_tr=17.5, rounding_br=17.5,\n        padding=10\n      ] {},\n      section {\n      }\n    },\n    \n    script {\n      event(onload) {\n        i := 0;\n        createSidebarButton := (name) ~ {\n          i = i + 1;\n          elem := document.createContainer(\"button\");\n          elem.height = 35;\n          elem.padding = 10;\n          elem.color = theme.seco;\n          elem.hover_color = theme.tert;\n          elem.rounding = 10;\n          elem.id = \"btn\" + i;\n          if (i == 1) {\n            elem.anchor = \"t\";\n          }\n          elem.margin_b = 10;\n          document.getElement(\"sidebar\").addChild(elem);\n          \n          script := document.createScript(\"event(#\" + elem.id + \":click) {\\n  log(\\\"\" + name + \" clicked!\\\");\\n}\\n\");\n          document.root.addChild(script);\n          \n          text := document.createTextElement(name);\n          text.color = theme.text;\n          elem.addChild(text);\n        };\n        \n        btns := [\n          \"hi\",\n          \"wow\",\n          \"blehh\",\n          \"fr\"\n        ];\n        \n        for (btn, btns) {\n          createSidebarButton(btn);\n        }\n      }\n    }\n  }"
)
)
import as "glass" from "packages"

// import overwrite


object rwl @= {
  main: import("./src/rwl/main.osl"),
  config: import("./src/rwl/config.osl"),
  area: import("./src/rwl/area.osl"),
  error: import("./src/rwl/error.osl"),
  value: import("./src/rwl/value.osl"),
  debug: import("./src/rwl/debug.osl"),
  ast: import("./src/rwl/ast.osl")
}

object rtr @= {
  main: import("./src/rtr/main.osl"),
  ast: import("./src/rtr/ast.osl"),
  error: import("./src/rtr/error.osl"),
  value: import("./src/rtr/value.osl")
}

rtr.rwl @= import("./src/rtr/rwl.osl")

object shared @= {
  graphics: import("./src/shared/graphics.osl"),
  utils: import("./src/shared/utils.osl"),
  document: import("./src/shared/document.osl"),
  tab: import("./src/shared/tab.osl"),
  url: import("./src/shared/url.osl"),
  theme: import("./src/shared/theme.osl"),
  config: import("./src/shared/config.osl"),
  tab_worker: import("./src/shared/tab_worker.osl"),
  input: import("./src/shared/input.osl"),
  settings: import("./src/shared/settings.osl"),
  save: import("./src/shared/save.osl")
}

object layouts @= {
  shared: {
    state: import("./src/layouts/shared/state.osl"),
    utils: import("./src/layouts/shared/utils.osl"),
    topbar: import("./src/layouts/shared/topbar.osl"),
    urlbar: import("./src/layouts/shared/urlbar.osl"),
    view: import("./src/layouts/shared/view.osl")
  },
  chromeLike: {
    main: import("./src/layouts/chromeLike/main.osl"),
    topbar: import("./src/layouts/chromeLike/topbar.osl")
  },
  summit: {
    main: import("./src/layouts/summit/main.osl"),
    sidebar: import("./src/layouts/summit/sidebar.osl"),
    topbar: import("./src/layouts/summit/topbar.osl")
  }
}

object net @= {
  fetch: import("./src/net/fetch.osl"),
  response: import("./src/net/response.osl")
}

object devtools @= {
  main: import("./src/devtools/main.osl"),
  topbar: import("./src/devtools/topbar.osl"),
  rightclick: import("./src/devtools/rightclick.osl"),
  
  menus: {
    elements: import("./src/devtools/menus/elements.osl"),
    console: import("./src/devtools/menus/console.osl"),
    network: import("./src/devtools/menus/network.osl"),
    storage: import("./src/devtools/menus/storage.osl")
  }
}

void shared.settings.load()

void layouts.chromeLike.main.init()

if true (
  local document @= shared.document.Document()
  void document.loadUrl(shared.url.Url("local://~/projects/phosphorus/main.rwl"))
  void layouts.shared.state.openTabDocument(document)
  
  local document2 @= shared.document.Document()
  void document2.loadUrl(shared.url.Url("local://~/projects/phosphorus/test.rwl"))
  void layouts.shared.state.openTabDocument(document2)
)

void layouts.shared.state.selectTab(1)

void window.resize(900,500)

devtools.main.open = true

mainloop:
  void layouts.chromeLike.main.update()
  //void layouts.summit.main.update()
  
  // file dropping
  if file_dropped != 0 (
    local data @= open(file_dropped,[3,2,1])
    local path = data[1] ++ "/" ++ data[2] ++ data[3]
    local document @= shared.document.Document()
    void document.loadUrl(shared.url.Url("local://" ++ path))
    void layouts.shared.state.openTabDocument(document)
    file_dropped = 0
  )