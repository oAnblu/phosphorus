
debug = false

class RWLNode (
  // global attributes
  def initGlobal() (
    self.elemI = rwl.main.elemI
    rwl.main.elemI ++
    self.updateGlobal()
  )
  def updateGlobal(area, context) (
    self.id = null
    
    local id @= self.expectOnHeader("id", "str")
    if id.isError (
      return id
    )
    if id != null (
      self.id = id.value
    )
    
    self.cu_area @= area
    self.cu_context @= context
    void self.checkUpdate()
  )
  
  def checkUpdate() (
    if self.needsUpdate (
      if self.cu_area != null (
        self.needsUpdate = false
        void self.update(self.cu_area, self.cu_context)
      )
    )
    
    // used when this was a branch like system
    //if self.children != null (
    //  for i self.children.len (
    //    void self.children[i].checkUpdate()
    //  )
    //)
  )
  
  def update() (
    
  )
  
  def topUpdate() (
    
  )
  
  def interactUpdate() (
    
  )
  
  def render() (
    
  )
  
  def renderDevtools() (
    
  )
  
  def expectOnHeader(string key, string type) (
    for attrI self.header.pairs.len (
      local attr @= self.header.pairs[attrI]
      if attr[2].isError (
        return attr[2]
      )
      if attr[1] == key (
        if attr[2].type != type (
          return rwl.error.Error("ValueTypeMismatch", {
            wanted: type,
            got: attr[2].type
          })
        ) else (
          return attr[2]
        )
      )
    )
    return null
  )
  
  def getAreaKeys(string name, pairs) (
    local l = 0
    local r = 0
    local b = 0
    local t = 0
    
    pairs ??= self.header.pairs
    for pairI pairs.len (
      local pair @= pairs[pairI]
      local n = pair[1]
      local value @= pair[2]
      
      if n == name (
        l = value.value
        r = value.value
        b = value.value
        t = value.value
      ) else if n == name ++ "_x" (
        l = value.value
        r = value.value
      ) else if n == name ++ "_y" (
        b = value.value
        t = value.value
      ) else if n == name ++ "_l" or n == name ++ "_left" (
        l = value.value
      ) else if n == name ++ "_r" or n == name ++ "_right" (
        r = value.value
      ) else if n == name ++ "_b" or n == name ++ "_bottom" (
        b = value.value
      ) else if n == name ++ "_t" or n == name ++ "_top" (
        t = value.value
      )
    )
    
    return [l, b, r, t]
  )
  
  def getPadding(pairs) (
    return self.getAreaKeys("padding", pairs)
  )
  def getMargin(pairs) (
    return self.getAreaKeys("margin", pairs)
  )
)

class RWLContainer extends RWLNode (
  kind = "block"
  def init(array children, object header) (
    self.children @= children
    self.header @= header
    void self.initGlobal()
  )
  
  def update(array area, object context) (
    void self.updateBackgroundColor()
    void self.updateBackground(area)
    void self.updateGlobal(area, context)
    
    local childArea @= rwl.area.pad(area, self.getPadding())
    
    self.area @= area
    self.childArea @= childArea
    
    return rwl.main.UpdateElements(self.children, childArea, {
      anchorX: "c",
      anchorY: "c",
      color: "#fff",
      inst: context.inst
    }, self)
  )
  
  def interactUpdate(object context) (
    for i self.children.len (
      void self.children[i].interactUpdate(context)
    )
  )
  
  def updateBackgroundColor() (
    local color @= self.expectOnHeader("color", "color")
    
    if color != null (
      self.color @= color.value
    )
  )
  
  def updateBackground(array area) (
    self.area @= area
    
    local allRounding @= self.expectOnHeader("rounding", "num")
    
    local rounding @= allRounding.value ?? 0
    
    local corners @= ["tl","tr","bl","br"]
    for i corners.len (
      local corner @= self.expectOnHeader("rounding_" ++ corners[i], "num")
      if corner != null (
        if typeof(rounding) != "array" (
          rounding @= []
          loop i - 1 (
            void rounding.append(allRounding.value ?? 0)
          )
        )
        void rounding.append(corner.value ?? 0)
      ) else (
        void rounding.append(allRounding.value ?? 0)
      )
    )
    self.rounding @= rounding
    
    void self.updateBackgroundColor()
  )
  
  def render() (
    if self.header.flags.contains("Hidden") (
      void self.renderDevtools()
      return
    )
    
    void self.renderBackground()
    if rwl.main.debug (
      void rwl.debug.box(self.area, #f00)
      void rwl.debug.box(self.childArea, #0f0)
    )
    void rwl.main.RenderElements(self.children)
    void self.renderDevtools()
  )
  
  def renderDevtools() (
    if self.elemI == devtools.main.hoveredElement (
      self.childArea ??= self.area
      
      // left
      void shared.graphics.filledTransparentArea([
        self.area[1],
        self.area[2],
        self.childArea[1],
        self.area[4]
      ], #f0f, 20)
      // right
      void shared.graphics.filledTransparentArea([
        self.childArea[3],
        self.area[2],
        self.area[3],
        self.area[4]
      ], #f0f, 20)
      // top
      void shared.graphics.filledTransparentArea([
        self.childArea[1],
        self.childArea[4],
        self.childArea[3],
        self.area[4]
      ], #f0f, 20)
      // bottom
      void shared.graphics.filledTransparentArea([
        self.childArea[1],
        self.area[2],
        self.childArea[3],
        self.childArea[2]
      ], #f0f, 20)
      
      if self.fullArea != null (
        // left
        void shared.graphics.filledTransparentArea([
          self.fullArea[1],
          self.fullArea[2],
          self.area[1],
          self.fullArea[4]
        ], #0f0, 20)
        // right
        void shared.graphics.filledTransparentArea([
          self.area[3],
          self.fullArea[2],
          self.fullArea[3],
          self.fullArea[4]
        ], #0f0, 20)
        // top
        void shared.graphics.filledTransparentArea([
          self.area[1],
          self.area[4],
          self.area[3],
          self.fullArea[4]
        ], #0f0, 20)
        // bottom
        void shared.graphics.filledTransparentArea([
          self.area[1],
          self.fullArea[2],
          self.area[3],
          self.area[2]
        ], #0f0, 20)
      )
      
      if self.name != "RWLFrame" (
        void shared.graphics.filledTransparentArea(self.childArea, #0ff, 20)
      )
    )
  )
  
  def renderBackground() (
    if self.color != null (
      void shared.graphics.filledBox(self.area, self.rounding, self.color)
    )
  )
)

class RWLRoot extends RWLContainer (
  blockName = "root"
  
  def init(array children, object header) (
    self.children @= children
    self.header @= header
    void self.initGlobal()
  )
)

class RWLFrame extends RWLContainer (
  blockName = "frame"
  
  def init(array children, object header) (
    self.children @= children
    self.header @= header
    void self.initGlobal()
  )
  
  def update(array area, object context) (
    void self.updateBackgroundColor()
    void self.updateBackground(area)
    void self.updateGlobal(area, context)
    
    local dir = "x"
    local flipped = false
    for flagI self.header.flags.len (
      switch self.header.flags[flagI] (
        case "Horizontal"
          dir = "x"
          break
        case "Vertical"
          dir = "y"
          break
        case "Flipped"
          flipped = !flipped
          break
      )
    )
    
    local amount = 0
    if dir == "x" (
      local total = rwl.area.width(area)
    ) else if dir == "y" (
      local total = rwl.area.height(area)
    )
    
    local frameContext @= {
      inst: context.inst
    }
    
    for i self.children.len (
      local child @= self.children[i]
      
      // defaults to remaining
      local size = total - amount
      local pairs @= child.header.pairs
      for pairI pairs.len (
        local pair @= pairs[pairI]
        local value @= pair[2]
        if pair[1] == "size" or (pair[1] == "width" and dir == "x") or (pair[1] == "height" and dir == "y") (
          switch value.type (
            case "num"
              size = value.value
              break
            case "percentage"
              size = value.value / 100 * (total - amount)
              break
            default
              return rwl.error.Error("ValueTypeMismatch", {
                wanted: ["num", "percentage"],
                got: value.type
              })
          )
          break
        )
      )
      
      if dir == "x" (
        local childArea @= [
          flipped ? (area[3] - amount - size) (area[1] + amount),
          area[2],
          flipped ? (area[3] - amount) (area[1] + amount + size),
          area[4]
        ]
      ) else if dir == "y" (
        local childArea @= [
          area[1],
          flipped ? (area[2] + amount) (area[4] - amount - size),
          area[3],
          flipped ? (area[2] + amount + size) (area[4] - amount)
        ]
      )
      
      child.fullArea @= childArea
      
      childArea @= rwl.area.pad(childArea, self.getMargin(pairs))
      
      if child.kind == "block" (
        local out @= child.update(childArea, frameContext)
        if out.isError (
          return out
        )
      ) else if ["icon"].contains(child.kind) (
        void child.update(childArea, frameContext)
      ) else (
        return rwl.error.Error("ElemInFrame", {})
      )
      amount += size
    )
    if dir == "x" (
      self.usedArea @= [
        flipped ? (area[3] - amount) (area[1]),
        area[2],
        flipped ? (area[3]) (area[1] + amount),
        area[4]
      ]
      self.unusedArea @= [
        flipped ? (area[1]) (area[1] + amount),
        area[2],
        flipped ? (area[3] - amount) (area[3]),
        area[4]
      ]
    ) else if dir == "y" (
      self.usedArea @= [
        area[1],
        flipped ? (area[2]) (area[4] - amount),
        area[3],
        flipped ? (area[2] + amount) (area[4])
      ]
      self.unusedArea @= [
        area[1],
        flipped ? (area[2] + amount) (area[2]),
        area[3],
        flipped ? (area[4]) (area[4] - amount)
      ]
    )
  )
  
  def render() (
    if self.header.flags.contains("Hidden") (
      void self.renderFrameDevtools()
      return
    )
    
    void self.renderBackground()
    void rwl.main.RenderElements(self.children)
    void self.renderFrameDevtools()
  )
  
  def renderFrameDevtools() (
    if self.elemI == devtools.main.hoveredElement (
      void shared.graphics.filledTransparentArea(self.usedArea, #0ff, 20)
      void shared.graphics.filledTransparentArea(self.unusedArea, #00f, 20)
    )
  )
)

class RWLSection extends RWLContainer (
  blockName = "section"
  
  def init(array children, object header) (
    self.children @= children
    self.header @= header
    void self.initGlobal()
  )
)

class RWLPositionedContainer extends RWLContainer (
  def update(array containerArea, object context) (
    void self.updateGlobal(containerArea, context)
    
    local height = self.expectOnHeader("height", "num").value ?? 20
    
    local margin @= self.getMargin()
    local padding @= self.getPadding()
    
    local anchor @= self.expectOnHeader("anchor", "str")
    if anchor.isError (
      return anchor
    )
    anchor = anchor["value"]
    
    if context.x == null or context.y == null (
      anchor ??= "c"
    )
    
    if anchor != null (
      if ["tl","t","tr",
          "l","c","r",
          "bl","b","br",
          "top left", "top", "top right",
          "left", "center", "right",
          "bottom left", "bottom", "bottom right"].contains(anchor).not() (
        return rwl.error.Error("InvalidAnchorName", {
          name: anchor
        })
      )
      
      local anchorX = rwl.area.centerX(containerArea)
      local anchorY = rwl.area.centerY(containerArea) + (height / 2 + margin[4])
      local anchorXType = "c"
      local anchorYType = "c"
      
      if anchor.endsWith("l") or anchor.endsWith("left") (
        anchorXType = "l"
      )
      if anchor.endsWith("r") or anchor.endsWith("right") (
        anchorXType = "r"
      )
      
      if anchor.startsWith("t") or anchor.endsWith("top") (
        anchorY = containerArea[4] - (0) + (margin[2] * 0)
        anchorYType = "t"
      )
      if anchor.startsWith("b") or anchor.endsWith("bottom") (
        anchorY = containerArea[2] + (height) + (margin[2] * 2)
        anchorYType = "b"
      )
      
      context.x = anchorX
      context.y = anchorY
      context.anchorX = anchorXType
      context.anchorY = anchorYType
    )
    
    context.y -= height / 2 + margin[2]
    
    local area @= [
      containerArea[1] + margin[1],
      context.y - (height / 2),
      containerArea[3] - margin[3],
      context.y + (height / 2)
    ]
    self.fullArea @= [
      containerArea[1],
      context.y - (height / 2) - margin[2],
      containerArea[3],
      context.y + (height / 2) + margin[4]
    ]
    
    context.y -= height / 2 + margin[4]
    
    void self.updateBackground(area)
    
    local childArea @= rwl.area.pad(area, padding)
    
    self.childArea @= childArea
    
    return rwl.main.UpdateElements(self.children, childArea, {
      anchorX: "c",
      anchorY: "c",
      color: "#fff",
      inst: context.inst
    }, self)
  )
  
  def render() (
    if self.header.flags.contains("Hidden") (
      void self.renderDevtools()
      return
    )
    
    void self.renderBackground()
    if rwl.main.debug (
      void rwl.debug.box(self.area, #f00)
      void rwl.debug.box(self.childArea, #0f0)
      void rwl.debug.box(self.outArea, #00f)
    )
    void rwl.main.RenderElements(self.children)
    void self.renderDevtools()
  )
)

class RWLButton extends RWLPositionedContainer (
  blockName = "button"
  
  def init(array children, object header) (
    self.children @= children
    self.header @= header
    void self.initGlobal()
  )
  
  def isHovered() (
    return mouse_x > self.area[1] and mouse_y > self.area[2] and mouse_x < self.area[3] and mouse_y < self.area[4]
  )
  
  def updateBackgroundColor() (
    local color @= self.expectOnHeader("color", "color")
    if color.isError (
      return color
    )
    if color != null (
      self.color @= color.value
    )
    
    local hover_color @= self.expectOnHeader("hover_color", "color")
    if hover_color.isError (
      return hover_color
    )
    if hover_color != null (
      self.hover_color @= hover_color.value
    )
  )
  
  def renderBackground() (
    local hov = self.isHovered()
    
    local col = self.color
    if self.hover_color != null and hov (
      col = self.hover_color
    )
    if col != null (
      void shared.graphics.filledBox(self.area, self.rounding, col)
    )
  )
  
  def interactUpdate(object context) (
    if context.topI < self.elemI (
      if self.isHovered() (
        context.top @= self
        context.topI = self.elemI
      )
    )
  )
  
  def topUpdate(object context) (
    //log "hi" context
    if shared.input.rwlLeftClick (
      void context.rtr.runEvents({
        name: "click",
        element: self
      }, {})
    )
  )
)

class RWLScript extends RWLNode (
  blockName = "script"
  kind = "script"
  
  def init(body, object header, object inst) (
    self.body @= body
    self.header @= header
    
    void self.parse()
    void self.makeModule(inst)
  )
  
  def parse() (
    self.ast @= null
    // TODO: try
    local parser @= rtr.ast.Parser(body)
    self.ast @= parser.parse()
  )
  
  def makeModule(object inst) (
    if self.ast != null (
      self.mod @= rtr.main.Module(self.ast)
      void inst.rtrInst.addModule(self.mod)
    )
  )
  
  def update(array area, object context) (
    if self.mod != null (
      void self.mod.runEvent({
        name: "onupdate"
      }, {})
    )
  )
)

class RWLElement extends RWLNode (
  kind = "element"
  def init(object value, object header) (
    self.value @= value
    self.header @= header
    void self.initGlobal()
  )
  
  def update(array area, object context) (
    void self.updateGlobal(area, context)
    local text = null
    
    switch self.value.type (
      case "str"; case "num"
        text = self.value.value.toStr()
        break
    )
    
    if text == null (
      return rwl.error.Error("InvalidElemType", {
        valueType: self.value.type
      })
    )
    
    // font
    //<font>
    local size @= self.expectOnHeader("size", "num")
    if size.isError (
      return size
    )
    size = size["value"] ?? 10
    
    local spacing @= self.expectOnHeader("spacing", "num")
    if spacing.isError (
      return spacing
    )
    spacing = spacing["value"] ?? 1
    
    local line_height @= self.expectOnHeader("line_height", "num")
    if line_height.isError (
      return line_height
    )
    line_height = spacing["line_height"] ?? 1
    
    // positioning
    local padding @= self.getPadding()
    
    local anchor @= self.expectOnHeader("anchor", "str")
    if anchor.isError (
      return anchor
    )
    anchor = anchor["value"]
    
    if context.x == null or context.y == null (
      anchor ??= "c"
    )
    
    if anchor != null (
      if ["tl","t","tr",
          "l","c","r",
          "bl","b","br",
          "top left", "top", "top right",
          "left", "center", "right",
          "bottom left", "bottom", "bottom right"].contains(anchor).not() (
        return rwl.error.Error("InvalidAnchorName", {
          name: anchor
        })
      )
      
      local anchorX = rwl.area.centerX(area)
      local anchorY = rwl.area.centerY(area) + (line_height * 1 * size)
      local anchorXType = "c"
      local anchorYType = "c"
      
      if anchor.endsWith("l") or anchor.endsWith("left") (
        anchorX = area[1] + padding[1]
        anchorXType = "l"
      )
      if anchor.endsWith("r") or anchor.endsWith("right") (
        anchorX = area[3] - padding[3]
        anchorXType = "r"
      )
      
      if anchor.startsWith("t") or anchor.endsWith("top") (
        anchorY = area[4] - padding[4]
        anchorYType = "t"
      )
      if anchor.startsWith("b") or anchor.endsWith("bottom") (
        anchorY = area[2] + padding[2]
        anchorYType = "b"
      )
      
      context.x = anchorX
      context.y = anchorY
      context.anchorX = anchorXType
      context.anchorY = anchorYType
    )
    
    local boxAlignment = context.anchorX
    
    local alignment @= self.expectOnHeader("alignment", "str")
    if alignment.isError (
      return alignment
    )
    alignment = alignment["value"]
    if alignment != null (
      if ["l","c","r",
          "left", "center", "right"].contains(alignment).not() (
        return rwl.error.Error("InvalidAlignmentName", {
          name: anchor
        })
      )
      
      if alignment.endsWith("l") or alignment.endsWith("left") (
        alignment = "l"
      )
      if alignment.endsWith("r") or alignment.endsWith("right") (
        alignment = "r"
      )
    )
    alignment ??= boxAlignment
    
    // appearance
    //<link>
    //<decoration>
    local color @= self.expectOnHeader("color", "color")
    if color.isError (
      return color
    )
    color = color.value
    if color != null (
      context.color = color
    )
    color ??= context.color
    
    local lines @= text.split("\n")
    local width = 0
    for lineI lines.len (
      width = max(width, lines[lineI].len * size * spacing)
    )
    local height = lines.len * line_height * 2 * size
    
    local x = context.x
    if boxAlignment == "l" (
      x += width / 2
    )
    if boxAlignment == "r" (
      x += width / -2
    )
    
    context.y -= height / (context.anchorY == "b" ? -2 2)
    
    self.lines @= []
    local y = context.y + (height / 2)
    for lineI lines.len (
      y -= size * line_height
      local lineW = shared.graphics.getTextWidth(lines[lineI]) * size
      local lx = x
      if alignment == "l" (
        lx += width / -2
      )
      if alignment == "r" (
        lx += width / 2 - lineW
      )
      if alignment == "c" (
        // account for char spacing
        lx += lineW * -.5
      )
      void self.lines.append([lines[lineI], lx, y, size, color])
      y -= size * line_height
    )
    
    self.debugArea @= [
      x - (width / 2),
      context.y - (height / 2),
      x + (width / 2),
      context.y + (height / 2)
    ]
    self.padding @= padding
    
    context.y -= height / (context.anchorY == "b" ? -2 2)
  )
  
  def render() (
    if self.header.flags.contains("Hidden") (
      void self.renderDevtools()
      return
    )
    
    for lineI self.lines.len (
      local line @= self.lines[lineI]
      void shared.graphics.ptext(line[1], line[2], line[3], line[4], line[5])
    )
    
    void rwl.debug.box(self.debugArea ?? [])
    void self.renderDevtools()
  )
  
  def renderDevtools() (
    if self.elemI == devtools.main.hoveredElement (
      void shared.graphics.filledTransparentArea(self.debugArea, #0ff, 20)
      
      local fullArea = rwl.area.margin(self.debugArea, self.padding)
     
      if fullArea != null (
        // left
        void shared.graphics.filledTransparentArea([
          fullArea[1],
          fullArea[2],
          self.debugArea[1],
          fullArea[4]
        ], #f0f, 20)
        // right
        void shared.graphics.filledTransparentArea([
          self.debugArea[3],
          fullArea[2],
          fullArea[3],
          fullArea[4]
        ], #f0f, 20)
        // top
        void shared.graphics.filledTransparentArea([
          self.debugArea[1],
          self.debugArea[4],
          self.debugArea[3],
          fullArea[4]
        ], #f0f, 20)
        // bottom
        void shared.graphics.filledTransparentArea([
          self.debugArea[1],
          fullArea[2],
          self.debugArea[3],
          self.debugArea[2]
        ], #f0f, 20)
      )
    )
  )
)

class RWLIcon extends RWLNode (
  kind = "icon"
  
  def update(array area, object context) (
    local scale @= self.expectOnHeader("scale", "num")
    if scale.isError (
      return scale
    )
    self.scale = size.value ?? 1
    
    local src @= self.expectOnHeader("src", "str")
    if src.isError (
      return src
    )
    if src == null (
      return rwl.error.Error("NoIconSrc", {})
    )
    self.src = src.value
    
    local color @= self.expectOnHeader("color", "color")
    if color.isError (
      return color
    )
    self.color = color.value
    
    // TODO: anchors?
    self.x = rwl.area.centerX(area)
    self.y = rwl.area.centerY(area)
  )
  
  def render() (
    if self.header.flags.contains("Hidden") (
      void self.renderDevtools()
      return
    )
    
    void shared.graphics.picon(self.src, self.x, self.y, self.scale, self.color ?? "#fff")
    void self.renderDevtools()
  )
  
  def init(object header) (
    self.header @= header
  )
)

def UpdateElements(array elements, array area, object context, object parentElem) (
  for i elements.len (
    elements[i].parent @= parentElem
    local out @= elements[i].update(area, context)
    if out.isError (
      return out
    )
  )
)

def RenderElements(array elements) (
  for i elements.len (
    //void
    void elements[i].render()
    void
  )
)

elemI = 0
def AstToElement(ast, object inst) (
  def AstToHeader(header) (
    local flags @= []
    local pairs @= []
    for attrI header.attributes.len (
      local attr @= header.attributes[attrI]
      switch attr.kind (
        case "flag"
          flags.append(attr.data)
          break
        case "key"
          void pairs.append([attr.key, rwl.value.AstToValue(attr.value)])
          break
      )
    )
    return { flags, pairs }
  )
  //log "a" ast
  local header @= AstToHeader(ast.data.header)
  
  switch ast.kind (
    case "block"
      if ast.data.header.key != "script" (
        local children @= AstsToElements(ast.data.content.elements, inst)
      )
      if typeof(children) != "array" and children["isError"] (
        return children
      )
      switch ast.data.header.key (
        // top level
        case "root"
          return rwl.main.RWLRoot(children, header)
        
        // normal
        case "frame"
          return rwl.main.RWLFrame(children, header)
        case "section"
          return rwl.main.RWLSection(children, header)
        
        case "script"
          return rwl.main.RWLScript(shared.utils.removeIndents(ast.data.content), header, inst)
        
        case "button"
          return rwl.main.RWLButton(children, header)
        
        default
          return rwl.error.Error("UnknownBlockType", {
            blockType: ast.data.header.key
          })
          break
      )
      break
    
    case "element"
      return rwl.main.RWLElement(rwl.value.AstToValue(ast.data.value), header)
    
    case "icon"
      return rwl.main.RWLIcon(header)
    
    default
      return rwl.error.Error("UnknownElementKind", {
        elementKind: ast.kind
      })
      break
  )
)

def AstsToElements(elements, object inst) (
  local elems @= []
  for i elements.len (
    local out @= AstToElement(elements[i], inst)
    if out.isError (
      return out
    )
    void elems.append(out)
  )
  return elems
)

class RWL (
  def init(object ast, object rtrInst) (
    self.rtrInst @= rtrInst
    self.errored = false
    self.needsUpdate = true
    self.hasUpdated = false
    
    self._lastW = 0
    self._lastH = 0
    
    void self.loadFromAst(ast)
  )
  
  def loadFromAst(object ast) (
    self.ast @= ast
    self.elements @= rwl.main.AstsToElements(ast.elements, self)
    
    if typeof(self.elements) != "array" and self.elements.isError (
      error self.elements.stringify()
      self.errored = true
      return
    )
  )
  
  def update(array area) (
    self.hasUpdated = true
    if self.errored (
      return
    )
    
    local out @= rwl.main.UpdateElements(self.elements, area, {
      inst: self,
      root: true
    }, {})
    if out.isError (
      error out.stringify()
      self.errored = true
      self.errormsg = out.stringify()
    )
  )
  
  def checkUpdate(array area) (
    local w = rwl.area.width(area)
    local h = rwl.area.height(area)
    
    // if the width or height has changed, update
    if w != self._lastW or h != self._lastH (
      self.needsUpdate = true
      
      self._lastW = w
      self._lastH = h
    )
    
    if self.needsUpdate (
      void self.update(area)
      self.needsUpdate = false
    )
  )
  
  def interactUpdate(object context) (
    if self.errored (
      return
    )
  
    context.top = null
    context.topI = 0
    for i self.elements.len (
      void self.elements[i].interactUpdate(context)
    )
    
    if context.top != null (
      void context.top.topUpdate(context)
    )
    void shared.input.reset()
  )
  
  def checkElemUpdate() (
    if self.errored (
      return
    )
  
    for i self.elements.len (
      void self.elements[i].checkUpdate()
    )
  )
  
  def render(array area) (
    void self.checkUpdate(area)
  
    self.worker.area @= area
    if self.errored (
      goto rwl.area.centerX(area) rwl.area.centerY(area)
      centext "rwl errored :(" 12 : c#shared.theme.seco
      if self.errormsg != null (
        centext self.errormsg 8 : c#shared.theme.prim chy#-20
      )
      return
    )
    
    void rwl.main.RenderElements(self.elements)
  )
  
  def getElement(string id) (
    local queue @= [...self.elements]
    while queue.len > 0 (
      local elem @= queue.shift()
      
      if elem.id == id (
        return elem
      )
      
      if elem.children != null (
        for i elem.children.len (
          void queue.append(elem.children[i])
        )
      )
    )
  )
)
