
class RTRDocument extends rtr.value.RTRValue (
  def init(object doc) (
    self.doc @= doc
  )

  def getRtrType() (
    return rtr.value.RTRTypeValue({
      name: "document"
    })
  )
  
  def getItem(key) (
    switch key.stringify() (
      // values
      case "title"
        return rtr.value.RTRStrValue(self.doc.title)
      case "icon"
        if self.doc.icon == null (
          return rtr.value.RTRNullValue()
        )
        return rtr.value.RTRStrValue(self.doc.icon)
      case "root"
        local elems @= self.doc.rwlInst.elements
        for i elems.len (
          local elem @= elems[i]
          if elem.name == "RWLRoot" (
            return rtr.rwl.RTRElement(elem)
          )
        )
        return rtr.value.RTRNullValue()
      
      // methods
      case "redirect"
        return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (
          void doc.doc.loadUrl(shared.url.Url(args[1].stringify()))
          void layouts.shared.state.updateTab()
        ), self)
      case "getElement"
        return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (
          local elem @= doc.doc.rwlInst.getElement(args[1].stringify())
          if elem == null (
            return rtr.value.RTRNullValue()
          )
          return rtr.rwl.RTRElement(elem)
        ), self)
      case "createTextElement"
        return rtr.value.RTROslFuncValue(def(args, _inst) -> (
          return rtr.rwl.RTRElement(rwl.main.RWLElement(rtr.rwl.rtrValueToRwlValue(args[1]), { flags: [], pairs: [] }))
        ))
      case "createScript"
        return rtr.value.RTROslFuncValue(def(args, _inst, doc) -> (
          local elem @= rwl.main.RWLScript(args[1].stringify(), { flags: [], pairs: [] }, doc.doc.rwlInst)
          void elem.start()
          return rtr.rwl.RTRElement(elem)
        ), self)
      case "createContainer"
        return rtr.value.RTROslFuncValue(def(args, _inst) -> (
          local kind = args[1].stringify()
          switch kind (
            case "frame"
              return rtr.rwl.RTRElement(rwl.main.RWLFrame([], { flags: [], pairs: [] }))
            case "section"
              return rtr.rwl.RTRElement(rwl.main.RWLSection([], { flags: [], pairs: [] }))
            case "button"
              return rtr.rwl.RTRElement(rwl.main.RWLButton([], { flags: [], pairs: [] }))
            
            default
              throw "unknown container type" + kind
          )
          return rtr.rwl.RTRElement(rwl.main.RWLElement(rtr.rwl.rtrValueToRwlValue(args[1]), { flags: [], pairs: [] }))
        ))
      
      default
        throw "unknown property" + key.stringify() + "on document"
    )
  )
  
  def setItem(key, value) (
    switch key.stringify() (
      case "title"
        self.doc.title = value.stringify()
        break
      case "icon"
        self.doc.icon = value.stringify()
        break
      default
        throw "cannot set property" + key.stringify() + "on document"
    )
  )
)

class RTRElement extends rtr.value.RTRValue (
  isRwlElem = true
  
  def init(object elem) (
    self.elem @= elem
  )

  def getRtrType() (
    return rtr.value.RTRTypeValue({
      name: "element"
    })
  )
  
  def stringify() (
    local txt = (self.elem.blockName ?? self.elem.kind).toStr()
    if self.elem.id != null (
      txt ++= ":" ++ self.elem.id
    )
    return "<" ++ txt ++ ">"
  )
  
  def getItem(key) (
    local k = key.stringify()
    
    switch k (
      case "toggleFlag"
        return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (
          local flags @= elem.elem.header.flags
          local name = args[1].stringify()
          
          if flags.contains(name) (
            void flags.delete(flags.index(name))
          ) else (
            void flags.append(name)
          )
          
          elem.elem.needsUpdate = true
          void elem.elem.checkUpdate()
        ), self)
      case "addFlag"
        return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (
          local flags @= elem.elem.header.flags
          local name = args[1].stringify()
          
          if !flags.contains(name) (
            void flags.append(name)
          )
          
          elem.elem.needsUpdate = true
          void elem.elem.checkUpdate()
        ), self)
      case "removeFlag"
        return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (
          local flags @= elem.elem.header.flags
          local name = args[1].stringify()
          
          if flags.contains(name) (
            void flags.delete(flags.index(name))
          )
          
          elem.elem.needsUpdate = true
          void elem.elem.checkUpdate()
        ), self)
      case "hasFlag"
        return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (
          local flags @= elem.elem.header.flags
          local name = args[1].stringify()
          
          return rtr.value.RTRBoolValue(flags.contains(name))
        ), self)
      
      case "addChild"
        return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (
          if elem.elem.children == null (
            throw elem.kind + "cannot contain children"
          )
          if !args[1].isRwlElem (
            throw "argument is not rwl element"
          )
          void elem.elem.children.append(args[1].elem)
          
          void elem.elem.updateParentFromCache()
        ), self)
      case "popChild"
        return rtr.value.RTROslFuncValue(def(args, _inst, elem) -> (
          if elem.elem.children == null (
            throw elem.kind + "doesnt contain children"
          )
          local idx = args.len > 0 ? args[1].numbify() 1
          local out @= elem.elem.children[idx]
          if out != null (
            out @= rtr.rwl.RTRElement(out)
          ) else (
            out @= rtr.value.RTRNullValue()
          )
          void elem.elem.children.delete(idx)
          
          void elem.elem.updateParentFromCache()
          return out
        ), self)
    )
    
    for i self.elem.header.pairs.len (
      local pair @= self.elem.header.pairs[i]
      if pair[1] == k (
        return rtr.rwl.rwlValueToRtrValue(pair[2])
      )
    )
    return rtr.value.RTRNullValue()
  )
  
  def setItem(key, value) (
    local k = key.stringify()
    local v @= rtr.rwl.rtrValueToRwlValue(value)
    for i self.elem.header.pairs.len (
      local pair @= self.elem.header.pairs[i]
      if pair[1] == k (
        pair[2] @= v
        void self.elem.updateParentFromCache()
        return
      )
    )
    
    void self.elem.header.pairs.append([
      k, v
    ])
    
    void self.elem.updateParentFromCache()
  )
)

def rwlValueToRtrValue(object val) (
  switch val.type (
    case "str"
      return rtr.value.RTRStrValue(val.value)
    case "num"
      return rtr.value.RTRNumValue(val.value)
    // percentage
    // color
  )
  
  return rtr.value.RTRNullValue()
)

def rtrValueToRwlValue(object val) (
  local type @= val.getRtrType()
  
  switch type.data.name (
    case "str"
      return rwl.value.RWLStrValue(val.value)
    case "num"
      return rwl.value.RWLNumValue(val.value)
    case "color"
      return rwl.value.RWLColorValue(val.value)
  )
  
  throw "cannot set" + type.stringify() + "as rwl property"
)

// applies all rwl related apis to rtr
def addToInst(object doc, object rtrInst) (
  local mods @= rtrInst.modules.getValues()
  for i mods.len (
    addToMod(doc, mods[i])
  )
)

def addToMod(object doc, object mod) (
  void mod.declScopeVar("document", RTRDocument(doc))
  void mod.declScopeVar("theme", rtr.value.RTRObjValue({
    back: rtr.value.RTRColorValue(shared.theme.back),
    prim: rtr.value.RTRColorValue(shared.theme.prim),
    seco: rtr.value.RTRColorValue(shared.theme.seco),
    tert: rtr.value.RTRColorValue(shared.theme.tert),
    text: rtr.value.RTRColorValue(shared.theme.text),
    accent: rtr.value.RTRColorValue(shared.theme.accent),
  }))
)
